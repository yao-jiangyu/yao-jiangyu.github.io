<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>同步FIFO详解</title>
    <link href="/sync_fifo/"/>
    <url>/sync_fifo/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>在学习科研的闲暇之余，打算记录一些FPGA基础知识，方便后续自己的查阅复习，如果能帮助到其他同学那就更好了。本文主要介绍同步FIFO的实现原理，内容如有不妥之处，欢迎评论区指正，共同学习进步。</p>          </div><h1 id="fifo概述">1、FIFO概述</h1><p>FIFO（First In FirstOut）是一种先进先出的数据存储、缓存器。我们知道一般的存储器是用外部的读写地址来进行读写，而FIFO这种存储器的结构并不需要外部的读写地址而是通过内部的读写指针自动的加一操作来控制读写，这也就决定了FIFO只能顺序的读写数据。FIFO本质上是由 RAM 加读写控制逻辑构成的一种先进先出的数据缓冲器。</p><p>FIFO 有两种类型：同步 FIFO 和异步 FIFO。同步 FIFO使用同一个时钟信号来控制数据的读写，而异步 FIFO有两个时钟信号，一个用于读操作，另一个用于写操作。</p><p>同步 FIFO 的作用一般是做一个数据缓冲，也就是一个 buffer。异步 FIFO有两个较为重要的作用：一个是实现数据在不同时钟域进行传递，另一个作用就是实现不同数据宽度的数据接口。</p><h1 id="同步fifo的实现">2、同步FIFO的实现</h1><p>FIFO的设计原则是任何时候都不能向满FIFO中写入数据（写溢出），任何时候都不能从空FIFO中读取数据（读溢出）。FIFO设计的核心是空满判断。FIFO 设置读，写地址指针，FIFO 初始化的时候读指针和写指针都指向地址为 0 的位置，当往 FIFO里面每写一个数据，写地址指针自动加 1 指向下一个要写入的地址。当从 FIFO里面每读一个数据，读地址指针自动加 1指向下一个要读出的地址，最后通过比较读地址指针和写地址指针的大小来确定空满状态。</p><ul><li><p>写指针：总是指向下一个将要被写入的单元，复位时，指向第 1个单元（编号为 0）。</p></li><li><p>读指针：总是指向当前要被读出的数据，复位时，指向第 1个单元（编号为 0）。</p></li></ul><p>产生可靠的 FIFO 读写指针和生成 FIFO “空”/“满”状态标志是 FIFO设计的关键。</p><p>当读写指针相等时，表明 FIFO为空，这种情况发生在复位操作时，或者当读指针读出 FIFO中最后一个数据后，追赶上了写指针时，如下图所示<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[掰开揉碎讲 FIFO（同步FIFO和异步FIFO）](https://www.cnblogs.com/DoreenLiu/p/17348480.html)">[1]</span></a></sup>：</p><figure><img src="/img/同步fifo/image.gif" alt="读空" /><figcaption aria-hidden="true">读空</figcaption></figure><p>当读写指针再次相等时，表明 FIFO为满，这种情况发生在写指针转了一圈，折回来又追上了读指针，如下图所示<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[掰开揉碎讲 FIFO（同步FIFO和异步FIFO）](https://www.cnblogs.com/DoreenLiu/p/17348480.html)">[1]</span></a></sup>：</p><figure><img src="/img/同步fifo/image-1.gif" alt="写满" /><figcaption aria-hidden="true">写满</figcaption></figure><p>参考刀哥的思路，我们将有两种思路进行同步fifo的设计。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[同步FIFO的两种Verilog设计方法（计数器法、高位扩展法）](https://blog.csdn.net/wuzhikaidetb/article/details/121136040?ops_request_misc=%257B%2522request%255Fid%2522%253A%252227622c9b4e0ef88928f3ab4dfabed8fd%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=27622c9b4e0ef88928f3ab4dfabed8fd&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-121136040-null-null.nonecase&amp;utm_term=fifo&amp;spm=1018.2226.3001.4450)">[2]</span></a></sup></p><h2 id="计数器法实现同步fifo">2.1、计数器法实现同步FIFO</h2><p>构建一个计数器，该计数器(fifo_cnt)用于指示当前 FIFO中数据的个数：</p><ul><li><p>复位时，该计数器为 0，FIFO 中的数据个数为 0。</p></li><li><p>当读写使能信号均有效时，说明又读又写，计数器不变，FIFO中的数据个数无变化。</p></li><li><p>当写使能有效且 full = 0，则 fifo_cnt + 1；表示写操作且 FIFO未满时候，FIFO 中的数据增加了 1 。</p></li><li><p>当读使能有效且 empty = 0，则 fifo_cnt - 1;表示读操作且 FIFO未空时候，FIFO 中的数据减少了 1 。</p></li><li><p>fifo_cnt = 0 的时候，表示 FIFO 空，需要设置 empty = 1；fifo_cnt =fifo的深度 的时候，表示 FIFO 现在已经满，需要设置 full = 1。</p></li></ul><p>这种方法设计比较简单，但是需要的额外的计数器，就会产生额外的资源，而且当FIFO 比较大时，会降低 FIFO 最终可以达到的速度。</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">//读操作，更新读地址</span><span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rst_n<span class="token punctuation">)</span>rd_addr <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>empty <span class="token operator">&amp;&amp;</span> rd_en<span class="token punctuation">)</span><span class="token keyword">begin</span>rd_addr <span class="token operator">&lt;=</span> rd_addr <span class="token operator">+</span> <span class="token number">1'd1</span><span class="token punctuation">;</span>data_out <span class="token operator">&lt;=</span> fifo_buffer<span class="token punctuation">[</span>rd_addr<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">end</span><span class="token comment">//写操作,更新写地址</span><span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rst_n<span class="token punctuation">)</span>wr_addr <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>full <span class="token operator">&amp;&amp;</span> wr_en<span class="token punctuation">)</span><span class="token keyword">begin</span>wr_addr <span class="token operator">&lt;=</span> wr_addr <span class="token operator">+</span> <span class="token number">1'd1</span><span class="token punctuation">;</span>fifo_buffer<span class="token punctuation">[</span>wr_addr<span class="token punctuation">]</span><span class="token operator">&lt;=</span>data_in<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">end</span><span class="token comment">//更新计数器</span><span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rst_n<span class="token punctuation">)</span>fifo_cnt <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">begin</span><span class="token function">case</span><span class="token punctuation">(</span><span class="token operator">&#123;</span>wr_en<span class="token punctuation">,</span>rd_en<span class="token operator">&#125;</span><span class="token punctuation">)</span><span class="token number">2'b00</span><span class="token punctuation">:</span>fifo_cnt <span class="token operator">&lt;=</span> fifo_cnt<span class="token punctuation">;</span><span class="token comment">//不读不写</span><span class="token number">2'b01</span><span class="token punctuation">:</span>                               <span class="token comment">//仅仅读</span><span class="token function">if</span><span class="token punctuation">(</span>fifo_cnt <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>fifo_cnt <span class="token operator">&lt;=</span> fifo_cnt <span class="token operator">-</span> <span class="token number">1'b1</span><span class="token punctuation">;</span> <span class="token number">2'b10</span><span class="token punctuation">:</span>                                 <span class="token comment">//仅仅写</span><span class="token function">if</span><span class="token punctuation">(</span>fifo_cnt <span class="token operator">!=</span> DATA_DEPTH<span class="token punctuation">)</span>fifo_cnt <span class="token operator">&lt;=</span> fifo_cnt <span class="token operator">+</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>   <span class="token number">2'b11</span><span class="token punctuation">:</span>fifo_cnt <span class="token operator">&lt;=</span> fifo_cnt<span class="token punctuation">;</span>           <span class="token comment">//读写同时</span><span class="token keyword">default</span><span class="token punctuation">:</span><span class="token punctuation">;</span>                              <span class="token keyword">endcase</span><span class="token keyword">end</span><span class="token keyword">end</span><span class="token comment">//依据计数器状态更新指示信号</span><span class="token keyword">assign</span> full  <span class="token operator">=</span> <span class="token punctuation">(</span>fifo_cnt <span class="token operator">==</span> DATA_DEPTH<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1'b1</span> <span class="token punctuation">:</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token comment">//满信号</span><span class="token keyword">assign</span> empty <span class="token operator">=</span> <span class="token punctuation">(</span>fifo_cnt <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">?</span> <span class="token number">1'b1</span> <span class="token punctuation">:</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token comment">//空信号</span></code></pre></div></figure><p>仿真依次进行以下测试：基本单次读写测试、FIFO写满测试、FIFO读空测试、同时读写操作测试、边界条件测试</p><figure><img src="/img/同步fifo/image.png" alt="计数器法-同步FIFO-仿真" /><figcaption aria-hidden="true">计数器法-同步FIFO-仿真</figcaption></figure><h2 id="高位扩展法实现同步fifo">2.2、高位扩展法实现同步FIFO</h2><p>高位扩展法是一种更加高效的FIFO实现方式。它通过在读写指针上增加一个额外的高位作为指示位，避免使用独立的计数器。其原理如下：</p><ul><li><p>读写指针的宽度要比FIFO深度所需的地址位宽多1位</p></li><li><p>指针的低位用于寻址，高位用于判断FIFO的空满状态</p></li><li><p>当写指针与读指针相比，最高位不同而其他位相同时，说明写入数据已经超过一轮，此时FIFO已满。</p></li><li><p>当写指针与读指针的最高位和其他位都相同时，说明读指针已经追上写指针位置，此时FIFO为空。</p></li></ul><p>高位扩展法要求FIFO深度为2的N次幂，以确保地址自然溢出和空满条件正确性。若深度非2的N次幂，需引入复杂的手动控制逻辑，失去高位扩展法的简洁性和高效性。</p><p>高位扩展法取消了计数器，在原来的基础上更改了读写指针的更新逻辑，通过比较读写指针的高位和低位来判断FIFO的空满状态。</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">//当所有位相等时，读指针追到到了写指针，FIFO被读空</span><span class="token keyword">assign</span>empty <span class="token operator">=</span> <span class="token punctuation">(</span> wr_ptr <span class="token operator">==</span> rd_ptr <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1'b1</span> <span class="token punctuation">:</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token comment">//当最高位不同但是其他位相等时，写指针超过读指针一圈，FIFO被写满</span><span class="token keyword">assign</span>full  <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>wr_ptr_msb <span class="token operator">!=</span> rd_ptr_msb <span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span> wr_ptr_true <span class="token operator">==</span> rd_ptr_true <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">?</span> <span class="token number">1'b1</span> <span class="token punctuation">:</span> <span class="token number">1'b0</span><span class="token punctuation">;</span></code></pre></div></figure><p>同样进行仿真测试：基本单次读写测试、FIFO写满测试、FIFO读空测试、同时读写操作测试、边界条件测试</p><figure><img src="/img/同步fifo/image1.png" alt="高位扩展法-同步FIFO-仿真" /><figcaption aria-hidden="true">高位扩展法-同步FIFO-仿真</figcaption></figure><h1 id="代码下载">3、代码下载</h1><p>博客中涉及到的代码均在我的<ahref="https://github.com/yao-jiangyu/MyBlogCode">GitHub仓库</a>中，欢迎大家下载学习。</p><h1 id="参考资料">4、参考资料</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><ahref="https://www.cnblogs.com/DoreenLiu/p/17348480.html">掰开揉碎讲FIFO（同步FIFO和异步FIFO）</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><ahref="https://blog.csdn.net/wuzhikaidetb/article/details/121136040?ops_request_misc=%257B%2522request%255Fid%2522%253A%252227622c9b4e0ef88928f3ab4dfabed8fd%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=27622c9b4e0ef88928f3ab4dfabed8fd&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-121136040-null-null.nonecase&amp;utm_term=fifo&amp;spm=1018.2226.3001.4450">同步FIFO的两种Verilog设计方法（计数器法、高位扩展法）</a><a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>FPGA基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>FIFO</tag>
      
      <tag>Verilog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDLBits刷题日记（三）</title>
    <link href="/HDLBits_three/"/>
    <url>/HDLBits_three/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>打算利用碎片化时间重温一遍Verilog语法，好记忆不如烂笔头，在此记录一下HDLBits刷题的过程，记录一些知识点，方便日后再次复习。</p>          </div><h1 id="verilog-language---vectors">1、Verilog Language - Vectors</h1><h2 id="problem-10-vectors">Problem 10 : Vectors</h2><p>向量是一组 wire信号的集合，通过赋予这一组信号的集合一个名称，以便于访问其中的 wire信号</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> w <span class="token punctuation">;</span> <span class="token comment">// 声明了一个 8 bit 位宽的信号，向量名为 w，等价于 8 个 1bit 位宽的 wire 信号。</span></code></pre></div></figure><p>请注意声明向量时，位宽位于向量名之前。但在片选向量中某个 bit时，使用的语法同 C 语言数组中取出某个数的语法相同。</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">99</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> my_vector<span class="token punctuation">;</span>      <span class="token comment">// Declare a 100-element vector </span><span class="token keyword">assign</span> out <span class="token operator">=</span> my_vector<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Part-select one bit out of the vector </span></code></pre></div></figure><p>在同时声明多个向量时，位宽对于声明的多个向量都是起作用的，比如：</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span> <span class="token comment">// Declares three 8-bit vectors</span></code></pre></div></figure><p>Build a circuit that has one 3-bit input, then outputs the samevector, and also splits it into three separate 1-bit outputs.</p><p>构建一个电路，有一个 3位输入，然后输出相同的向量，并将其分成三个单独的 1 位输出。</p><figure><img src="/img/HDLBits_three/Vector0.png" alt="Vector0" /><figcaption aria-hidden="true">Vector0</figcaption></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">top_module</span><span class="token punctuation">(</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> vec<span class="token punctuation">,</span>     <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> outv<span class="token punctuation">,</span>    <span class="token keyword">output</span> o2<span class="token punctuation">,</span>    <span class="token keyword">output</span> o1<span class="token punctuation">,</span>    <span class="token keyword">output</span> o0<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> outv <span class="token operator">=</span> vec<span class="token punctuation">;</span>    <span class="token comment">// This is ok too: assign &#123;o2, o1, o0&#125; = vec;</span>    <span class="token keyword">assign</span> o0 <span class="token operator">=</span> vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> o1 <span class="token operator">=</span> vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> o2 <span class="token operator">=</span> vec<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre></div></figure><p>如果想要片选多个 bit，那么可以通过如下操作实现:</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> w <span class="token operator">=</span> vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> </code></pre></div></figure><h2 id="problem-11-vectors-in-more-detail">Problem 11 : Vectors in moredetail</h2><p>向量的声明规则如下：</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">type</span> <span class="token punctuation">[</span>upper<span class="token punctuation">:</span>lower<span class="token punctuation">]</span> vector_name<span class="token punctuation">;</span></code></pre></div></figure><p>其中 type 指定了向量的类型，一般为 wire 或者 reg 型。关于 reg型，会在后续介绍中引入。如果向量为模块的输入输出端口，那么可以在 type中添加 input/output 定义。</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> w<span class="token punctuation">;</span>         <span class="token comment">// 8-bit wire</span><span class="token keyword">reg</span>  <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span> x<span class="token punctuation">;</span>         <span class="token comment">// 4-bit reg</span><span class="token keyword">output</span> <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> y<span class="token punctuation">;</span>   <span class="token comment">// 1-bit reg  output port (但仍然是一个向量)</span><span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> z<span class="token punctuation">;</span>  <span class="token comment">// 6-bit wire input (在位宽中使用负数作为 index 是可以的，代表倒数第二位)</span><span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">;</span>       <span class="token comment">// 4-bit output wire. wire 为默认定义，在没有显式声明的情况下</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">]</span> b<span class="token punctuation">;</span>         <span class="token comment">// 8-bit wire b[0]是这个向量的 最高位 MSB（most-significant bit）</span></code></pre></div></figure><p>声明为 [3:0] w 的向量，LSB 是 w[0]，如果声明为 [0:3] w,那么 w[3] 是LSB 。LSB 指的是二进制数中权值最低的一位。</p><p>在 Verilog 语法中，可以将向量声明为 [3:0],这种语法最为常见，但也可以将向量声明为[0:3]。这都是可以的，但必须在声明和使用时保持一致。如果声明为 wire [3:0]w ，但使用 w[0:3]赋值，这是不允许的，保持前后如一的比特顺序是很重要的一点。</p><p>信号变量有两种声明方式，一是使用 wire 或者 assign语句进行显示声明和定义，二是综合器的隐式声明和定义。变量隐式声明的危害在于，当你将一个未定义声明的信号连接到模块的输入输出端口时，综合器会“热心”地帮助你声明这个信号，但它只会将其声明为1 bit wire 型信号。</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> c<span class="token punctuation">;</span>   <span class="token comment">// Two vectors</span><span class="token keyword">assign</span> a <span class="token operator">=</span> <span class="token number">3'b101</span><span class="token punctuation">;</span>  <span class="token comment">// a = 101</span><span class="token keyword">assign</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>       <span class="token comment">// b =   1  implicitly-created wire</span><span class="token keyword">assign</span> c <span class="token operator">=</span> b<span class="token punctuation">;</span>       <span class="token comment">// c = 001  &lt;-- bug</span>my_module i1 <span class="token punctuation">(</span>d<span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// d and e are implicitly one-bit wide if not declared.</span>                    <span class="token comment">// This could be a bug if the port was intended to be a vector.</span></code></pre></div></figure><p>通过添加 `default_nettype none宏定义会关闭隐式声明功能，那么这样一来，使用未声明的变量就会变成一个Error 而不再只是 Warning。</p><p>unpacked 和 packed数组：在声明向量时，一般向量的位宽写在向量名之前。位宽定义了向量的packed维度，该向量中每位信号都被视作一个块进行操作（在仿真中，硬件中有所不同）。unpacked维度定义在向量名之后，通常用来定义向量数组长度。</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> mem <span class="token punctuation">[</span><span class="token number">255</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// 256 unpacked elements, each of which is a 8-bit packed vector of reg.</span><span class="token keyword">reg</span> mem2 <span class="token punctuation">[</span><span class="token number">28</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">// 29 unpacked elements, each of which is a 1-bit reg.</span></code></pre></div></figure><p>获取向量元素，也称片选：</p><p>通过向量名可以获得整个向量，在下方的 assign 语句中，向量名 a代表了向量中的所有比特为信号。</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">;</span><span class="token keyword">assign</span> w <span class="token operator">=</span> a<span class="token punctuation">;</span> </code></pre></div></figure><p>在 assign赋值操作中，如果等号左右两侧信号的位宽不同，那么就会进行截断或者补零操作。左侧信号位宽大于右侧信号位宽，右值的低位赋予左值对应的低位，左值高位的部分赋零。左侧信号位宽小于右侧信号位宽，右值的低位赋予左值对应的低位，右值高位的部分直接被截断。即保留右值的低位。</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog">w<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>      <span class="token comment">// Only the lower 4 bits of w</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token comment">// The lowest bit of x</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span>      <span class="token comment">// ...also the lowest bit of x</span>z<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span>    <span class="token comment">// Z 最低两位</span>b<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>      <span class="token comment">// 如果 b 在声明时 声明为 wire [0:3] b;则不能使用 b [3:0]进行选择</span>b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>      <span class="token comment">// b的高四位.</span><span class="token keyword">assign</span> w<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 将 b 的高位赋予 w 的低位 w[3]=b[0], w[2]=b[1], etc.</span></code></pre></div></figure><p>Build a combinational circuit that splits an input half-word (16bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.</p><p>构建一个组合电路，将输入的半字（16 位，[15:0]）分为低位 [7:0] 和高位[15:8] 字节。</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`default_nettype</span> none     <span class="token comment">// Disable implicit nets. Reduces some types of bugs.</span><span class="token keyword">module</span> <span class="token function">top_module</span><span class="token punctuation">(</span>     <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> in<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> out_hi<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> out_lo <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> out_hi <span class="token operator">=</span> in<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> out_lo <span class="token operator">=</span> in<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre></div></figure><h2 id="problem-12-vector-part-select">Problem 12 : Vector partselect</h2><p>A 32-bit vector can be viewed as containing 4 bytes (bits [31:24],[23:16], etc.). Build a circuit that will reverse the byte ordering ofthe 4-byte word.</p><p>一个 32 位向量可以看作包含 4 个字节（位 [31:24], [23:16],etc.）。构建一个电路，将 4 字节的字节顺序反转。</p><p>AaaaaaaaBbbbbbbbCcccccccDddddddd =&gt;DdddddddCcccccccBbbbbbbbAaaaaaaa</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">top_module</span><span class="token punctuation">(</span>     <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> in<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> out <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> out<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">24</span><span class="token punctuation">]</span> <span class="token operator">=</span> in<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> out<span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">]</span> <span class="token operator">=</span> in<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> out<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> in<span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> out<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> in<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//或者使用&#123;&#125;拼接符</span>    <span class="token comment">// assign out = &#123;in[7:0], in[15:8], in[23:16], in[31:24]&#125;;</span><span class="token keyword">endmodule</span></code></pre></div></figure><h2 id="problem-13-bitwise-operators">Problem 13 : Bitwiseoperators</h2><p>Build a circuit that has two 3-bit inputs that computes thebitwise-OR of the two vectors, the logical-OR of the two vectors, andthe inverse (NOT) of both vectors. Place the inverse of b in the upperhalf of out_not (i.e., bits [5:3]), and the inverse of a in the lowerhalf.</p><p>构建一个电路，有两个 3位输入，计算两个向量的按位或，两个向量的逻辑或，以及两个向量的逆（NOT）。将b 的逆放在 out_not 的上半部分（即，位 [5:3]），将 a的逆放在下半部分。</p><figure><img src="/img/HDLBits_three/Vectorgates.png" alt="Vectorgates" /><figcaption aria-hidden="true">Vectorgates</figcaption></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">top_module</span><span class="token punctuation">(</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> out_or_bitwise<span class="token punctuation">,</span>    <span class="token keyword">output</span> out_or_logical<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> out_not<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> out_or_bitwise <span class="token operator">=</span> a <span class="token operator">|</span> b<span class="token punctuation">;</span>    <span class="token keyword">assign</span> out_or_logical <span class="token operator">=</span> a <span class="token operator">||</span> b<span class="token punctuation">;</span>    <span class="token keyword">assign</span> out_not <span class="token operator">=</span> <span class="token operator">&#123;~</span>b<span class="token punctuation">,</span> <span class="token operator">~</span>a<span class="token operator">&#125;</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre></div></figure><h2 id="problem-14-four-input-gates">Problem 14 : Four-input gates</h2><p>Build a combinational circuit with four inputs, in[3:0]. There are 3outputs:</p><p>out_and: output of a 4-input AND gate. out_or: output of a 4-input ORgate.out_xor: output of a 4-input XOR gate</p><p>构建一个具有四个输入 in[3:0] 的组合电路。有 3 个输出：</p><p>out_and：4 输入 AND 门的输出。out_or：4 输入 OR 门的输出。out_xor：4输入 XOR 门的输出。</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">top_module</span><span class="token punctuation">(</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> in<span class="token punctuation">,</span>    <span class="token keyword">output</span> out_and<span class="token punctuation">,</span>    <span class="token keyword">output</span> out_or<span class="token punctuation">,</span>    <span class="token keyword">output</span> out_xor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> out_and <span class="token operator">=</span> <span class="token operator">&amp;</span>in<span class="token punctuation">;</span>    <span class="token keyword">assign</span> out_or <span class="token operator">=</span> <span class="token operator">|</span>in<span class="token punctuation">;</span>    <span class="token keyword">assign</span> out_xor <span class="token operator">=</span> <span class="token operator">^</span>in<span class="token punctuation">;</span>    <span class="token comment">// 繁琐点的写法</span>    <span class="token comment">// assign out_and = in[3] &amp; in[2] &amp; in[1] &amp; in[0]; </span><span class="token keyword">endmodule</span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>HDLBits刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>HDLBits</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GTY高速收发器（一）：基本架构和时钟架构</title>
    <link href="/GTY%E9%AB%98%E9%80%9F%E6%94%B6%E5%8F%91%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/GTY%E9%AB%98%E9%80%9F%E6%94%B6%E5%8F%91%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>最近在学习高速收发器相关内容，本系列将结合Xilinx官方手册UG578及个人理解，对于GT收发器的一些主要内容进行整理和记录。本文主要介绍GTY的基本架构和时钟架构。</p>          </div><h1 id="gty简介">1. GTY简介</h1><p>通过<ahref="https://docs.amd.com/v/u/en-US/ds890-ultrascale-overview">DS890</a>手册可以查询到我们手头的芯片，拥有76个GTY收发器，无GTM收发器，这个需要更高级别的芯片才会有，如下图所示：</p><figure><img src="/img/GTY高速收发器（一）/image-2.png" alt="图1 GT资源图" /><figcaption aria-hidden="true">图1 GT资源图</figcaption></figure><p>UltraScale 架构中的 GTY 收发器是高能效的收发器，在 UltraScale FPGA中支持 500 Mb/s 到 30.5 Gb/s 的线速率，在 UltraScale+ FPGA 中则支持到<strong>32.75 Gb/s</strong> 的线速率。</p><p>4个<code>GTYE3/4_CHANNEL</code> 和 1个<code>GTYE3/4_COMMON</code>形成一个 Quad，如下图所示。<strong>GTY 收发器原语在 UltraScale FPGA中称为 GTYE3_COMMON 和 GTYE3_CHANNEL，在 UltraScale+ FPGA 中称为GTYE4_COMMON 和 GTYE4_CHANNEL。</strong></p><figure><img src="/img/GTY高速收发器（一）/image.png"alt="图2 GTY收发器Quad配置" /><figcaption aria-hidden="true">图2 GTY收发器Quad配置</figcaption></figure><ul><li><p><strong>GTYE3/4_COMMON原语包含两个LC谐振回路PLL（QPLL0和QPLL1）。</strong>仅当应用中需要使用该PLL时，才需要实例化GTYE3/4_COMMON 原语。QPLL 中的 Q 表示 Quad，表示这个 PLL 是为 Quad 中的4 个通道共享的。QPLL 用于为 Quad 中的所有通道提供时钟。</p></li><li><p><strong>GTYE3/4_CHANNEL 原语由 ChannelPLL（CPLL）、发射端和接收端组成。</strong>之所以叫做 ChannelPLL，是因为它是一个独立的 PLL，用于为每个通道提供时钟。每个GTYE3/4_CHANNEL 原语都有一个独立的 CPLL。</p></li><li><p><strong>一个 GTYE4_CHANNEL 就是我们常说的一个 GTTransceiver，</strong>一个 Quad 就是四个 GT Transceiver。在一个 Quad中，四个 GT Transceiver 共享一个 GTY_COMMON，也就是共享时钟。</p></li></ul><p>GT收发器的TX发送端和RX接收端功能独立，且均由<code>PMA（Physical Media Attachment，物理媒介适配层）</code> 和<code>PCS（Physical Coding Sublayer，物理编码子层）</code>两个子层组成，如下图所示：</p><figure><img src="/img/GTY高速收发器（一）/image-1.png"alt="图3 GTYE3/4_CHANNEL原始拓扑" /><figcaption aria-hidden="true">图3 GTYE3/4_CHANNEL原始拓扑</figcaption></figure><div class="note note-info">            <ul><li><p><strong>PMA子层内部集成了高速串并转换、预加重、接收均衡、时钟发生器及时钟恢复等电路（模拟电路部分）。</strong>SERDES是一个串并转换器，负责FPGA内部的并行数据与GTY接口串行数据之间的转换。预加重技术是针对典型物理连接系统中高频部分的补偿，在发送端加一个高通滤波器，放大高频成分，提高信号质量。预加重只在必要情况下使用，因为预加重会导致功耗和EMC辐射的增加。接收均衡主要用于补偿由频率不同而引起的阻抗/衰减差异。时钟发生器及时钟恢复电路在发送端将时钟与数据绑定发送，在接收端对接收到的数据流恢复时钟，从而避免了在高速传输条件下时钟与数据分开传输所带来的时钟抖动等问题。</p></li><li><p><strong>PCS子层内部集成了8b/10b编/解码、弹性缓冲区、通道绑定和时钟修正等专用电路模块。</strong>8b/10b编码可以避免数据流中出现连续的‘0'或‘1'的情况，避免数据传输的不平衡。利用通道绑定通过在发送数据流中加入K码字符，将多个物理上独立的GTY通道绑定成一个时序逻辑上同步的并行通道，通过增加GTY通道数可以提高接口传输的吞吐率。弹性缓冲区解决恢复时钟与本地时钟的不一致问题，并通过对缓存区中的K码匹配对齐实现通道绑定功能。</p></li><li><p><strong>Transmitter的数据流大致为：</strong>FPGA用户逻辑的数据，进入FPGATX接口，进入PCS，再经过PMA，转换为高速串行数据输出。<strong>Receiver的数据流大致为：</strong>数据由PMA部分接收，转换为并行数据进入PCS，再经过RX接口输出给FPGA用户逻辑处理。</p></li></ul>          </div><p>关于 PMA 和 PCS 内部的细节，在后续的文章会逐步深入。</p><h1 id="gty的时钟架构">2. GTY的时钟架构</h1><p>如下图所示，差分时钟进入FPGA之后，先经过 IBUFDS_GTE3/4转换为单端时钟，<strong>然后作为 QPLL 或者 CPLL 的时钟输入，QPLL 或者CPLL 的输出时钟作为发送和接收部分的时钟信号。</strong></p><figure><img src="/img/GTY高速收发器（一）/image-3.png" alt="图4 四通道配置" /><figcaption aria-hidden="true">图4 四通道配置</figcaption></figure><p>当参考时钟来自 GTYE3/4_COMMON 的 QPLL 时，必须实例化 GTYE3/4_COMMON原语。又每个通道包含一个通道锁相环( Channel PLL，CPLL)，因此，参考时钟可以直接连接到 GTYE3/4_CHANNEL 原语，此时不需要实例化GTYE3/4_COMMON 原语。</p><h2 id="参考时钟输入输出结构">2.1 参考时钟输入/输出结构</h2><p>GTY收发器中的参考时钟结构支持两种操作模式：输入模式和输出模式。<strong>在输入工作模式下，</strong>在专用参考时钟I/O 引脚上提供时钟，用于驱动 Quad 或 ChannelPLLs。<strong>在输出工作模式下，</strong>来自于同一 Quad内四个通道中任意一个恢复时钟 (RXRECCLKOUT) 都可以路由到专用参考时钟 I/O引脚。然后，此输出时钟可用作不同位置的参考时钟输入。运行过程中无法改变操作模式。</p><h3 id="参考时钟输入结构">2.1.1 参考时钟输入结构</h3><figure><img src="/img/GTY高速收发器（一）/image-4.png"alt="图5 参考时钟输入结构" /><figcaption aria-hidden="true">图5 参考时钟输入结构</figcaption></figure><h3 id="参考时钟输出结构">2.1.2 参考时钟输出结构</h3><p>参考时钟输出模式可通过两个软件原语之一实现：OBUFDS_GTE3/4_ADV 和OBUFDS_GTE3/4。原语的选择取决于具体的应用。当 RXRECCLKOUT始终来自同一通道时，请使用 OBUFDS_GTE3/4。如果提供 RXRECCLKOUT的通道在运行时可能会发生变化，请使用 OBUFDS_GTE3/4_ADV。使用OBUFDS_GTE3/4_ADV 原语时，必须实例 GTHE3/4_COMMON 原语。使用OBUFDS_GTE3/4 原语时，不需要实例化 GTHE3/4_COMMON。</p><figure><img src="/img/GTY高速收发器（一）/image-5.png"alt="图6 参考时钟输出使用模型OBUFDS_GTE3/4" /><figcaption aria-hidden="true">图6参考时钟输出使用模型OBUFDS_GTE3/4</figcaption></figure><figure><img src="/img/GTY高速收发器（一）/image-6.png"alt="图7 参考时钟输出使用模型OBUFDS_GTE3/4_ADV" /><figcaption aria-hidden="true">图7参考时钟输出使用模型OBUFDS_GTE3/4_ADV</figcaption></figure><p>GTHE3/4_COMMON 上的端口 RXRECCLK0_SEL 和 RXRECCLK1_SEL控制多路复用器，该多路复用器从 Quad 中的四个不同通道中选择RXRECCLKOUT。</p><p>参考时钟有输入输出两种模式，区别在于输入模式参考的时钟源来自于外部的专用参考时钟引脚，输出模式下参考时钟通过从Quad 中的 Channel 中恢复出来的 RXRECCLKOUT 路由而来。</p><h2 id="参考时钟方案选择">2.2 参考时钟方案选择</h2><p><strong>从架构上看，Quad（Q）包含四个 GTHE3/4_CHANNEL 原语、一个GTHE3/4_COMMON原语、两个专用外部参考时钟引脚对和专用参考时钟路由。</strong>每个收发器使用中必须实例化GTHE3/4_CHANNEL 原语。如果需要高性能 QPLL，还必须实例化 GTHE3/4_COMMON原语。通常，Quad（Q(n)）的参考时钟可以通过 GTNORTHREFCLK从最多下方两个位置的 Quad（Q(n–1) 或 Q(n-2)）获取，或通过 GTSOUTHREFCLK从最多上方两个的 Quad（Q(n+1) 或 Q(n+2)）获取。<strong>（即当前 Quad的参考时钟可以通过南北不超过2个 Quad区域的参考时钟路由而来）。</strong></p><p>Quad 中的每个 GTY 收发器通道都有六个可用的时钟输入：</p><p>（1）两个本地参考时钟引脚对：GTREFCLK0 或 GTREFCLK1</p><p>（2）上方 Quad 的两个参考时钟引脚对：GTSOUTHREFCLK0 或GTSOUTHREFCLK1</p><p>（3）下方 Quad 的两个参考时钟引脚对：GTNORTHREFCLK0 或GTNORTHREFCLK1</p><p>单个 GTHE3/4_COMMON 原语内的参考时钟多路复用器结构如下图所示：</p><figure><img src="/img/GTY高速收发器（一）/image-7.png"alt="图8 QPLL参考时钟选择复用器" /><figcaption aria-hidden="true">图8 QPLL参考时钟选择复用器</figcaption></figure><p>单个 GTHE3/4_CHANNEL 原语内的参考时钟多路复用器结构如下图所示：</p><figure><img src="/img/GTY高速收发器（一）/image-8.png"alt="图9 CPLL参考时钟选择复用器" /><figcaption aria-hidden="true">图9 CPLL参考时钟选择复用器</figcaption></figure><h3 id="单个外部参考钟使用模型">2.2.1 单个外部参考钟使用模型</h3><p>下图显示了单个外部参考时钟连接到单个 Quad 内的多个收发器。</p><figure><img src="/img/GTY高速收发器（一）/image-9.png"alt="图10 单个外部参考时钟连接到单个QUAD内的多个收发器" /><figcaption aria-hidden="true">图10单个外部参考时钟连接到单个QUAD内的多个收发器</figcaption></figure><p>下图展示了单个外部参考时钟连接到多个 Quad 内的多个收发器。</p><figure><img src="/img/GTY高速收发器（一）/image-10.png"alt="图11 单个外部参考时钟连接到多个Quad内的多个收发器" /><figcaption aria-hidden="true">图11单个外部参考时钟连接到多个Quad内的多个收发器</figcaption></figure><p>共享参考时钟时必须遵守以下规则，以确保满足高速设计的抖动裕度：</p><ul><li><p>源 Quad 上方的 Quad 数量不得超过两个。</p></li><li><p>源 Quad 下方的 Quad 数量不得超过两个。</p></li><li><p>外部时钟引脚对 (MGTREFCLKN/MGTREFCLKP) 作为源的 Quad总数不得超过五个 (或者说作为源的收发器不能超过20个)。</p></li></ul><h3 id="多个外部参考时钟使用模型">2.2.2 多个外部参考时钟使用模型</h3><p>下图展示了同一 Quad 中多个 GTY 收发器使用多个参考时钟。</p><figure><img src="/img/GTY高速收发器（一）/image-11.png"alt="图12 在单个QUAD中具有多个参考时钟的多个GTY收发器" /><figcaption aria-hidden="true">图12在单个QUAD中具有多个参考时钟的多个GTY收发器</figcaption></figure><p>图13和图14给出了属于一个 Quad 的收发器如何使用 GTNORTHREFCLK 和GTSOUTHREFCLK 端口从另一个 Quad 访问专用参考时钟的例子。在每个 GTY收发器 PLL 有多个参考时钟选项的情况下，用户设计需要根据设计需求设置QPLL0/1REFCLKSEL[2:0] 和 CPLLREFCLKSEL[2:0]。</p><figure><img src="/img/GTY高速收发器（一）/image-12.png"alt="图13 多个GTY收发器使用CPLLs，在不同的Quads中具有多个参考时钟" /><figcaption aria-hidden="true">图13多个GTY收发器使用CPLLs，在不同的Quads中具有多个参考时钟</figcaption></figure><figure><img src="/img/GTY高速收发器（一）/image-13.png"alt="图14 多个GTY收发器使用QPLLs，在不同的Quads中具有多个参考时钟" /><figcaption aria-hidden="true">图14多个GTY收发器使用QPLLs，在不同的Quads中具有多个参考时钟</figcaption></figure><div class="note note-info">            <p>上面的 Quad 位于下面 Quad 的北面，那么下面的 Quad 可以将北面 Quad的差分时钟通过 GTSOUTHREFCLK0、GTSOUTHREFCLK1 端口作为自己的 QPLL的时钟输入。</p><p>同样的道理下面的 Quad 位于上面 Quad 的南面，上面 Quad 可以通过GTNORTHREFCLK0、GTNORTHREFCLK1 把下面 Quad 的差分时钟作为自己的 QPLL的输入时钟。</p><p>注意这里的 NORTH 和 SOUTH 不是表示时钟来自 NORTH 还是SOUTH，而是表示自己 Quad 所在的位置。举个例子，Quad0、Quad1 和 Quad2从北到南依次排布，Quad1 位于正中，那么从 Quad0也就是北边来的时钟就要接到 GTSOUTHREFCLK0 和 GTSOUTHREFCLK1这两个端口，因为 Quad1 相对于 Quad0 它处于南边；同样的从 Quad2也就是南边来的时钟就要接到 GTNORTHREFCLK0 和 GTNORTHREFCLK1这两个端口，因为 Quad1 相对于 Quad2 它处于北边。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>高速收发器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>GTY</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDLBits刷题日记（二）</title>
    <link href="/HDLBits_two/"/>
    <url>/HDLBits_two/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>打算利用碎片化时间重温一遍Verilog语法，好记忆不如烂笔头，在此记录一下HDLBits刷题的过程，记录一些知识点，方便日后再次复习。</p>          </div><h1 id="verilog-language---basics">1、Verilog Language - Basics</h1><h2 id="problem-4-notgate">Problem 4 : Notgate</h2><p>Create a module that implements a NOT gate.</p><p>创建一个模块，实现一个非门。</p><figure><img src="/img/HDLBits_two/Notgate.png" alt="Notgate" /><figcaption aria-hidden="true">Notgate</figcaption></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> top_module <span class="token punctuation">(</span>    <span class="token keyword">input</span> in<span class="token punctuation">,</span>    <span class="token keyword">output</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> out <span class="token operator">=</span> <span class="token operator">~</span> in<span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre></div></figure><div class="note note-success">            <ul><li><p><code>~</code> 是逐位取反。</p></li><li><p><code>！</code> 是逻辑取反。</p></li></ul>          </div><h2 id="problem-5-andgate">Problem 5 : Andgate</h2><p>Create a module that implements an AND gate.</p><p>创建一个模块，实现一个与门。</p><figure><img src="/img/HDLBits_two/Andgate.png" alt="Andgate" /><figcaption aria-hidden="true">Andgate</figcaption></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">top_module</span><span class="token punctuation">(</span>    <span class="token keyword">input</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> b<span class="token punctuation">,</span>    <span class="token keyword">output</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> out <span class="token operator">=</span> a <span class="token operator">&amp;</span> b<span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre></div></figure><div class="note note-success">            <ul><li><p><code>&amp;</code> 是逐位与。</p></li><li><p><code>&amp;&amp;</code> 是逻辑与。</p></li></ul>          </div><h2 id="problem-6-norgate">Problem 6 : Norgate</h2><p>Create a module that implements a NOR gate. A NOR gate is an OR gatewith its output inverted. A NOR function needs two operators whenwritten in Verilog.</p><p>创建一个模块，实现一个或非门。一个或非门是一个或门，其输出被反转。在Verilog中，一个或非函数需要两个运算符。</p><figure><img src="/img/HDLBits_two/Norgate.png" alt="Norgate" /><figcaption aria-hidden="true">Norgate</figcaption></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">top_module</span><span class="token punctuation">(</span>    <span class="token keyword">input</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> b<span class="token punctuation">,</span>    <span class="token keyword">output</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> out <span class="token operator">=</span> <span class="token operator">~</span><span class="token punctuation">(</span>a <span class="token operator">|</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre></div></figure><div class="note note-success">            <ul><li><p><code>|</code> 是逐位或。</p></li><li><p><code>||</code> 是逻辑或。</p></li><li><p>注意括号的由来，因为 ~ 非逻辑的优先级大于 | 或。</p></li></ul>          </div><h2 id="problem-7-xnorgate">Problem 7 : Xnorgate</h2><p>Create a module that implements an XNOR gate.</p><p>创建一个模块，实现一个同或门（异或非门）。</p><figure><img src="/img/HDLBits_two/Xnorgate.png" alt="Xnorgate" /><figcaption aria-hidden="true">Xnorgate</figcaption></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">top_module</span><span class="token punctuation">(</span>    <span class="token keyword">input</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> b<span class="token punctuation">,</span>    <span class="token keyword">output</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> out <span class="token operator">=</span> <span class="token operator">~</span><span class="token punctuation">(</span>a <span class="token operator">^</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre></div></figure><div class="note note-success">            <ul><li><p>同或门 （XNor Gate） 是异或门 (Xor Gate) 的取反输出。</p></li><li><p>异或门的输入输出可以概括为：（输入）相同（输出）为 0 ，不同为1。</p></li><li><p><code>^</code> 为逐位异或，Verilog中不存在逻辑异或符号。</p></li></ul>          </div><h2 id="problem-8-declaring-wires">Problem 8 : Declaring wires</h2><p>信号定义语句需要放置于模块的 body 中，模块的 body 指的就是 module 和endmodule 中间的部分。</p><p>举个例子：</p><figure><img src="/img/HDLBits_two/Wiredecl1.png" alt="Wiredecl1" /><figcaption aria-hidden="true">Wiredecl1</figcaption></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> top_module <span class="token punctuation">(</span>    <span class="token keyword">input</span> in<span class="token punctuation">,</span>              <span class="token comment">// Declare an input wire named "in"</span>    <span class="token keyword">output</span> out             <span class="token comment">// Declare an output wire named "out"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">wire</span> not_in<span class="token punctuation">;</span>           <span class="token comment">// Declare a wire named "not_in"</span>    <span class="token keyword">assign</span> out <span class="token operator">=</span> <span class="token operator">~</span>not_in<span class="token punctuation">;</span>  <span class="token comment">// Assign a value to out (create a NOT gate).</span>    <span class="token keyword">assign</span> not_in <span class="token operator">=</span> <span class="token operator">~</span>in<span class="token punctuation">;</span>   <span class="token comment">// Assign a value to not_in (create another NOT gate).</span><span class="token keyword">endmodule</span>   <span class="token comment">// End of module "top_module"</span></code></pre></div></figure><p>在上面的模块中，有三个 wire (in、out 和 not_in)，其中两个已经声明为模块的输入和输出端口的一部分(这就是为什么在前面的练习中不需要声明任何连接)。wire not_in需要在模块内部声明。从模块外部不可见。然后，使用两个 assign赋值语句创建两个 NOT 门。注意，先创建哪个 NOT门并不重要，最终还是会得到相同的电路。</p><p>小试牛刀：</p><p>Implement the following circuit. Create two intermediate wires (namedanything you want) to connect the AND and OR gates together.</p><p>实现以下电路：创建两个中间线 (命名任意)，以便连接与门、或门一起。</p><figure><img src="/img/HDLBits_two/Wiredecl2.png" alt="Wiredecl2" /><figcaption aria-hidden="true">Wiredecl2</figcaption></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`default_nettype</span> none<span class="token keyword">module</span> top_module <span class="token punctuation">(</span>    <span class="token keyword">input</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> b<span class="token punctuation">,</span>    <span class="token keyword">input</span> c<span class="token punctuation">,</span>    <span class="token keyword">input</span> d<span class="token punctuation">,</span>    <span class="token keyword">output</span> out，    <span class="token keyword">output</span> out_n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">wire</span> w1<span class="token punctuation">,</span> w2<span class="token punctuation">;</span>    <span class="token keyword">assign</span> w1 <span class="token operator">=</span> a <span class="token operator">&amp;</span> b<span class="token punctuation">;</span>    <span class="token keyword">assign</span> w2 <span class="token operator">=</span> c <span class="token operator">&amp;</span> d<span class="token punctuation">;</span>    <span class="token keyword">assign</span> out <span class="token operator">=</span> w1 <span class="token operator">|</span> w2<span class="token punctuation">;</span>    <span class="token keyword">assign</span> out_n <span class="token operator">=</span> <span class="token operator">~</span>out<span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre></div></figure><div class="note note-success">            <ul><li>在定义信号的同时，可以对其赋值，如<code>wire w1 = a &amp; b;</code>。</li></ul>          </div><h2 id="problem-9-7458">Problem 9 : 7458</h2><p>The 7458 is a chip with four AND gates and two OR gates.</p><p>7458 是一个具有四个与门和两个或门的芯片。</p><figure><img src="/img/HDLBits_two/7458.png" alt="7458" /><figcaption aria-hidden="true">7458</figcaption></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> top_module <span class="token punctuation">(</span>    <span class="token keyword">input</span> p1a<span class="token punctuation">,</span>    <span class="token keyword">input</span> p1b<span class="token punctuation">,</span>    <span class="token keyword">input</span> p1c<span class="token punctuation">,</span>    <span class="token keyword">input</span> p1d<span class="token punctuation">,</span>    <span class="token keyword">input</span> p1e<span class="token punctuation">,</span>    <span class="token keyword">input</span> p1f<span class="token punctuation">,</span>    <span class="token keyword">output</span> p1y<span class="token punctuation">,</span>    <span class="token keyword">input</span> p2a<span class="token punctuation">,</span>    <span class="token keyword">input</span> p2b<span class="token punctuation">,</span>    <span class="token keyword">input</span> p2c<span class="token punctuation">,</span>    <span class="token keyword">input</span> p2d<span class="token punctuation">,</span>    <span class="token keyword">output</span> p2y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">wire</span> w1<span class="token punctuation">,</span> w2<span class="token punctuation">,</span> w3<span class="token punctuation">,</span> w4<span class="token punctuation">,</span> w5<span class="token punctuation">,</span> w6<span class="token punctuation">;</span>    <span class="token keyword">assign</span> w1 <span class="token operator">=</span> p1a <span class="token operator">&amp;</span> p1b <span class="token operator">&amp;</span> p1c<span class="token punctuation">;</span>    <span class="token keyword">assign</span> w2 <span class="token operator">=</span> p1d <span class="token operator">&amp;</span> p1e <span class="token operator">&amp;</span> p1f<span class="token punctuation">;</span>    <span class="token keyword">assign</span> w3 <span class="token operator">=</span> p2a <span class="token operator">&amp;</span> p2b<span class="token punctuation">;</span>    <span class="token keyword">assign</span> w4 <span class="token operator">=</span> p2c <span class="token operator">&amp;</span> p2d<span class="token punctuation">;</span>    <span class="token keyword">assign</span> p1y <span class="token operator">=</span> w1 <span class="token operator">|</span> w2<span class="token punctuation">;</span>    <span class="token keyword">assign</span> p2y <span class="token operator">=</span> w3 <span class="token operator">|</span> w4<span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre></div></figure><p>或者对每个输出信号，使用一个 assign 语句，不需要中间信号。</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> top_module <span class="token punctuation">(</span>    <span class="token keyword">input</span> p1a<span class="token punctuation">,</span>    <span class="token keyword">input</span> p1b<span class="token punctuation">,</span>    <span class="token keyword">input</span> p1c<span class="token punctuation">,</span>    <span class="token keyword">input</span> p1d<span class="token punctuation">,</span>    <span class="token keyword">input</span> p1e<span class="token punctuation">,</span>    <span class="token keyword">input</span> p1f<span class="token punctuation">,</span>    <span class="token keyword">output</span> p1y<span class="token punctuation">,</span>    <span class="token keyword">input</span> p2a<span class="token punctuation">,</span>    <span class="token keyword">input</span> p2b<span class="token punctuation">,</span>    <span class="token keyword">input</span> p2c<span class="token punctuation">,</span>    <span class="token keyword">input</span> p2d<span class="token punctuation">,</span>    <span class="token keyword">output</span> p2y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> p1y <span class="token operator">=</span> <span class="token punctuation">(</span>p1a <span class="token operator">&amp;</span> p1b <span class="token operator">&amp;</span> p1c<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>p1d <span class="token operator">&amp;</span> p1e <span class="token operator">&amp;</span> p1f<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> p2y <span class="token operator">=</span> <span class="token punctuation">(</span>p2a <span class="token operator">&amp;</span> p2b<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>p2c <span class="token operator">&amp;</span> p2d<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre></div></figure><h1 id="逻辑门总结">2、逻辑门总结</h1><div class="note note-info">            <ul><li><p><code>&amp;</code> 是逐位与，而 <code>&amp;&amp;</code>是逻辑与。</p></li><li><p><code>~</code> 是逐位取反，而 <code>!</code>是逻辑取反。</p></li><li><p><code>|</code> 是逐位或， 而 <code>||</code> 是逻辑或。</p></li><li><p><code>^</code> 为逐位异或，Verilog中不存在逻辑异或符号。</p></li><li><p>同或门 （XNor Gate） 是异或门 (Nor Gate) 的取反输出。</p></li><li><p>异或门的输入输出可以概括为：（输入）相同（输出）为 0 ，不同为1。</p></li></ul>          </div>]]></content>
    
    
    <categories>
      
      <category>HDLBits刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>HDLBits</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDLBits刷题日记（一）</title>
    <link href="/HDLBits_one/"/>
    <url>/HDLBits_one/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>打算利用碎片化时间重温一遍Verilog语法，好记忆不如烂笔头，在此记录一下HDLBits刷题的过程，记录一些知识点，方便日后再次复习。</p>          </div><h1 id="getting-started">1、Getting Started</h1><h2 id="problem-0-step-one">Problem 0 : Step one</h2><p>Build a circuit with no inputs and one output. That output shouldalways drive 1 (or logic high).</p><p>构建一个电路，没有输入端口，只有一个输出端口，输出端口时钟驱动逻辑 1，即逻辑高电平。</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> top_module <span class="token punctuation">(</span>    <span class="token keyword">output</span> one<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> one <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre></div></figure><div class="note note-success">            <p>1 在数字逻辑中代表 logic high，而 0 代表 logic low。</p>          </div><h2 id="problem-1-zero">Problem 1 : Zero</h2><p>Build a circuit with no inputs and one output that outputs a constant0.</p><p>构建一个电路，没有输入端口，只有一个输出端口，但这次输出端口时钟驱动逻辑0 ，即逻辑低电平。</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> top_module <span class="token punctuation">(</span>    <span class="token keyword">output</span> zero<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Module body starts after semicolon</span>    <span class="token keyword">assign</span> zero <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre></div></figure><h1 id="verilog-language---basics">2、Verilog Language - Basics</h1><h2 id="problem-2-wire">Problem 2 : Wire</h2><p>Create a module with one input and one output that behaves like awire.</p><p>创建一个具有一个输入和一个输出的模块，其行为类似于导线（wire）。</p><p>不同于物理导线，Verilog中的导线（和其他信号）是有<strong>方向性</strong>的。这意味着信息只能从源（source）单向流向接收端（sink）（源通常也被称为驱动器，用于向导线驱动一个值）。在Verilog的"连续赋值"语句中（<code>assign left_side = right_side;</code>），右侧信号的值被驱动到左侧的导线上。这种赋值被称为"连续的"，是因为即使右侧的值发生变化，赋值也会持续进行。连续赋值不是一次性的事件。</p><p>模块的端口也具有方向性（通常是输入或输出）。输入端口由模块外部的元件驱动，而输出端口则驱动模块外部的元件。从模块内部来看，输入端口是一个驱动器或源，而输出端口是一个接收端。</p><p>下图说明了电路的每个部分如何对应Verilog代码的每个位。模块和端口声明创建了电路的黑色部分。我们的任务是通过添加一个<code>assign</code>语句来创建一条导线（绿色部分），将输入(<code>in</code>)连接到输出(<code>out</code>)。模块外部的部分不是我们需要关心的，但应该知道，我们设计的电路将通过官方的测试工具连接到<code>top_module</code>的端口来进行测试。</p><figure><img src="/img/HDLBits_one/image.png" alt="Wire" /><figcaption aria-hidden="true">Wire</figcaption></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> top_module <span class="token punctuation">(</span>    <span class="token keyword">input</span> in<span class="token punctuation">,</span>    <span class="token keyword">output</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Note that wires are directional, so "assign in = out" is not equivalent.</span>    <span class="token comment">// 注意 wire 是有方向的 因此 assign in = out 是不等价的</span>    <span class="token keyword">assign</span> out <span class="token operator">=</span> in<span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre></div></figure><div class="note note-success">            <ul><li><p>wire 一般只有一个 source，即从某一点输出，但可以有多个sinks，即输入到多个点</p></li><li><p>assign语句映射到具体的硬件上，就是产生了信号的驱动，由右值驱动左值。</p></li></ul>          </div><h2 id="problem-3-wire4">Problem 3 : Wire4</h2><p>Create a module with 3 inputs and 4 outputs that behaves like wiresthat makes these connections:</p><p>创建一个具有3个输入和4个输出的模块，要实现如下连接：</p><p>a -&gt; w</p><p>b -&gt; x</p><p>b -&gt; y</p><p>c -&gt; z</p><figure><img src="/img/HDLBits_one/image-1.png" alt="Wire4" /><figcaption aria-hidden="true">Wire4</figcaption></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">top_module</span><span class="token punctuation">(</span>    <span class="token keyword">input</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> b<span class="token punctuation">,</span>    <span class="token keyword">input</span> c<span class="token punctuation">,</span>    <span class="token keyword">output</span> w<span class="token punctuation">,</span>    <span class="token keyword">output</span> x<span class="token punctuation">,</span>    <span class="token keyword">output</span> y<span class="token punctuation">,</span>    <span class="token keyword">output</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 这里的顺序可以任意调换</span>    <span class="token keyword">assign</span> w <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token keyword">assign</span> x <span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token keyword">assign</span> y <span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token comment">// 注意这里 b 连接到两个输出</span>    <span class="token keyword">assign</span> z <span class="token operator">=</span> c<span class="token punctuation">;</span>    <span class="token keyword">endmodule</span></code></pre></div></figure><div class="note note-success">            <ul><li><p>多个 assign语句的顺序并不重要，因为它们描述的是连接关系，而不是执行顺序。</p></li><li><p>输入输出端口声明会自动声明 wire类型（除非特别指定其他类型），模块端口声明 <code>input a</code> 等同于<code>input wire a</code> 。</p></li><li><p>assign语句不是创建新的导线，而是在已存在的导线之间建立连接</p></li></ul>          </div><p>注意 b 连接到了两个输出（x 和y），这是允许的，因为一个输入信号可以驱动多个输出；虽然看起来有4条assign 语句，但我们实际上是在7个已经存在的导线之间建立连接。</p>]]></content>
    
    
    <categories>
      
      <category>HDLBits刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>HDLBits</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三大低速总线之SPI详解</title>
    <link href="/spi-introduction/"/>
    <url>/spi-introduction/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>本科阶段在搞硬件设计的时候就经常碰到三大低速总线(UART、SPI、IIC)，奈何好记忆不如烂笔头，趁着现在基于github搭建了个人博客，就把这三大低速总线的原理和应用做一个详细的总结吧，以便日后查阅。</p>          </div><h1 id="spi简介">1、SPI简介</h1><p>SPI (Serial Peripheral Interface)是一种同步通信协议，可以实现微控制器和外围设备之间的数据传输。它是一个全双工的主从协议，这意味着数据可以同时发送和接收。当主设备向从设备发送数据时，从设备可以将数据发送回主设备，而无需等待单独的读操作。它通常用于嵌入式系统，特别是需要高速数据传输的应用程序。</p><h2 id="引脚配置-mosimisosclk-和-cs">1.1、引脚配置： MOSI，MISO，SCLK 和CS</h2><p>SPI 通信需要四个引脚：</p><ul><li><p>MOSI (Master Output Slave Input) : 主设备使用 MOSI引脚向从设备传输数据。</p></li><li><p>MISO (Master Input Slave Output) : 从设备使用 MISO引脚将数据传输回主设备。</p></li><li><p>SCLK (Serial Clock) : SCLK引脚提供时钟信号，用于同步主从设备之间的数据传输。</p></li><li><p>CS (Slave Select) : CS引脚被主设备用来选择它想要与之通信的从设备。</p></li></ul><h2 id="spi-数据传输">1.2、SPI 数据传输</h2><p>数据传输可以由主设备或从设备启动。SPI数据传输过程包括以下几个步骤：</p><p><strong>选择从设备：</strong> 主设备通过拉低 CS线低来选择从设备。这将告诉从设备它正在被寻址，并且应该准备接收或传输数据。</p><p><strong>配置数据传输参数：</strong>主设备设置数据传输参数，如时钟频率、数据格式和每个事务要传输的位数。</p><p><strong>发送数据：</strong> 主设备通过 MOSI线路向从设备发送数据。数据以串行格式发送，从最重要的位开始，一次一位。</p><p><strong>接收数据：</strong> 在发送数据时，主设备也通过 MISO线从从设备接收数据。接收到的数据也是串行格式，一次一位，从最有意义的位开始。</p><p><strong>时钟数据：</strong> 数据传输由 SCK线上的时钟信号同步。所述时钟信号由所述主设备产生，所述从设备将其数据传输与所述时钟信号同步。</p><p><strong>完成数据传输：</strong> 数据传输完成后，主设备将拉高 CS行，表明从设备不再被寻址。然后，从设备可以释放在数据传输期间使用的任何资源。</p><figure><imgsrc="/img/spi-introduction/img_temp_6421dddc954f14-18738137-83373518.png"alt="图 1 数据传输示意图" /><figcaption aria-hidden="true">图 1 数据传输示意图</figcaption></figure><h2 id="spi-寄存器级数据传输">1.3、SPI 寄存器级数据传输</h2><p>在寄存器级，数据一次在主设备和从设备之间传输一个字节。数据传输发生在设备中的特定寄存器之间。每个寄存器都包含一个需要传输的特定函数或数据。</p><ul><li><p>主设备在 SCLK 线路上发送时钟信号来同步数据传输。</p></li><li><p>主设备将 MOSI线设置为适当的逻辑电平，以便将字节的第一位发送给从设备。</p></li><li><p>从设备接收 MISO 线上的位并将其存储在移位寄存器中。</p></li><li><p>时钟信号被切换，字节的下一位由 MOSI 线上的主设备发送。</p></li><li><p>从设备接收 MISO 线上的位并将其移入移位寄存器。</p></li><li><p>这个过程一直持续到所有 8 位的字节都被传输完毕为止。</p></li></ul><p><img src="/img/spi-introduction/image.png"alt="图 2 寄存器级数据传输示意图（a）" /> <imgsrc="/img/spi-introduction/img_temp_64207d4bad0069-44022866-18941375.gif"alt="图 2 寄存器级数据传输示意图（b）" /></p><h2 id="菊花链连接多个设备">1.4、菊花链：连接多个设备</h2><p>SPI 支持多个设备的菊花链，允许多个设备共享一个 SPI总线。在菊花链配置中，每个从设备的 CS 引脚连接到前一个从设备的 MOSI引脚，形成一个链。主设备发送单个 CS信号，选择链路中的第一个从设备，然后通过发送数据和时钟信号与链路中的所有从设备进行通信。</p><figure><imgsrc="/img/spi-introduction/img_temp_6421dddcbf7866-20126192-46942657.png"alt="图 3 连接多个设备" /><figcaption aria-hidden="true">图 3 连接多个设备</figcaption></figure><h2id="错误检测时钟极性和相位等方面">1.5、错误检测，时钟极性和相位等方面</h2><p>SPI 通信还包括其他方面，如错误检测、时钟极性和时钟相位。像 CRC(循环冗余校验)这样的错误检测机制可以用来确保数据的完整性。时钟极性和时钟相位设置决定数据何时被采样和何时被传输，允许协议的灵活性。</p><p>SPI 总线传输一共有 4 种模式，这 4种模式分别由<strong>时钟极性（CPOL，ClockPolarity）和时钟相位（CPHA，Clock Phase）来定义，其中 CPOL 参数规定了SCLK 时钟信号空闲状态的电平，CPHA 规定了数据是在 SCLK时钟的上升沿被采样还是下降沿被采样。</strong></p><ul><li><p>时钟极性决定 SPI 总线空闲时的 SCLK时钟信号是高电平还是低电平。</p><p>CPOL = 1：表示空闲时是高电平；</p><p>CPOL = 0：表示空闲时是低电平。</p></li><li><p>时钟相位决定 SPI 总线从哪个跳变沿开始采样数据。</p><p>CPHA = 0：在时钟信号SCK的第1个跳变沿采样；</p><p>CPHA = 1：在时钟信号SCK的第2个跳变沿采样。</p></li></ul><table style="width:100%;"><thead><tr><th style="text-align: center;">SPI 模式</th><th style="text-align: center;">CPOL</th><th style="text-align: center;">CPHA</th><th style="text-align: center;">空闲时 SCLK 时钟</th><th style="text-align: center;">数据采样时刻</th><th style="text-align: center;">数据切换时刻</th></tr></thead><tbody><tr><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">低电平</td><td style="text-align: center;">上升沿</td><td style="text-align: center;">下降沿</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">低电平</td><td style="text-align: center;">下降沿</td><td style="text-align: center;">上升沿</td></tr><tr><td style="text-align: center;">2</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">高电平</td><td style="text-align: center;">下降沿</td><td style="text-align: center;">上升沿</td></tr><tr><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">高电平</td><td style="text-align: center;">上升沿</td><td style="text-align: center;">下降沿</td></tr></tbody></table><figure><img src="/img/spi-introduction/SPIMode.png" alt="图 4 SPI Mode" /><figcaption aria-hidden="true">图 4 SPI Mode</figcaption></figure><h2 id="spi-的优缺点">1.6、SPI 的优缺点</h2><h3 id="优点">1.6.1、优点</h3><p>与 I2C 和 UART 等其他通信协议相比，SPI 有以下几个优点：</p><p><strong>高速数据传输：</strong> 与其他协议相比，SPI可以实现更高的数据传输速率，使其成为需要快速数据传输的应用程序的极佳选择。</p><p><strong>低开销：</strong> 由于 SPI对数据和时钟信号使用单独的线路，因此与通信协议相关的开销最小。</p><p><strong>简单协议：</strong> SPI是一个开销较少的简单协议，使其成为一些应用程序更有效的选择，易于在硬件和软件中实现。</p><p><strong>全双工通信：</strong> SPI允许在两个方向上同时传输数据，比其他需要单独读写操作的协议 (如 I2C)更有效率。</p><p><strong>灵活的配置：</strong> SPI通信的不同模式允许灵活地配置通信的时间和极性，同时支持多个设备的菊花链，使其成为一些应用程序更灵活的选择。</p><h3 id="缺点">1.6.2、缺点</h3><p>使用 SPI 通信的一些缺点包括：</p><p><strong>有限的距离：</strong> SPI通常用于设备之间的短距离通信，不适合长距离通信。</p><p><strong>设备数量有限：</strong> 尽管 SPI允许多个设备连接到同一总线，但设备数量受到可用 CS 线路数量的限制。</p><p><strong>缺乏错误检测：</strong> 与其他串行通信协议 (如 CAN) 不同，SPI没有内置的纠错机制，这可能使其不太适合需要高可靠性的应用程序。</p>]]></content>
    
    
    <categories>
      
      <category>三大低速总线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>通信协议</tag>
      
      <tag>SPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三大低速总线之UART详解</title>
    <link href="/uart-introduction/"/>
    <url>/uart-introduction/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>本科阶段在搞硬件设计的时候就经常碰到三大低速总线(UART、SPI、IIC)，奈何好记忆不如烂笔头，趁着现在基于github搭建了个人博客，就把这三大低速总线的原理和应用做一个详细的总结吧，以便日后查阅。</p>          </div><h1 id="uart简介">1、UART简介</h1><p>UART是一种采用<strong>异步串行通信方式</strong>的通用异步收发传输器(universalasynchronous receiver-transmitter)，它在发送数据时将并行数据转换成串行数据来传输，在接收数据时将接收到的串行数据转换成并行数据。</p><p>UART串口通信需要两根信号线来实现，一根用于串口发送，另外一根负责串口接收，如图1 所示。对于 PC 来说它的 TX 要和对于 FPGA 来说的 RX 连接，同样 PC 的 RX要和 FPGA 的 TX 连接，如果是两个 TX 或者两个 RX连接那数据就不能正常被发送出去或者接收到。</p><figure><img src="/img/uart-introduction/image.png" alt="图 1 串口通信连接图" /><figcaption aria-hidden="true">图 1 串口通信连接图</figcaption></figure><p>UART 在发送或接收过程中的一帧数据由 4部分组成，起始位、数据位、奇偶校验位和停止位，如图 2 所示。</p><figure><img src="/img/uart-introduction/image-1.png"alt="图 2 异步串行通信数据格式" /><figcaption aria-hidden="true">图 2 异步串行通信数据格式</figcaption></figure><p><spanclass="label label-success"><strong>起始位：</strong></span>当不传输数据时，UART数据传输线通常保持高电压电平。若要开始数据传输，发送UART会将传输线从高电平拉到低电平并保持 1 个波特率周期。当接收 UART检测到高到低电压跃迁时，便开始以波特率对应的频率读取数据帧中的位。</p><p><spanclass="label label-success"><strong>数据帧：</strong></span>其包含所传输的实际数据。如果使用奇偶校验位，数据帧长度可以是5 位到 8 位。如果不使用奇偶校验位，数据帧长度可以是 9位。在大多数情况下，数据以最低有效位优先方式发送。</p><p><spanclass="label label-success"><strong>奇偶校验：</strong></span>奇偶性描述数字是偶数还是奇数。通过奇偶校验位，接收UART判断传输期间是否有数据发生改变。电磁辐射、不一致的波特率或长距离数据传输都可能改变数据位。接收UART 读取数据帧后，将计数值为 1的位，检查总数是偶数还是奇数。如果奇偶校验位为0（偶数奇偶校验），则数据帧中的 1或逻辑高位总计应为偶数。如果奇偶校验位为 1（奇数奇偶校验），则数据帧中的1 或逻辑高位总计应为奇数。当奇偶校验位与数据匹配时，UART认为传输未出错。但是，如果奇偶校验位为 0，而总和为奇数，或者奇偶校验位为1，而总和为偶数，则 UART 认为数据帧中的位已改变。</p><p><spanclass="label label-success"><strong>停止位：</strong></span>为了表示数据包结束，发送UART 将数据传输线从低电压驱动到高电压并保持 1 到 2 位时间。</p><p>UART通信过程中的数据格式及传输速率是可设置的，为了正确的通信，收发双方应约定并遵循同样的设置。数据位可选择为5、6、7、8 位，其中 8 位数据位是最常用的，在实际应用中一般都选择 8位数据 位；校验位可选择奇校验、偶校验或者无校验位；停止位可选择 1位（默认），1.5 或 2位。串口通信的速率用波特率表示，它表示每秒传输二进制数据的位数，单位是bps（位/秒），常用的波特率有 9600、 19200、38400、57600 以及 115200等。</p><div class="note note-primary">            <p>波特率：每秒通过信号传输的码元数称为码元的传输速率，常用符号“Baud”表示，其单位为“波特每秒”(Bps)。在信息传输通道中，携带数据信息的信号单元叫作码元(因为串口是1bit 进行传输的，所以其码元就代表一个二进制数)，串口常见的波特率有4800、9600、19200、115200等，其实意思就是每秒传输这么多个比特位数(bit)。</p><p>通信信道每秒传输的信息量称为位传输速率，简称“比特率”，其单位为“每秒比特数”（bps）。比特率可由波特率计算得出，公式为比特率=波特率×单个调制状态对应的二进制位数。</p><p>如果使用的是 115200 的波特率，其串口的比特率为 115200Bps×1bit =115200bps，由计算得串口发送或者接收 1bit 数据的时间为一个波特，即1/115200s。</p>          </div><p>目前在各种设备中，都是利用CH340、CP2102等 USB转串口芯片来实现串口通信，这些芯片内部集成了 USB转串口的功能，只需要通过 USB 接口连接到 PC 上，就可以实现串口通信。</p><figure><img src="/img/uart-introduction/image-2.png"alt="图 3 USB 串口通信连接示意图" /><figcaption aria-hidden="true">图 3 USB 串口通信连接示意图</figcaption></figure><h1id="uart接收模块uart_rx.v设计">2、UART接收模块(<code>uart_rx.v</code>)设计</h1><p>该模块实现了一个基于AXI4-Stream接口的UART接收器，支持可配置的数据位宽(<code>DATA_WIDTH</code>)和波特率(通过<code>prescale</code>参数)。主要功能包括：</p><ul><li><p><strong>串行数据接收</strong>：通过<code>rxd</code>引脚接收数据。</p></li><li><p><strong>AXI4-Stream接口输出</strong>：通过<code>m_axis_tdata</code>和<code>m_axis_tvalid</code>输出数据。</p></li><li><p><strong>错误检测</strong>：支持帧错误（<code>frame_error</code>）和溢出错误（<code>overrun_error</code>）。</p></li><li><p><strong>状态指示</strong>：通过<code>busy</code>信号指示接收状态。</p></li></ul><h2 id="关键信号与寄存器">2.1、关键信号与寄存器</h2><h3 id="输入输出接口">2.1.1、输入/输出接口</h3><table><thead><tr><th>类型</th><th>名称</th><th>位宽</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>parameter</td><td><code>DATA_WIDTH</code></td><td>-</td><td>-</td><td>数据宽度，默认值为8</td></tr><tr><td>parameter</td><td><code>CLK_FREQ</code></td><td>-</td><td>-</td><td>输入时钟频率，默认值为200MHz</td></tr><tr><td>parameter</td><td><code>BAUD_RATE</code></td><td>-</td><td>-</td><td>目标波特率，默认值为115200bps</td></tr><tr><td>localparam</td><td><code>prescale</code></td><td>-</td><td>-</td><td>分频系数 = CLK_FREQ/(BAUD_RATE*8)</td></tr><tr><td>wire</td><td><code>clk</code></td><td>1</td><td>input</td><td>系统时钟</td></tr><tr><td>wire</td><td><code>rst</code></td><td>1</td><td>input</td><td>系统复位，高电平有效</td></tr><tr><td>wire</td><td><code>m_axis_tdata</code></td><td>DATA_WIDTH</td><td>output</td><td>AXI Stream数据输出</td></tr><tr><td>wire</td><td><code>m_axis_tvalid</code></td><td>1</td><td>output</td><td>AXI Stream数据有效信号</td></tr><tr><td>wire</td><td><code>m_axis_tready</code></td><td>1</td><td>input</td><td>AXI Stream就绪信号</td></tr><tr><td>wire</td><td><code>rxd</code></td><td>1</td><td>input</td><td>UART接收数据线</td></tr><tr><td>wire</td><td><code>busy</code></td><td>1</td><td>output</td><td>接收器忙状态指示</td></tr><tr><td>wire</td><td><code>overrun_error</code></td><td>1</td><td>output</td><td>数据溢出错误指示</td></tr><tr><td>wire</td><td><code>frame_error</code></td><td>1</td><td>output</td><td>帧格式错误指示</td></tr></tbody></table><h3 id="内部寄存器">2.2.2、内部寄存器</h3><table><thead><tr><th>寄存器</th><th>功能说明</th></tr></thead><tbody><tr><td><code>rxd_reg</code></td><td>同步后的<code>rxd</code>输入，避免亚稳态</td></tr><tr><td><code>prescale_reg</code></td><td>分频计数器，控制采样时机</td></tr><tr><td><code>bit_cnt</code></td><td>比特计数器，跟踪当前接收的比特位</td></tr><tr><td><code>data_reg</code></td><td>临时存储接收到的数据位</td></tr><tr><td><code>busy_reg</code></td><td>接收状态标志（忙/空闲）</td></tr><tr><td><code>overrun_error_reg</code></td><td>溢出错误标志</td></tr><tr><td><code>frame_error_reg</code></td><td>帧错误标志</td></tr><tr><td><code>m_axis_tdata_reg</code></td><td>输出数据寄存器</td></tr><tr><td><code>m_axis_tvalid_reg</code></td><td>输出数据有效标志</td></tr></tbody></table><h2 id="实现流程详解">2.2、实现流程详解</h2><h3 id="复位初始化">2.2.1、复位初始化</h3><ul><li><strong>寄存器清零</strong>：在复位信号(<code>rst</code>)为高电平时，所有寄存器和状态标志被清零，rxd_reg初始化为高电平(UART空闲状态)。</li></ul><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>rst<span class="token punctuation">)</span> <span class="token keyword">begin</span>        m_axis_tdata_reg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        m_axis_tvalid_reg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        rxd_reg <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token comment">// UART空闲状态为高电平</span>        prescale_reg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        bit_cnt <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        busy_reg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        overrun_error_reg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        frame_error_reg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span>     <span class="token keyword">else</span> <span class="token keyword">begin</span>        <span class="token comment">// 正常操作逻辑</span>    <span class="token keyword">end</span><span class="token keyword">end</span></code></pre></div></figure><h3 id="同步与状态更新">2.2.2、同步与状态更新</h3><ul><li><p><strong>同步输入</strong>：<code>rxd_reg</code>在每个时钟上升沿采样<code>rxd</code>，避免亚稳态。</p></li><li><p><strong>错误标志清零</strong>：<code>overrun_error_reg</code>和<code>frame_error_reg</code>在每个周期开始时清零，仅在有错误时置位。</p></li></ul><h3 id="接收逻辑">2.2.3、接收逻辑</h3><h4 id="空闲状态bit_cnt-0">空闲状态(bit_cnt = 0)</h4><ul><li>检测<strong>起始位</strong>：当<code>rxd_reg</code>从高电平跳变为低电平时，启动接收流程。</li></ul><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rxd_reg<span class="token punctuation">)</span> <span class="token keyword">begin</span>    prescale_reg <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>prescale <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 起始位采样点</span>    bit_cnt <span class="token operator">&lt;=</span> DATA_WIDTH <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token comment">// 总比特数：起始位 + 数据位 + 停止位</span>    data_reg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>                        <span class="token comment">// 清空数据寄存器</span>    busy_reg <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>                        <span class="token comment">// 进入忙状态</span><span class="token keyword">end</span></code></pre></div></figure><h4 id="接收数据位bit_cnt-data_width-1">接收数据位(bit_cnt &gt;DATA_WIDTH + 1)</h4><ul><li><strong>起始位确认</strong>：确保起始位有效。</li></ul><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">if</span> <span class="token punctuation">(</span>bit_cnt <span class="token operator">></span> DATA_WIDTH <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rxd_reg<span class="token punctuation">)</span> <span class="token keyword">begin</span>                   <span class="token comment">// 起始位有效</span>        bit_cnt <span class="token operator">&lt;=</span> bit_cnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        prescale_reg <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>prescale <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 数据位采样点：1倍波特率周期</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>                        <span class="token comment">// 起始位无效，中止接收</span>        bit_cnt <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        prescale_reg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span></code></pre></div></figure><h4 id="数据位采集bit_cnt-1">数据位采集(bit_cnt &gt; 1)</h4><ul><li><strong>移位接收</strong>：每个数据位在中间点采样，并右移存入<code>data_reg</code>。</li></ul><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bit_cnt <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>    bit_cnt <span class="token operator">&lt;=</span> bit_cnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    prescale_reg <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>prescale <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 更新分频计数器</span>    data_reg <span class="token operator">&lt;=</span> <span class="token operator">&#123;</span>rxd_reg<span class="token punctuation">,</span> data_reg<span class="token punctuation">[</span>DATA_WIDTH<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 右移并插入新比特</span><span class="token keyword">end</span></code></pre></div></figure><h4 id="停止位确认bit_cnt-1">停止位确认(bit_cnt = 1)</h4><ul><li><strong>停止位检测</strong>：停止位应为高电平，否则触发帧错误。</li></ul><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bit_cnt <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>    bit_cnt <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>rxd_reg<span class="token punctuation">)</span> <span class="token keyword">begin</span>                    <span class="token comment">// 停止位有效</span>        m_axis_tdata_reg <span class="token operator">&lt;=</span> data_reg<span class="token punctuation">;</span>     <span class="token comment">// 输出数据</span>        m_axis_tvalid_reg <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>           <span class="token comment">// 置位有效信号</span>        overrun_error_reg <span class="token operator">&lt;=</span> m_axis_tvalid_reg<span class="token punctuation">;</span> <span class="token comment">// 若前次数据未读，触发溢出错误</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>        frame_error_reg <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>             <span class="token comment">// 停止位无效，触发帧错误</span>    <span class="token keyword">end</span><span class="token keyword">end</span></code></pre></div></figure><h3 id="错误处理">2.2.4、错误处理</h3><ul><li><p><strong>溢出错误(OverrunError)</strong>：当新数据已接收(<code>m_axis_tvalid_reg == 1</code>)，但前次数据未被读取(<code>m_axis_tready == 0</code>)时触发。</p></li><li><p><strong>帧错误(FrameError)</strong>：停止位无效(停止位为低电平)，触发帧错误。</p></li></ul><h3 id="波特率控制">2.2.5、波特率控制</h3><ul><li><strong>分频计数器</strong>：<code>prescale_reg</code>控制采样时机，递减至0时触发下一次采样。</li></ul><h1id="uart发送模块uart_tx.v设计">3、UART发送模块(<code>uart_tx.v</code>)设计</h1><p>该模块实现了一个基于AXI4-Stream接口的UART发送器，将并行数据转换为串行数据输出，支持可配置的数据位宽(<code>DATA_WIDTH</code>)和波特率(通过<code>prescale</code>输入)。主要功能包括：</p><ul><li><p><strong>串行数据发送</strong>：通过<code>txd</code>引脚发送数据。</p></li><li><p><strong>AXI4-Stream输入</strong>：<code>s_axis_tdata</code>(数据)、<code>s_axis_tvalid</code>(数据有效)、<code>s_axis_tready</code>(模块就绪)。</p></li><li><p><strong>波特率控制</strong>：<code>prescale</code>(波特率分频系数)。</p></li><li><p><strong>状态指示</strong>：通过<code>busy</code>信号指示发送状态。</p></li></ul><h2 id="关键寄存器与信号">3.1、关键寄存器与信号</h2><h3 id="输入输出接口-1">3.1.1、输入/输出接口</h3><table><thead><tr><th>类型</th><th>名称</th><th>位宽</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>parameter</td><td><code>DATA_WIDTH</code></td><td>-</td><td>-</td><td>数据宽度，默认值为8</td></tr><tr><td>parameter</td><td><code>CLK_FREQ</code></td><td>-</td><td>-</td><td>输入时钟频率，默认值为200MHz</td></tr><tr><td>parameter</td><td><code>BAUD_RATE</code></td><td>-</td><td>-</td><td>目标波特率，默认值为115200bps</td></tr><tr><td>localparam</td><td><code>prescale</code></td><td>-</td><td>-</td><td>分频系数 = CLK_FREQ/(BAUD_RATE*8)</td></tr><tr><td>wire</td><td><code>clk</code></td><td>1</td><td>input</td><td>系统时钟</td></tr><tr><td>wire</td><td><code>rst</code></td><td>1</td><td>input</td><td>系统复位，高电平有效</td></tr><tr><td>wire</td><td><code>s_axis_tdata</code></td><td>DATA_WIDTH</td><td>input</td><td>AXI Stream数据输入</td></tr><tr><td>wire</td><td><code>s_axis_tvalid</code></td><td>1</td><td>input</td><td>AXI Stream数据有效信号</td></tr><tr><td>wire</td><td><code>s_axis_tready</code></td><td>1</td><td>output</td><td>AXI Stream就绪信号</td></tr><tr><td>wire</td><td><code>txd</code></td><td>1</td><td>output</td><td>UART发送数据线</td></tr><tr><td>wire</td><td><code>busy</code></td><td>1</td><td>output</td><td>发送器忙状态指示</td></tr></tbody></table><h3 id="内部寄存器-1">3.1.2、内部寄存器</h3><table><thead><tr><th>寄存器/信号</th><th>描述</th></tr></thead><tbody><tr><td><code>s_axis_tready_reg</code></td><td>控制AXI <code>tready</code>信号，表示模块是否可接收新数据。</td></tr><tr><td><code>txd_reg</code></td><td>存储当前发送的串行数据位（最终输出到<code>txd</code>）。</td></tr><tr><td><code>busy_reg</code></td><td>表示模块是否正在发送数据（高电平有效）。</td></tr><tr><td><code>data_reg</code></td><td>存储待发送的数据帧（包含数据位）。</td></tr><tr><td><code>prescale_reg</code></td><td>波特率分频计数器，用于控制每个位的持续时间。</td></tr><tr><td><code>bit_cnt</code></td><td>位计数器，跟踪当前发送的位位置。</td></tr></tbody></table><h2 id="发送流程详解">3.2、发送流程详解</h2><h3 id="初始状态空闲">3.2.1、初始状态（空闲）</h3><ul><li><p><code>txd_reg</code>保持高电平（空闲状态）。</p></li><li><p><code>s_axis_tready_reg</code>为高，允许接收新数据。</p></li><li><p><code>busy_reg</code>为低，表示模块空闲。</p></li></ul><h3id="数据接收与启动发送s_axis_tvalid有效且模块空闲s_axis_tready_reg为高">3.2.2、数据接收与启动发送(<code>s_axis_tvalid</code>有效且模块空闲<code>s_axis_tready_reg</code>为高)</h3><ul><li><p><strong>锁存数据</strong>：<code>data_reg &lt;= s_axis_tdata</code>。</p></li><li><p><strong>设置起始位</strong>：<code>txd_reg &lt;= 0</code>。</p></li><li><p><strong>初始化计数器</strong>：<code>prescale_reg &lt;= (prescale &lt;&lt; 3) - 1</code>，<code>bit_cnt &lt;= DATA_WIDTH + 1</code>。</p></li><li><p><strong>状态切换</strong>：<code>busy_reg</code>置高，<code>s_axis_tready_reg</code>置低。</p></li></ul><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">if</span> <span class="token punctuation">(</span>s_axis_tvalid<span class="token punctuation">)</span> <span class="token keyword">begin</span>    s_axis_tready_reg <span class="token operator">&lt;=</span> <span class="token operator">!</span>s_axis_tready_reg<span class="token punctuation">;</span>    prescale_reg      <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>prescale <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    bit_cnt           <span class="token operator">&lt;=</span> DATA_WIDTH <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    data_reg          <span class="token operator">&lt;=</span> s_axis_tdata<span class="token punctuation">;</span>    txd_reg           <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    busy_reg          <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span></code></pre></div></figure><h3 id="数据位发送bit_cnt-1">3.2.3、数据位发送(bit_cnt &gt; 1)</h3><ul><li><p><strong>分频计数</strong>：<code>prescale_reg</code>递减至0。</p></li><li><p><strong>移位发送</strong>：<code>&#123;data_reg, txd_reg&#125; &lt;= &#123;1'b0, data_reg&#125;</code>，<code>txd_reg</code>取<code>data_reg</code>的最低位（LSB优先发送）。</p></li><li><p><strong>更新计数器</strong>：<code>bit_cnt</code>减1，重置<code>prescale_reg</code>。</p></li></ul><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">if</span> <span class="token punctuation">(</span>bit_cnt <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>    bit_cnt             <span class="token operator">&lt;=</span> bit_cnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    prescale_reg        <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>prescale <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token operator">&#123;</span>data_reg<span class="token punctuation">,</span> txd_reg<span class="token operator">&#125;</span> <span class="token operator">&lt;=</span> <span class="token operator">&#123;</span><span class="token number">1'b0</span><span class="token punctuation">,</span> data_reg<span class="token operator">&#125;</span><span class="token punctuation">;</span><span class="token keyword">end</span> </code></pre></div></figure><h3 id="停止位发送bit_cnt-1">3.2.4、停止位发送(bit_cnt == 1)</h3><ul><li><p><strong>设置停止位</strong>：<code>txd_reg &lt;= 1</code>。</p></li><li><p><strong>分频计数</strong>：<code>prescale_reg &lt;= prescale &lt;&lt; 3</code>（停止位持续时间）。</p></li><li><p><strong>状态恢复</strong>：<code>bit_cnt</code>减至0，<code>busy_reg</code>置低，<code>s_axis_tready_reg</code>置高。</p></li></ul><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bit_cnt <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>    prescale_reg <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>prescale <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    bit_cnt      <span class="token operator">&lt;=</span> bit_cnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    txd_reg      <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bit_cnt <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>    s_axis_tready_reg <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    busy_reg          <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">//其他逻辑</span><span class="token keyword">end</span></code></pre></div></figure><h2 id="状态转换示意">3.3、状态转换示意</h2><figure><div class="code-wrapper"><pre class="language-none"><code class="language-none">     +-------------+     |   空闲状态   |     | (busy=0)    |     +-----+-------+           | s_axis_tvalid &amp; s_axis_tready           v     +-------------+   bit_cnt &gt; 1  +-----------------+     | 发送起始位   |+--------------&gt;| 发送数据位(循环) |     | (txd=0)     |                | (LSB优先)       |     +-----+-------+                +--------+--------+           |                                  |           | bit_cnt == 1                     |           v                                  |     +-------------+                          |     | 发送停止位   | &lt;------------------------+     | (txd=1)     |     +-------------+</code></pre></div></figure><h1 id="uart回环测试">4、UART回环测试</h1><p>比较简单，只需要将发送模块和接收模块互相连接，然后通过串口助手发送数据，观察接收端是否能够正常接收到数据即可。</p><h2 id="输入输出接口-2">4.1、输入/输出接口</h2><table><thead><tr><th>类型</th><th>名称</th><th>位宽</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>parameter</td><td><code>DATA_WIDTH</code></td><td>-</td><td>-</td><td>数据宽度，默认值为8</td></tr><tr><td>parameter</td><td><code>CLK_FREQ</code></td><td>-</td><td>-</td><td>输入时钟频率，默认值为200MHz</td></tr><tr><td>parameter</td><td><code>BAUD_RATE</code></td><td>-</td><td>-</td><td>目标波特率，默认值为115200bps</td></tr><tr><td>wire</td><td><code>sys_clk_p</code></td><td>1</td><td>input</td><td>系统差分时钟正端</td></tr><tr><td>wire</td><td><code>sys_clk_n</code></td><td>1</td><td>input</td><td>系统差分时钟负端</td></tr><tr><td>wire</td><td><code>sys_rst_n</code></td><td>1</td><td>input</td><td>系统复位信号，低电平有效</td></tr><tr><td>wire</td><td><code>uart_rxd</code></td><td>1</td><td>input</td><td>UART接收数据线</td></tr><tr><td>wire</td><td><code>uart_txd</code></td><td>1</td><td>output</td><td>UART发送数据线</td></tr></tbody></table><h2 id="模块实例化">4.2、模块实例化</h2><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog">uart_tx #<span class="token punctuation">(</span>    <span class="token punctuation">.</span><span class="token function">DATA_WIDTH</span><span class="token punctuation">(</span>DATA_WIDTH<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">CLK_FREQ</span><span class="token punctuation">(</span>CLK_FREQ<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">BAUD_RATE</span><span class="token punctuation">(</span>BAUD_RATE<span class="token punctuation">)</span><span class="token punctuation">)</span>uart_tx_inst <span class="token punctuation">(</span>    <span class="token punctuation">.</span><span class="token function">clk</span><span class="token punctuation">(</span>sys_clk<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">rst</span><span class="token punctuation">(</span><span class="token operator">~</span>sys_rst_n<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// axi input</span>    <span class="token punctuation">.</span><span class="token function">s_axis_tdata</span><span class="token punctuation">(</span>m_axis_tdata<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">s_axis_tvalid</span><span class="token punctuation">(</span>m_axis_tvalid<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">s_axis_tready</span><span class="token punctuation">(</span>m_axis_tready<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// output</span>    <span class="token punctuation">.</span><span class="token function">txd</span><span class="token punctuation">(</span>uart_txd<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// status output</span>    <span class="token punctuation">.</span><span class="token function">busy</span><span class="token punctuation">(</span>tx_busy<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>uart_rx #<span class="token punctuation">(</span>    <span class="token punctuation">.</span><span class="token function">DATA_WIDTH</span><span class="token punctuation">(</span>DATA_WIDTH<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">CLK_FREQ</span><span class="token punctuation">(</span>CLK_FREQ<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">BAUD_RATE</span><span class="token punctuation">(</span>BAUD_RATE<span class="token punctuation">)</span><span class="token punctuation">)</span>uart_rx_inst <span class="token punctuation">(</span>    <span class="token punctuation">.</span><span class="token function">clk</span><span class="token punctuation">(</span>sys_clk<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">rst</span><span class="token punctuation">(</span><span class="token operator">~</span>sys_rst_n<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// axi output</span>    <span class="token punctuation">.</span><span class="token function">m_axis_tdata</span><span class="token punctuation">(</span>m_axis_tdata<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">m_axis_tvalid</span><span class="token punctuation">(</span>m_axis_tvalid<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">m_axis_tready</span><span class="token punctuation">(</span>m_axis_tready<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// input</span>    <span class="token punctuation">.</span><span class="token function">rxd</span><span class="token punctuation">(</span>uart_rxd<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// status output</span>    <span class="token punctuation">.</span><span class="token function">busy</span><span class="token punctuation">(</span>rx_busy<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">overrun_error</span><span class="token punctuation">(</span>rx_overrun_error<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">frame_error</span><span class="token punctuation">(</span>rx_frame_error<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div></figure><h2 id="测试结果">4.3、测试结果</h2><ul><li><p><strong>波特率</strong>：115200bps</p></li><li><p><strong>数据位</strong>：8位</p></li><li><p><strong>校验位</strong>：无</p></li><li><p><strong>停止位</strong>：1位</p></li></ul><figure><img src="/img/uart-introduction/image-3.png"alt="图 4 USB 串口回环测试结果图" /><figcaption aria-hidden="true">图 4 USB 串口回环测试结果图</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>三大低速总线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>通信协议</tag>
      
      <tag>UART</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8b/10b编码详解</title>
    <link href="/8b10b/"/>
    <url>/8b10b/</url>
    
    <content type="html"><![CDATA[<h1 id="b10b编码简介">1、8b/10b编码简介</h1><p>8B/10B 编码是 1983 年由 IBM 公司的 Al Widmer 和 Peter Franaszek所提出的数据传输编码标准，目前已经被广泛应用到高速串行总线。8B/10B编码将待发送的 8 位数据转换成 10位代码组，其目的是保证直流平衡，以及足够密集的电平转换。</p><p>在这些高速收发器的接收端需要通过 CDR技术去恢复时钟与数据的相位关系，在这个过程中需要不断地检测数据边沿和数据中心，从而调整时钟和数据的相位，因此需要保证接收的数据不断变化，从而给CDR 提供足够多的待检测数据边沿。</p><p>另外，高速接口电路一般采用交流耦合方式进行连接，在交流耦合电路中的信号线会接电容（隔直通交）。如果传输的数据在一段时间内全是1 或全是0，那么这段时间传输的信号可以等效成直流信号，会产生直流偏移，在通过电容时，有可能解码错误。</p><p>因此，<strong>通过 8B/10B 编码，保证编码后的数据在一定时间内 0的个数与 1 的个数保持相等。</strong></p><h1 id="b10b编码原理">2、8b/10b编码原理</h1><p>8B/10B 编码的原理是将 8 位数据编码成 10 位数据，编码后的数据中 0 和 1的个数相等，以保证数据的直流平衡。</p><p>当中 8bit 的原始数据可以分为两部分：<strong>低位的 5bitEDCBA(设其十进制数值为X)，高位的 3bit HGF(设其十进制数值为Y)，则该 8bit数据可以记为 D.X.Y。</strong> 比如待编码数据为 110_00011，高 3位数据的十进制为 6，低 5 位的十进制数据为 3，则 D.3.6 就表示110_00011。</p><p>编码时，低 5bit 原数据 EDCBA 经过 5B/6B 编码成为 6bit 码 abcdei，高3bit 原数据 HGF 经 3B/4B 成为 4bit 码fghj，最后再将两部分组合起来形成一个 10bit 码abcdeifghj，如下图所示：</p><figure><img src="/img/8b10b/image.png" alt="图 1 编码示意图" /><figcaption aria-hidden="true">图 1 编码示意图</figcaption></figure><p>另外，<strong>8B/10B 编码中还用到 12个控制字符，他们可以作为传输中帧起始、帧结束、传输空闲等状态标识，与数据字符的记法类似，控制字符一般记为K.X.Y。</strong> 8bit 数据有 256 种，加上 12 种控制字符，总共有 268种。10bit 数据有 1024 种，可以从 1024 种状态中选取 256 种 0 和 1个数相等的数据作为编码结果，在从剩下的数据中选取 12个作为控制字符，即常见的 K码。</p><p>8B/10B 编码中将 K28.1、K28.5 和 K28.7 作为 K码的控制字符，称为“comma”。在任意数据组合中，comma只作为控制字符出现，而在数据部分不会出现，因此可以用 comma字符指示帧的开始和结束标志，或用来修正和数据流对齐的控制字符。</p><h1 id="b10b编码表">3、8b/10b编码表</h1><p>我们首先要搞清楚三个概念：</p><ul><li><strong>编码对照表</strong>：用来对原始数据进行编码的查找表，在对原始8bit数据进行编码时，不需要进行一系列复杂的算法运算（自己推算也可），而是直接从查找表上去查找8bit 原始数据对应的 10bit 编码数据。</li><li><strong>Paireddisparity</strong>：成对差异即“1”的个数和“0”的个数相差 2个（完美平衡除外）。不论是 5B/6B编码还是 3B/4B编码，最终编码后的数据“1”和“0”的个数对比只有三种情况，第一种是“1”的个数比“0”的个数多2 个，第二种是“0”的个数比“1”的个数多 2个，第三种是“1”的个数和“0”的个数一样多。其中“1”的个数和“0”的个数一样多又称之为完美平衡，在完美平衡的状态下是不需要进行补偿的，只不过由于完美平衡的编码数量无法满足所有数据的编码需求，因此完美平衡实际是无法做到的。</li></ul><div class="note note-success">            <p>5位数据总共有32种状态，编码结果有6位数据，0和1数量相等的只有000_111、001_011…、110_001、111_000等20种状态。其中000_111和111_000存在三个连续相同的状态，并没有被使用。导致编码后0和1数据相等的结果就只有18种状态，并不能满足输入5位数据的32种数据状态，3B4B编码也有同样的问题。此时设计编码的人提出，一次编码如果不能保证编码结果0和1个数相等，那么可以让连续两次编码结果的0和1相等，也能满足要求。</p>          </div><ul><li><strong>Running disparity</strong>：运行不一致，在上文的 Paireddisparity中已经说过编码后的数据“1”的个数和“0”的个数不可能做到一直完美平衡（因为只有少数数据编码后是完美平衡，大多数数据编码后是成对差异的），要么“1”的个数比“0”多，要么反之。我们称这种“0”“1”个数差为“极性偏差”，用 RD 表示，当“1”的个数比“0”多的时候 RD的值为“+1”，反过来 RD 的值为“-1”。</li></ul><div class="note note-success">            <p>如果编码结果的1和0个数相等，称为平衡编码，此时RD的数值保持不变。如果编码结果1和0个数不等，称为非平衡编码，此时RD的数值翻转，下次编码采用RD对应数值的编码作为编码结果。</p>          </div><p>搞清楚这三个概念后，我们就可以开始进行 8B/10B 编码了。8B/10B 编码是由5B/6B 编码和 3B/4B 编码组成的，编码的过程是先进行 5B/6B 编码，再进行3B/4B 编码，最后将两部分编码结果组合成 10bit 编码。在编码的过程中，RD的数值会不断翻转，每次编码的起始 RD 都是上次编码结果的 RD。</p><div class="note note-info">            <p><strong>上次8B/10B编码结果的RD数值将用作本次5B/6B编码的起始RD，而3B/4B编码的起始RD等于上次5B/6B编码结果的RD，3B/4B编码结果的RD作为本次8B/10B编码的RD。</strong></p>          </div><p>对应的编码状态跳转如下图所示：</p><figure><img src="/img/8b10b/image-3.png" alt="图 2 编码状态跳转示意图" /><figcaption aria-hidden="true">图 2 编码状态跳转示意图</figcaption></figure><h2 id="b6b-编码表">3.1 5B/6B 编码表</h2><figure><img src="/img/8b10b/image-1.png" alt="图 3 5B/6B 编码表" /><figcaption aria-hidden="true">图 3 5B/6B 编码表</figcaption></figure><p>5bit 的数据位宽一共对应 32 个原始数据，所以在上图的 5B/6B编码中一共拥有 0~31个原始数据，其中“EDCBA”表示原始数据，“abcdei”表示编码后的数据。表中可以看到绝大多数数据都是有两个编码对应的，在实际使用的时候根据RD 的值来选择其中一个编码使用；还有一部分数据后面是携带标记符号的，如D.23、D.27、D.29、D.30，这些带标记符号的既是原始数据又是控制编码的一部分，主要用于K.x.7。其中还有一个 K28比较特殊，这是一个独立的控制编码不与数据复用，主要用于控制编码K.28.y。</p><h2 id="b4b-编码表">3.2 3B/4B 编码表</h2><figure><img src="/img/8b10b/image-2.png" alt="图 4 3B/4B 编码表" /><figcaption aria-hidden="true">图 4 3B/4B 编码表</figcaption></figure><p>在 3B/4B 编码当中大家要注意的是数字 7 有两种编码，分别是 D.x.P7 和D.x.A7，为什么要用两种编码方式呢？</p><div class="note note-success">            <p>主要是避免出现连续的 5 个“0”或“1”，例如当 RD 为 1 时对 D(11,7)进行编码，其中 11 编码后的数值是 110100 而 7 就只能使用 D.x.A7这种编码规则了，如果使用 D.x.P7 的编码规则，最后编码数据就成了1101000001，可以看到出现了连续的 5个“0”。因此大家在编码的时候一定要选择合适的编码规则。</p>          </div><p>在控制码的编码表中可以看到 K.x.1、 K.x.5、 K.x.7这三个控制码被特殊标记了，这三个特殊编码会和上文 5B/6B 编码中提到的 K28连用，组成 K.28.1、K.28.5 和 K.28.7三个特殊编码，这三个特殊编码是会出现连续 5个“0”或“1”的，这种特殊码又称之为“commasymbols”。它们不会出现在数据负荷部分，并且只要出现就一定是控制码，通常用它们作为帧的开始和结束标志，或者数据流对齐的控制字符。</p><p>除了K.28.1、K.28.5 和 K.28.7 这三个特殊编码外还要注意上文 5B/6B编码中提到的 D.23、D.27、D.29、D.30 这几个特殊数值，在控制码中他们只能和K.x.7 连用组成 K.23.7、K.27.7、K.29.7、K.30.7这四个特殊控制码。原因和数字 7 的两套编码规则一样，避免出现连续的 5个“0”或“1”。</p><p><strong>完整的控制码编码表如下：</strong></p><figure><img src="/img/8b10b/image-4.png" alt="图 5 控制码编码示意图" /><figcaption aria-hidden="true">图 5 控制码编码示意图</figcaption></figure><h1 id="b10b编码实例">4、8b/10b编码实例</h1><p>Xilinx<ahref="https://docs.amd.com/v/u/en-US/ug476_7Series_Transceivers">UG476</a>手册的附录有所有8B/10B 编码数据的结果, 以及对应的RD值。这里以手册中的数据为例，对 8B/10B编码进行实例分析。</p><div class="note note-info">            <p><strong>问题一</strong></p><p>请问 D.8.3 的 8B/10B 编码结果是多少？</p>          </div><p>第一个原始数据在进行编码的时候是默认 RD 为“-1”。D.8 的 5B/6B编码结果为 111001，5B/6B 编码完成后，RD 翻转变为 1。将 RD=1 作为 D.x.3的 3B/4B 编码起始 RD，根据查表得编码结果为 0011，再次将 RD翻转，作为本次 8B/10B 编码结果的 RD。因此<strong>起始 RD=-1 的编码结果为111001_0011。</strong></p><p>与正确答案一致，编码结果为 111001_0011：</p><figure><img src="/img/8b10b/image-5.png" alt="图 6 D.8.3 的 8B/10B 编码结果" /><figcaption aria-hidden="true">图 6 D.8.3 的 8B/10B编码结果</figcaption></figure><div class="note note-info">            <p><strong>问题二</strong></p><p>当前 RD=1，则 K.28.5、D.2.6、D.23.4 的编码结果依次是多少，且最终的 RD是多少？</p>          </div><p>首先 RD=1 时，查得 k.28 编码结果为 110000，这是不平衡编码，RD的最终结果会翻转，RD=-1；K.x.5 的3B/4B编码是 0101，这是平衡编码，因此 RD不变，等于 -1。</p><p>因此 D.2.6 的起始 RD=-1，首先 D.2 的 5B/6B 编码结果为 101101，RD翻转变为 1。D.x.6 的 3B/4B 编码结果为 0110，由于 D.x.6 是平衡编码，因此RD 保持不变，等于 1。故 D.2.6 的编码结果为 101101_0110，RD 最终为1。</p><p>最后，D.23.4 的起始 RD=1，D.23.4 的 5B6B 编码结果为 000101，RD 翻转为-1。之后 D.x.4 的编码结果为 1101，RD 的极性再次翻转为 1。</p><p>所以 K.28.5、D.2.6、D.23.4 的编码结果依次是110000_0101、101101_0110、000101_1101，RD 的最终取值为 1。D.2.6、D.23.4的手册查表结果如下图所示，与上述计算结果保持相同，证明编码规则没有问题。</p><figure><img src="/img/8b10b/image-7.png" alt="图 7 D.2.6 的 8B/10B 编码结果" /><figcaption aria-hidden="true">图 7 D.2.6 的 8B/10B编码结果</figcaption></figure><figure><img src="/img/8b10b/image-6.png"alt="图 8 D.23.4 的 8B/10B 编码结果" /><figcaption aria-hidden="true">图 8 D.23.4 的 8B/10B编码结果</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>高速收发器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字编码</tag>
      
      <tag>FPGA</tag>
      
      <tag>8b/10b</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<center>繁星纵变，智慧永存！</center>]]></content>
    
  </entry>
  
  
  
</search>
