<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>HDLBits刷题日记（五）</title>
    <link href="/HDLBits_five/"/>
    <url>/HDLBits_five/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>打算利用碎片化时间重温一遍Verilog语法，好记忆不如烂笔头，在此记录一下HDLBits刷题的过程，记录一些知识点，方便日后再次复习。</p>          </div><h1 id="verilog-language---moduleshierarchy">1、Verilog Language -Modules:Hierarchy</h1><h2 id="problem-19-module">Problem 19 : Module</h2><p>模块，它是一个通过输入和输出端口与外部进行交互的电路。更大、更复杂的电路是通过将较小的模块组合成较大的模块，以及将其他部分(如 assign 语句和 always 块)连接在一起来构建的。这形成了一个层次结构，因为模块可以包含其他模块的实例。模块的层次结构是通过在另一个模块中实例化一个模块来创建的，只要所有使用的模块都属于同一个项目(这样编译器就知道在哪里找到该模块)。通常一个文件只包含一个模块。</p><p>在实例化模块时，有两种常用的方式来进行模块端口的信号连接：按端口顺序以及按端口名称连接端口。</p><p><strong>按端口顺序，</strong> mod_a instance1 ( wa, wb, wc ); wa, wb,wc 分别连接到模块的第一个端口（in1），第二个端口（in2）以及第三个端口（out）。这里所谓的端口顺序指的是模块端口的定义顺序。这种方式的弊端在于，一旦端口列表发生改变，所有模块实例化中的端口连接都需要改变。</p><p><strong>按端口名称，</strong> mod_a instance2 ( .out(wc), .in1(wa),.in2(wb) );在这种方式中根据端口名称指定外部信号的连接。这样一来就和端口声明的顺序完全没有关系。一旦模块出现改动，只要修改相应的部分即可。实际上，一般都使用这种方式来进行模块实例化。</p><p>下图显示了一个非常简单的电路，其中包含一个子模块。在这个练习中，创建一个模块mod_a 的实例，然后将模块的三个引脚 (in1、in2 和 out)连接到顶级模块的三个端口 (线路 a、b 和 out)。</p><figure><img src="/img/HDLBits_five/Module.png" alt="Module" /><figcaption aria-hidden="true">Module</figcaption></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> top_module <span class="token punctuation">(</span> <span class="token keyword">input</span> a<span class="token punctuation">,</span> <span class="token keyword">input</span> b<span class="token punctuation">,</span> <span class="token keyword">output</span> out <span class="token punctuation">)</span><span class="token punctuation">;</span>        mod_a U_mod_a <span class="token punctuation">(</span>        <span class="token punctuation">.</span><span class="token function">in1</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">.</span><span class="token function">in2</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">.</span><span class="token function">out</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//mod_a U_mod_a(a, b, out); //使用按照端口顺序的方式 声明信号连接</span><span class="token keyword">endmodule</span></code></pre></div></figure><h2 id="problem-20-module-pos">Problem 20 : Module pos</h2><p><code>module mod_a ( output, output, input, input, input, input );</code></p><p>模块 mod_a有四个输入端口和两个输出端口。它的端口声明顺序是：out1、out2、in1、in2、in3、in4。现在在顶级模块中实例化mod_a 模块，并将其端口连接到顶级模块的四个输入端口 (a、b、c 和 d)和两个输出端口 (out1 和out2)。<strong>注意，端口连接的顺序与模块的端口声明顺序相同。</strong></p><figure><img src="/img/HDLBits_five/Module_pos.png" alt="Module_pos" /><figcaption aria-hidden="true">Module_pos</figcaption></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> top_module <span class="token punctuation">(</span>     <span class="token keyword">input</span> a<span class="token punctuation">,</span>     <span class="token keyword">input</span> b<span class="token punctuation">,</span>     <span class="token keyword">input</span> c<span class="token punctuation">,</span>    <span class="token keyword">input</span> d<span class="token punctuation">,</span>    <span class="token keyword">output</span> out1<span class="token punctuation">,</span>    <span class="token keyword">output</span> out2<span class="token punctuation">)</span><span class="token punctuation">;</span>    mod_a <span class="token function">name</span><span class="token punctuation">(</span>out1<span class="token punctuation">,</span>out2<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">endmodule</span></code></pre></div></figure><h2 id="problem-21-module-name">Problem 21 : Module name</h2><p><code>module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);</code></p><figure><img src="/img/HDLBits_five/Module_name.png" alt="Module_name" /><figcaption aria-hidden="true">Module_name</figcaption></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> top_module <span class="token punctuation">(</span>     <span class="token keyword">input</span> a<span class="token punctuation">,</span>     <span class="token keyword">input</span> b<span class="token punctuation">,</span>     <span class="token keyword">input</span> c<span class="token punctuation">,</span>    <span class="token keyword">input</span> d<span class="token punctuation">,</span>    <span class="token keyword">output</span> out1<span class="token punctuation">,</span>    <span class="token keyword">output</span> out2<span class="token punctuation">)</span><span class="token punctuation">;</span>    mod_a <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">out1</span><span class="token punctuation">(</span>out1<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token function">out2</span><span class="token punctuation">(</span>out2<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token function">in1</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token function">in2</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token function">in3</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token function">in4</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre></div></figure><h2 id="problem-22-module-shift">Problem 22 : Module shift</h2><p>给出了一个名为 my_dff 的模块，包含两个输入和一个输出(实现 D触发器的功能)。实例化三个 my_dff，然后将它们连接在一起，构成长度为 3的移位寄存器。注意：clk 端口需要连接到所有的寄存器实例上。</p><p><code>module my_dff ( input clk, input d, output q );</code></p><figure><img src="/img/HDLBits_five/Module_shift.png" alt="Module_shift" /><figcaption aria-hidden="true">Module_shift</figcaption></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> top_module <span class="token punctuation">(</span>     <span class="token keyword">input</span> clk<span class="token punctuation">,</span>     <span class="token keyword">input</span> d<span class="token punctuation">,</span>     <span class="token keyword">output</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">wire</span> q1<span class="token punctuation">,</span> q2<span class="token punctuation">;</span> <span class="token comment">//定义中间信号</span>    my_dff <span class="token function">dff1</span><span class="token punctuation">(</span>clk<span class="token punctuation">,</span> d<span class="token punctuation">,</span> q1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//实例化第一个 D 触发器</span>    my_dff <span class="token function">dff2</span><span class="token punctuation">(</span>clk<span class="token punctuation">,</span> q1<span class="token punctuation">,</span> q2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//实例化第二个 D 触发器</span>    my_dff <span class="token function">dff3</span><span class="token punctuation">(</span>clk<span class="token punctuation">,</span> q2<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//实例化第三个 D 触发器</span><span class="token keyword">endmodule</span></code></pre></div></figure><h2 id="problem-23-module-shift8">Problem 23 : Module shift8</h2><p><code>module my_dff8 ( input clk, input [7:0] d, output [7:0] q );</code></p><figure><img src="/img/HDLBits_five/Module_shift8.png" alt="Module_shift8" /><figcaption aria-hidden="true">Module_shift8</figcaption></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> top_module <span class="token punctuation">(</span>     <span class="token keyword">input</span> clk<span class="token punctuation">,</span>     <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> d<span class="token punctuation">,</span>     <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> sel<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> q1<span class="token punctuation">,</span> q2<span class="token punctuation">,</span>q3<span class="token punctuation">;</span> <span class="token comment">//定义中间信号</span>    my_dff8 <span class="token function">dff1</span><span class="token punctuation">(</span>clk<span class="token punctuation">,</span> d<span class="token punctuation">,</span> q1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//实例化第一个 D 触发器</span>    my_dff8 <span class="token function">dff2</span><span class="token punctuation">(</span>clk<span class="token punctuation">,</span> q1<span class="token punctuation">,</span> q2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//实例化第二个 D 触发器</span>    my_dff8 <span class="token function">dff3</span><span class="token punctuation">(</span>clk<span class="token punctuation">,</span> q2<span class="token punctuation">,</span> q3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//实例化第二个 D 触发器</span>    <span class="token keyword">assign</span> q <span class="token operator">=</span> <span class="token punctuation">(</span>sel <span class="token operator">==</span> <span class="token number">2'b00</span><span class="token punctuation">)</span> <span class="token operator">?</span> d <span class="token punctuation">:</span> <span class="token comment">//当 sel 为 00 时，输出 d</span>               <span class="token punctuation">(</span>sel <span class="token operator">==</span> <span class="token number">2'b01</span><span class="token punctuation">)</span> <span class="token operator">?</span> q1 <span class="token punctuation">:</span> <span class="token comment">//当 sel 为 01 时，输出 q1</span>               <span class="token punctuation">(</span>sel <span class="token operator">==</span> <span class="token number">2'b10</span><span class="token punctuation">)</span> <span class="token operator">?</span> q2 <span class="token punctuation">:</span> <span class="token comment">//当 sel 为 10 时，输出 q2</span>               q3<span class="token punctuation">;</span> <span class="token comment">//当 sel 为 11 时，输出 q3</span>        <span class="token comment">// always @(*)  // 组合逻辑always块</span>    <span class="token comment">// case(sel)</span>    <span class="token comment">//   2'h0: q = d;</span>    <span class="token comment">//   2'h1: q = q1;</span>    <span class="token comment">//   2'h2: q = q2;</span>    <span class="token comment">//   2'h3: q = q3;</span>    <span class="token comment">// endcase</span><span class="token keyword">endmodule</span></code></pre></div></figure><h2 id="problem-24-module-add">Problem 24 : Module add</h2><p><code>module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );</code></p><figure><img src="/img/HDLBits_five/Module_add.png" alt="Module_add" /><figcaption aria-hidden="true">Module_add</figcaption></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> top_module <span class="token punctuation">(</span>     <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span>     <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span>      <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">wire</span> c1<span class="token punctuation">,</span>cout<span class="token punctuation">;</span> <span class="token comment">//定义中间进位信号</span>    add16 <span class="token function">adder1</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> sum<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> c1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//实例化第一个 8 位加法器</span>    add16 <span class="token function">adder2</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">,</span> c1<span class="token punctuation">,</span> sum<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">,</span> cout<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//实例化第二个 8 位加法器</span><span class="token keyword">endmodule</span></code></pre></div></figure><h2 id="problem-25-module-fadd">Problem 25 : Module fadd</h2><p><code>module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );</code></p><p><code>module add1 ( input a, input b, input cin, output sum, output cout );</code></p><figure><img src="/img/HDLBits_five/Module_fadd.png" alt="Module_fadd" /><figcaption aria-hidden="true">Module_fadd</figcaption></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> top_module <span class="token punctuation">(</span>     <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span>     <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span>      <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">wire</span> c1<span class="token punctuation">,</span>cout<span class="token punctuation">;</span> <span class="token comment">//定义中间进位信号</span>    add16 <span class="token function">adder1</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> sum<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> c1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//实例化第一个 8 位加法器</span>    add16 <span class="token function">adder2</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">,</span> c1<span class="token punctuation">,</span> sum<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">,</span> cout<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//实例化第二个 8 位加法器</span><span class="token keyword">endmodule</span><span class="token keyword">module</span> add1 <span class="token punctuation">(</span> <span class="token keyword">input</span> a<span class="token punctuation">,</span> <span class="token keyword">input</span> b<span class="token punctuation">,</span> <span class="token keyword">input</span> cin<span class="token punctuation">,</span>   <span class="token keyword">output</span> sum<span class="token punctuation">,</span> <span class="token keyword">output</span> cout <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Full adder module here</span><span class="token keyword">assign</span> <span class="token operator">&#123;</span>cout<span class="token punctuation">,</span>sum<span class="token operator">&#125;</span> <span class="token operator">=</span> a<span class="token operator">+</span>b<span class="token operator">+</span>cin<span class="token punctuation">;</span><span class="token comment">//全加器逻辑</span><span class="token comment">//assign sum = a ^ b ^ cin;</span><span class="token comment">//assign cout = a&amp;b | a&amp;cin | b&amp;cin;</span><span class="token keyword">endmodule</span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>HDLBits刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>HDLBits</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位操作替代取模运算</title>
    <link href="/%E4%BD%8D%E6%93%8D%E4%BD%9C%E6%9B%BF%E4%BB%A3%E5%8F%96%E6%A8%A1%E8%BF%90%E7%AE%97/"/>
    <url>/%E4%BD%8D%E6%93%8D%E4%BD%9C%E6%9B%BF%E4%BB%A3%E5%8F%96%E6%A8%A1%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>在日常学习中，常常碰到一些巧妙的设计思路，好记性不如烂笔头，在此记录，方便后续自己的查阅复习，如果能帮助到其他同学那就更好了。活到老学到老，FPGA设计技巧系列将持续更新，内容如有不妥之处，欢迎评论区指正，共同学习进步。</p>          </div><h1 id="位操作替代取模运算">1、位操作替代取模运算</h1><p>在数字电路设计中，当模数为2的幂时（如<spanclass="math inline">\(64=2^6\)</span>），可以<strong>用位操作替代取模运算。</strong></p><ul><li><p>二进制特性：$ N = 2^n $ 的二进制形式为 1 后跟 <spanclass="math inline">\(n\)</span> 个 0（如 64 = 1000000）</p></li><li><p><span class="math inline">\(N-1\)</span> 的二进制：<spanclass="math inline">\(N-1\)</span> 的二进制为 <spanclass="math inline">\(n\)</span> 个 1（如 63 = 0111111）</p></li><li><p>位操作效果：<span class="math inline">\(x\)</span> &amp; <spanclass="math inline">\((N-1)\)</span> 会直接保留 <spanclass="math inline">\(x\)</span> 的低 <spanclass="math inline">\(n\)</span> 位（等效于取模）</p></li></ul><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">// 假设 base_addr + data_cnt = 127 (01111111₂)</span><span class="token keyword">assign</span> rd_addr_mod <span class="token operator">=</span> <span class="token number">127</span> <span class="token operator">%</span> <span class="token number">64</span><span class="token punctuation">;</span>    <span class="token comment">// 结果 = 63 (0111111₂)</span><span class="token keyword">assign</span> rd_addr_and <span class="token operator">=</span> <span class="token number">127</span> <span class="token operator">&amp;</span> <span class="token number">63</span><span class="token punctuation">;</span>    <span class="token comment">// 结果 = 63 (0111111₂)</span><span class="token comment">// 假设 base_addr + data_cnt = 65 (01000001₂)</span><span class="token keyword">assign</span> rd_addr_mod <span class="token operator">=</span> <span class="token number">65</span> <span class="token operator">%</span> <span class="token number">64</span><span class="token punctuation">;</span>     <span class="token comment">// 结果 = 1 (0000001₂)</span><span class="token keyword">assign</span> rd_addr_and <span class="token operator">=</span> <span class="token number">65</span> <span class="token operator">&amp;</span> <span class="token number">63</span><span class="token punctuation">;</span>     <span class="token comment">// 结果 = 1 (0000001₂)</span></code></pre></div></figure><p>当然，我们也可以简单仿真验证一下：</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">mod_2_n</span><span class="token punctuation">(</span>    <span class="token keyword">input</span> clk<span class="token punctuation">,</span>    <span class="token keyword">input</span> rst_n<span class="token punctuation">,</span>    <span class="token keyword">output</span> MyFlag<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data_cnt<span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> rd_addr<span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> wr_addr<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">~</span>rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span>        data_cnt <span class="token operator">&lt;=</span> <span class="token number">6'd0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>        data_cnt <span class="token operator">&lt;=</span> data_cnt <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">~</span>rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span>        rd_addr <span class="token operator">&lt;=</span>  <span class="token number">6'd0</span><span class="token punctuation">;</span>        wr_addr <span class="token operator">&lt;=</span>  <span class="token number">6'd0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>        rd_addr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">48</span> <span class="token operator">+</span> data_cnt<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">64</span><span class="token punctuation">;</span>        wr_addr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">48</span> <span class="token operator">+</span> data_cnt<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">6'h3F</span><span class="token punctuation">;</span> <span class="token comment">// 与63(111111)进行位与操作</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token keyword">assign</span> MyFlag <span class="token operator">=</span> wr_addr <span class="token operator">==</span> rd_addr<span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`timescale</span> <span class="token number">1</span>ns<span class="token operator">/</span><span class="token number">1</span>ps<span class="token keyword">module</span> <span class="token function">tb_mod_2_n</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 定义测试信号</span>    <span class="token keyword">reg</span> clk<span class="token punctuation">;</span>    <span class="token keyword">reg</span> rst_n<span class="token punctuation">;</span>    <span class="token keyword">wire</span> MyFlag<span class="token punctuation">;</span>        <span class="token comment">// 实例化被测模块</span>    mod_2_n dut <span class="token punctuation">(</span>        <span class="token punctuation">.</span><span class="token function">clk</span><span class="token punctuation">(</span>clk<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">.</span><span class="token function">rst_n</span><span class="token punctuation">(</span>rst_n<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">.</span><span class="token function">MyFlag</span><span class="token punctuation">(</span>MyFlag<span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 时钟生成</span>    <span class="token keyword">initial</span> <span class="token keyword">begin</span>        clk <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">forever</span> <span class="token number">#5</span> clk <span class="token operator">=</span> <span class="token operator">~</span>clk<span class="token punctuation">;</span> <span class="token comment">// 10ns周期（100MHz）时钟</span>    <span class="token keyword">end</span>        <span class="token comment">// 测试过程</span>    <span class="token keyword">initial</span> <span class="token keyword">begin</span>        <span class="token comment">// 波形输出</span>        <span class="token kernel-function property">$dumpfile</span><span class="token punctuation">(</span><span class="token string">"tb_mod_2_n.vcd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token kernel-function property">$dumpvars</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> tb_mod_2_n<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 初始复位</span>        rst_n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token number">#20</span><span class="token punctuation">;</span>        rst_n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment">// 运行足够长的时间以观察多个周期</span>        <span class="token number">#1500</span><span class="token punctuation">;</span> <span class="token comment">// 运行150个时钟周期，足以观察64个计数和环绕</span>                <span class="token comment">// 再次复位测试</span>        rst_n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token number">#20</span><span class="token punctuation">;</span>        rst_n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token number">#680</span><span class="token punctuation">;</span>                <span class="token kernel-function property">$display</span><span class="token punctuation">(</span><span class="token string">"测试完成"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token kernel-function property">$finish</span><span class="token punctuation">;</span>    <span class="token keyword">end</span>        <span class="token comment">// 监控信号</span>    <span class="token keyword">initial</span> <span class="token keyword">begin</span>        <span class="token kernel-function property">$monitor</span><span class="token punctuation">(</span><span class="token string">"Time=%0t, rst_n=%b, wr_addr=%d, rd_addr=%d, MyFlag=%b"</span><span class="token punctuation">,</span>                  <span class="token kernel-function property">$time</span><span class="token punctuation">,</span> rst_n<span class="token punctuation">,</span> dut<span class="token punctuation">.</span>wr_addr<span class="token punctuation">,</span> dut<span class="token punctuation">.</span>rd_addr<span class="token punctuation">,</span> MyFlag<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">end</span>    <span class="token keyword">endmodule</span></code></pre></div></figure><p>仿真结果如下图所示，我们可以看到 <code>wr_addr</code> 和<code>rd_addr</code> 的值始终相等，即 <code>MyFlag</code> 信号始终为1。</p><figure><img src="/img/位操作替代取模运算/1742214787466.png" alt="仿真结果" /><figcaption aria-hidden="true">仿真结果</figcaption></figure><h1 id="注意事项">2、注意事项</h1><ul><li><p>位操作替代取模运算的前提是模数为2的幂，否则无法使用该方法。</p></li><li><p>操作数为无符号数：有符号数的位操作会保留符号位，导致错误。</p></li></ul><h1 id="代码下载">3、代码下载</h1><p>博客中涉及到的代码均在我的<ahref="https://github.com/yao-jiangyu/MyBlogCode">GitHub仓库</a>中，欢迎大家下载学习。</p>]]></content>
    
    
    <categories>
      
      <category>FPGA设计技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>Verilog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异步FIFO详解</title>
    <link href="/async_fifo/"/>
    <url>/async_fifo/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>在学习科研的闲暇之余，打算记录一些FPGA基础知识，方便后续自己的查阅复习，如果能帮助到其他同学那就更好了。本文主要介绍异步FIFO的实现原理，内容如有不妥之处，欢迎评论区指正，共同学习进步。</p>          </div><h1 id="fifo概述">1、FIFO概述</h1><p>FIFO（First In FirstOut）是一种先进先出的数据存储、缓存器。我们知道一般的存储器是用外部的读写地址来进行读写，而FIFO这种存储器的结构并不需要外部的读写地址而是通过内部的读写指针自动的加一操作来控制读写，这也就决定了FIFO只能顺序的读写数据。FIFO本质上是由 RAM 加读写控制逻辑构成的一种先进先出的数据缓冲器。</p><p>FIFO 有两种类型：同步 FIFO 和异步 FIFO。同步 FIFO使用同一个时钟信号来控制数据的读写，而异步 FIFO有两个时钟信号，一个用于读操作，另一个用于写操作。这两个时钟可能时钟频率不同，也可能时钟相位不同，可能是同源时钟，也可能是不同源时钟。异步FIFO 实质上也是基于中间的双口RAM，外加一些读写控制电路组成的。</p><p><strong>同步 FIFO 的作用一般是做一个数据缓冲，也就是一个 buffer。异步FIFO有两个较为重要的作用：一个是实现数据在不同时钟域进行传递，另一个作用就是实现不同数据宽度的数据接口。</strong></p><h1 id="异步fifo的实现">2、异步FIFO的实现</h1><p>和同步 FIFO 一样，对于异步 FIFO的空满信号的产生，也能通过写读指针的比较来实现。同样也是<strong>在读指针追上写指针时，FIFO为空；在写指针追上读指针时，FIFO 为满。</strong>但是异步 FIFO的读写指针是由两个时钟控制的，时钟不同步，无法直接比较，只能<strong>将读时钟域的读指针转换到写时钟域，与写指针进行比较，判断FIFO 是否为满；将写时钟域的写指针转换到读时钟域，与读指针进行比较，判断FIFO 是否为空。</strong></p><p>以上操作将会涉及到跨时钟域问题，而跨时钟域传输的一旦没处理好就会引起亚稳态问题。亚稳态不可完全避免，只能通过一些手段如：引入同步机制（打2拍）以及格雷码等来降低亚稳态出现的机率。</p><h2 id="同步到写时钟域">2.1、同步到写时钟域</h2><p>读指针同步到写时钟域需要时间T，在经过T时间后，可能原来的读指针会增加或者不变，也就是说同步后的读指针一定是小于等于原来的读指针的。写指针也可能发生变化，但是写指针本来就在这个时钟域，所以是不需要同步的，也就意味着进行对比的写指针就是真实的写指针。</p><p>当我们认为写指针追上了同步后的读指针时，实际上读时钟域的读指针是大于等于同步后的读指针的，所以这个时候写指针不一定刚好追上读指针（可能还差一点点），也就是说这种情况是“假写满”。那么“假写满”是不会造成功能错误，只会造成性能损失，事实上这还可以算是某种程度上的保守设计（安全）。</p><h2 id="同步到读时钟域">2.2、同步到读时钟域</h2><p>写指针同步到读时钟域需要时间T，在经过T时间后，可能原来的写指针会增加或者不变，也就是说同步后的写指针一定是小于等于原来的写指针的。读指针也可能发生变化，但是读指针本来就在这个时钟域，所以是不需要同步的，也就意味着进行对比的读指针就是真实的读指针。</p><p>当我们认为读指针追上了同步后的写指针时，实际上写时钟域的写指针是大于等于同步后的写指针的，所以这个时候读指针不一定刚好追上写指针（可能还差一点点），也就是说这种情况是“假读空”。那么“假读空”是不会造成功能错误，只会造成性能损失，事实上这还可以算是某种程度上的保守设计（安全）。</p><h2 id="格雷码">2.3、格雷码</h2><p>将一个时钟域上的指针同步到另一个时钟域，如果数据用二进制的方式进行同步的话就会出现多位数据同时跳变的问题，比如3'b011到3'b100即3到4跳变会引起多位数据的改变，这样会大大增加出错的概率。Gray码就很好的解决了上述问题，gray码相邻数据只有一位跳变，这样就大大降低了数据出错的概率，有效的避免了在跨时钟域情况下亚稳态问题发生。</p><p>引入格雷码同时也引入一个问题，就是数据空满标志的判断不再是二进制时候的判断标准，这时由格雷码是镜像对称而造成的。</p><figure><img src="/img/异步fifo/188f5cc554dc55bb6bd6ee1e74582264.jpg"alt="格雷码镜像对称" /><figcaption aria-hidden="true">格雷码镜像对称</figcaption></figure><ul><li><p>如果是空状态的话，无可厚非，仍然是要满足<strong>读指针</strong>和<strong>写指针</strong>每一位都相等。</p></li><li><p>如果是满状态的话，要满足<strong>读指针</strong>和<strong>写指针</strong>的高位和次高位相反，其余各位相等。</p></li></ul><p>还有一种办法就是将同步后的格雷码再转换成二进制码进行比较。</p><p>格雷码是二进制码右移1位再与原码相异或的结果，如下图所示<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[掰开揉碎讲 FIFO（同步FIFO和异步FIFO）](https://www.cnblogs.com/DoreenLiu/p/17348480.html)">[1]</span></a></sup>。</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">//地址指针从二进制转换成格雷码</span><span class="token keyword">assign</span> wr_ptr_g <span class="token operator">=</span> wr_ptr <span class="token operator">^</span> <span class="token punctuation">(</span>wr_ptr <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">assign</span> rd_ptr_g <span class="token operator">=</span> rd_ptr <span class="token operator">^</span> <span class="token punctuation">(</span>rd_ptr <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div></figure><figure><img src="/img/异步fifo/image.png" alt="格雷码与二进制码" /><figcaption aria-hidden="true">格雷码与二进制码</figcaption></figure><h2id="快时钟域的信号同步到慢时钟域造成的漏采">2.4、快时钟域的信号同步到慢时钟域造成的漏采</h2><p>快时钟采慢时钟可以直接采（打拍），但是快时钟信号同步到慢时钟域却有可能发生漏采的问题（在单bit的应用中需要展宽快时钟以便能被慢时钟采集到）。</p><p>在异步 FIFO 中，这样的漏采问题是不影响 FIFO的逻辑操作。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[＜FPGA＞异步FIFO的Verilg实现方法](https://blog.csdn.net/wuzhikaidetb/article/details/121152844?ops_request_misc=%257B%2522request%255Fid%2522%253A%25225678a482f6e3ca87276028f1fb0010d0%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=5678a482f6e3ca87276028f1fb0010d0&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-121152844-null-null.nonecase&amp;utm_term=fifo&amp;spm=1018.2226.3001.4450)">[2]</span></a></sup>分析如下：</p><p><strong>读时钟域慢——写时钟域快：</strong></p><p>在进行写满判断的时候：需要将读指针同步到写时钟域，因为<code>读时钟域慢、写时钟域快</code>，所以在写时钟域中采集到的读指针，是不会有遗漏的情况出现，同步会消耗时钟周期，所以同步后的读指针会小于等于当前读地址，所以可能写满会提前产生，并非真写满。</p><p>进行读空判断的时候：需要将写指针同步到读时钟域，因为读时钟域慢、写时钟域快，所以当读时钟同步写指针的时候，必然会漏掉一部分写指针，漏掉的指针并不会对FIFO的读空产生影响。比如写指针从0写到10，期间读时钟域只同步捕捉到了3、5、8这三个写指针而漏掉了其他指针。当同步到8这个写指针时，真实的写指针可能已经写到10，相当于在读时钟域还没来得及觉察的情况下，写时钟域可能写了数据到 FIFO去，所以可能读空会提前产生，并非真读空。</p><p><strong>读时钟域快——写时钟域慢：</strong></p><p>在进行读空判断的时候：需要将写指针同步到读时钟域，因为<code>读时钟域快、写时钟域慢</code>，所以在读时钟域中采集到的写指针，是不会有遗漏的情况出现，同步会消耗时钟周期，所以同步后的写指针会小于等于当前写地址，所以可能读空会提前产生，并非真读空。</p><p>进行写满判断的时候：需要将读指针同步到写时钟域，因为<code>读时钟域快、写时钟域慢</code>，所以当写时钟同步读指针的时候，必然会漏掉一部分读指针，漏掉的指针并不会对FIFO的写满产生影响。比如读指针从0读到10，期间写时钟域只同步捕捉到了3、5、8这三个读指针而漏掉了其他指针。当同步到8这个读指针时，真实的读指针可能已经读到10，相当于在写时钟域还没来得及觉察的情况下，读时钟域可能读了数据到 FIFO去，所以可能写满会提前产生，并非真写满。</p><h1 id="异步fifo的设计">3、异步FIFO的设计</h1><ul><li><p>读、写时钟域下的读、写指针，指针位数需拓展一位。</p></li><li><p>将读、写指针从二进制码转换成格雷码。</p></li><li><p>将格雷码形式的读指针同步到写时钟域；将格雷码形式的写指针同步到读时钟域。</p></li></ul><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">//将读指针的格雷码同步到写时钟域，来判断是否写满</span><span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> wr_clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> wr_rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>wr_rst_n<span class="token punctuation">)</span><span class="token keyword">begin</span>rd_ptr_g_d1 <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//寄存1拍</span>rd_ptr_g_d2 <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//寄存2拍</span><span class="token keyword">end</span><span class="token keyword">else</span> <span class="token keyword">begin</span>rd_ptr_g_d1 <span class="token operator">&lt;=</span> rd_ptr_g<span class="token punctuation">;</span><span class="token comment">//寄存1拍</span>rd_ptr_g_d2 <span class="token operator">&lt;=</span> rd_ptr_g_d1<span class="token punctuation">;</span><span class="token comment">//寄存2拍</span><span class="token keyword">end</span><span class="token keyword">end</span><span class="token comment">//将写指针的格雷码同步到读时钟域，来判断是否读空</span><span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> rd_clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rd_rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rd_rst_n<span class="token punctuation">)</span><span class="token keyword">begin</span>wr_ptr_g_d1 <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//寄存1拍</span>wr_ptr_g_d2 <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//寄存2拍</span><span class="token keyword">end</span><span class="token keyword">else</span> <span class="token keyword">begin</span>wr_ptr_g_d1 <span class="token operator">&lt;=</span> wr_ptr_g<span class="token punctuation">;</span><span class="token comment">//寄存1拍</span>wr_ptr_g_d2 <span class="token operator">&lt;=</span> wr_ptr_g_d1<span class="token punctuation">;</span><span class="token comment">//寄存2拍</span><span class="token keyword">end</span><span class="token keyword">end</span></code></pre></div></figure><ul><li>读、写指针的比较，判断 FIFO 是否为空、满。</li></ul><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">//当所有位相等时，读指针追到到了写指针，FIFO被读空</span><span class="token keyword">assign</span>empty <span class="token operator">=</span> <span class="token punctuation">(</span> wr_ptr_g_d2 <span class="token operator">==</span> rd_ptr_g <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1'b1</span> <span class="token punctuation">:</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token comment">//当高位相反且其他位相等时，写指针超过读指针一圈，FIFO被写满</span><span class="token comment">//同步后的读指针格雷码高两位取反，再拼接上余下位</span><span class="token keyword">assign</span>full  <span class="token operator">=</span> <span class="token punctuation">(</span> wr_ptr_g <span class="token operator">==</span> <span class="token operator">&#123;</span> <span class="token operator">~</span><span class="token punctuation">(</span>rd_ptr_g_d2<span class="token punctuation">[</span><span class="token kernel-function property">$clog2</span><span class="token punctuation">(</span>DATA_DEPTH<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token kernel-function property">$clog2</span><span class="token punctuation">(</span>DATA_DEPTH<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>rd_ptr_g_d2<span class="token punctuation">[</span><span class="token kernel-function property">$clog2</span><span class="token punctuation">(</span>DATA_DEPTH<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">)</span><span class="token operator">?</span> <span class="token number">1'b1</span> <span class="token punctuation">:</span> <span class="token number">1'b0</span><span class="token punctuation">;</span></code></pre></div></figure><h1 id="代码下载">4、代码下载</h1><p>博客中涉及到的代码均在我的<ahref="https://github.com/yao-jiangyu/MyBlogCode">GitHub仓库</a>中，欢迎大家下载学习。</p><h1 id="参考资料">5、参考资料</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><ahref="https://www.cnblogs.com/DoreenLiu/p/17348480.html">掰开揉碎讲FIFO（同步FIFO和异步FIFO）</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><ahref="https://blog.csdn.net/wuzhikaidetb/article/details/121152844?ops_request_misc=%257B%2522request%255Fid%2522%253A%25225678a482f6e3ca87276028f1fb0010d0%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=5678a482f6e3ca87276028f1fb0010d0&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-121152844-null-null.nonecase&amp;utm_term=fifo&amp;spm=1018.2226.3001.4450">＜FPGA＞异步FIFO的Verilg实现方法</a><a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>FPGA基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>FIFO</tag>
      
      <tag>Verilog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>同步FIFO详解</title>
    <link href="/sync_fifo/"/>
    <url>/sync_fifo/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>在学习科研的闲暇之余，打算记录一些FPGA基础知识，方便后续自己的查阅复习，如果能帮助到其他同学那就更好了。本文主要介绍同步FIFO的实现原理，内容如有不妥之处，欢迎评论区指正，共同学习进步。</p>          </div><h1 id="fifo概述">1、FIFO概述</h1><p>FIFO（First In FirstOut）是一种先进先出的数据存储、缓存器。我们知道一般的存储器是用外部的读写地址来进行读写，而FIFO这种存储器的结构并不需要外部的读写地址而是通过内部的读写指针自动的加一操作来控制读写，这也就决定了FIFO只能顺序的读写数据。FIFO本质上是由 RAM 加读写控制逻辑构成的一种先进先出的数据缓冲器。</p><p>FIFO 有两种类型：同步 FIFO 和异步 FIFO。同步 FIFO使用同一个时钟信号来控制数据的读写，而异步 FIFO有两个时钟信号，一个用于读操作，另一个用于写操作。</p><p>同步 FIFO 的作用一般是做一个数据缓冲，也就是一个 buffer。异步 FIFO有两个较为重要的作用：一个是实现数据在不同时钟域进行传递，另一个作用就是实现不同数据宽度的数据接口。</p><h1 id="同步fifo的实现">2、同步FIFO的实现</h1><p>FIFO的设计原则是任何时候都不能向满FIFO中写入数据（写溢出），任何时候都不能从空FIFO中读取数据（读溢出）。FIFO设计的核心是空满判断。FIFO 设置读，写地址指针，FIFO 初始化的时候读指针和写指针都指向地址为 0 的位置，当往 FIFO里面每写一个数据，写地址指针自动加 1 指向下一个要写入的地址。当从 FIFO里面每读一个数据，读地址指针自动加 1指向下一个要读出的地址，最后通过比较读地址指针和写地址指针的大小来确定空满状态。</p><ul><li><p>写指针：总是指向下一个将要被写入的单元，复位时，指向第 1个单元（编号为 0）。</p></li><li><p>读指针：总是指向当前要被读出的数据，复位时，指向第 1个单元（编号为 0）。</p></li></ul><p>产生可靠的 FIFO 读写指针和生成 FIFO “空”/“满”状态标志是 FIFO设计的关键。</p><p>当读写指针相等时，表明 FIFO为空，这种情况发生在复位操作时，或者当读指针读出 FIFO中最后一个数据后，追赶上了写指针时，如下图所示<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[掰开揉碎讲 FIFO（同步FIFO和异步FIFO）](https://www.cnblogs.com/DoreenLiu/p/17348480.html)">[1]</span></a></sup>：</p><figure><img src="/img/同步fifo/image.gif" alt="读空" /><figcaption aria-hidden="true">读空</figcaption></figure><p>当读写指针再次相等时，表明 FIFO为满，这种情况发生在写指针转了一圈，折回来又追上了读指针，如下图所示<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[掰开揉碎讲 FIFO（同步FIFO和异步FIFO）](https://www.cnblogs.com/DoreenLiu/p/17348480.html)">[1]</span></a></sup>：</p><figure><img src="/img/同步fifo/image-1.gif" alt="写满" /><figcaption aria-hidden="true">写满</figcaption></figure><p>参考刀哥的思路，我们将有两种思路进行同步fifo的设计。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[同步FIFO的两种Verilog设计方法（计数器法、高位扩展法）](https://blog.csdn.net/wuzhikaidetb/article/details/121136040?ops_request_misc=%257B%2522request%255Fid%2522%253A%252227622c9b4e0ef88928f3ab4dfabed8fd%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=27622c9b4e0ef88928f3ab4dfabed8fd&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-121136040-null-null.nonecase&amp;utm_term=fifo&amp;spm=1018.2226.3001.4450)">[2]</span></a></sup></p><h2 id="计数器法实现同步fifo">2.1、计数器法实现同步FIFO</h2><p>构建一个计数器，该计数器(fifo_cnt)用于指示当前 FIFO中数据的个数：</p><ul><li><p>复位时，该计数器为 0，FIFO 中的数据个数为 0。</p></li><li><p>当读写使能信号均有效时，说明又读又写，计数器不变，FIFO中的数据个数无变化。</p></li><li><p>当写使能有效且 full = 0，则 fifo_cnt + 1；表示写操作且 FIFO未满时候，FIFO 中的数据增加了 1 。</p></li><li><p>当读使能有效且 empty = 0，则 fifo_cnt - 1;表示读操作且 FIFO未空时候，FIFO 中的数据减少了 1 。</p></li><li><p>fifo_cnt = 0 的时候，表示 FIFO 空，需要设置 empty = 1；fifo_cnt =fifo的深度 的时候，表示 FIFO 现在已经满，需要设置 full = 1。</p></li></ul><p>这种方法设计比较简单，但是需要的额外的计数器，就会产生额外的资源，而且当FIFO 比较大时，会降低 FIFO 最终可以达到的速度。</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">//读操作，更新读地址</span><span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rst_n<span class="token punctuation">)</span>rd_addr <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>empty <span class="token operator">&amp;&amp;</span> rd_en<span class="token punctuation">)</span><span class="token keyword">begin</span>rd_addr <span class="token operator">&lt;=</span> rd_addr <span class="token operator">+</span> <span class="token number">1'd1</span><span class="token punctuation">;</span>data_out <span class="token operator">&lt;=</span> fifo_buffer<span class="token punctuation">[</span>rd_addr<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">end</span><span class="token comment">//写操作,更新写地址</span><span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rst_n<span class="token punctuation">)</span>wr_addr <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>full <span class="token operator">&amp;&amp;</span> wr_en<span class="token punctuation">)</span><span class="token keyword">begin</span>wr_addr <span class="token operator">&lt;=</span> wr_addr <span class="token operator">+</span> <span class="token number">1'd1</span><span class="token punctuation">;</span>fifo_buffer<span class="token punctuation">[</span>wr_addr<span class="token punctuation">]</span><span class="token operator">&lt;=</span>data_in<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">end</span><span class="token comment">//更新计数器</span><span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rst_n<span class="token punctuation">)</span>fifo_cnt <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">begin</span><span class="token function">case</span><span class="token punctuation">(</span><span class="token operator">&#123;</span>wr_en<span class="token punctuation">,</span>rd_en<span class="token operator">&#125;</span><span class="token punctuation">)</span><span class="token number">2'b00</span><span class="token punctuation">:</span>fifo_cnt <span class="token operator">&lt;=</span> fifo_cnt<span class="token punctuation">;</span><span class="token comment">//不读不写</span><span class="token number">2'b01</span><span class="token punctuation">:</span>                               <span class="token comment">//仅仅读</span><span class="token function">if</span><span class="token punctuation">(</span>fifo_cnt <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>fifo_cnt <span class="token operator">&lt;=</span> fifo_cnt <span class="token operator">-</span> <span class="token number">1'b1</span><span class="token punctuation">;</span> <span class="token number">2'b10</span><span class="token punctuation">:</span>                                 <span class="token comment">//仅仅写</span><span class="token function">if</span><span class="token punctuation">(</span>fifo_cnt <span class="token operator">!=</span> DATA_DEPTH<span class="token punctuation">)</span>fifo_cnt <span class="token operator">&lt;=</span> fifo_cnt <span class="token operator">+</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>   <span class="token number">2'b11</span><span class="token punctuation">:</span>fifo_cnt <span class="token operator">&lt;=</span> fifo_cnt<span class="token punctuation">;</span>           <span class="token comment">//读写同时</span><span class="token keyword">default</span><span class="token punctuation">:</span><span class="token punctuation">;</span>                              <span class="token keyword">endcase</span><span class="token keyword">end</span><span class="token keyword">end</span><span class="token comment">//依据计数器状态更新指示信号</span><span class="token keyword">assign</span> full  <span class="token operator">=</span> <span class="token punctuation">(</span>fifo_cnt <span class="token operator">==</span> DATA_DEPTH<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1'b1</span> <span class="token punctuation">:</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token comment">//满信号</span><span class="token keyword">assign</span> empty <span class="token operator">=</span> <span class="token punctuation">(</span>fifo_cnt <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">?</span> <span class="token number">1'b1</span> <span class="token punctuation">:</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token comment">//空信号</span></code></pre></div></figure><p>仿真依次进行以下测试：基本单次读写测试、FIFO写满测试、FIFO读空测试、同时读写操作测试、边界条件测试</p><figure><img src="/img/同步fifo/image.png" alt="计数器法-同步FIFO-仿真" /><figcaption aria-hidden="true">计数器法-同步FIFO-仿真</figcaption></figure><h2 id="高位扩展法实现同步fifo">2.2、高位扩展法实现同步FIFO</h2><p>高位扩展法是一种更加高效的FIFO实现方式。它通过在读写指针上增加一个额外的高位作为指示位，避免使用独立的计数器。其原理如下：</p><ul><li><p>读写指针的宽度要比FIFO深度所需的地址位宽多1位</p></li><li><p>指针的低位用于寻址，高位用于判断FIFO的空满状态</p></li><li><p>当写指针与读指针相比，最高位不同而其他位相同时，说明写入数据已经超过一轮，此时FIFO已满。</p></li><li><p>当写指针与读指针的最高位和其他位都相同时，说明读指针已经追上写指针位置，此时FIFO为空。</p></li></ul><p>高位扩展法要求FIFO深度为2的N次幂，以确保地址自然溢出和空满条件正确性。若深度非2的N次幂，需引入复杂的手动控制逻辑，失去高位扩展法的简洁性和高效性。</p><p>高位扩展法取消了计数器，在原来的基础上更改了读写指针的更新逻辑，通过比较读写指针的高位和低位来判断FIFO的空满状态。</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">//当所有位相等时，读指针追到到了写指针，FIFO被读空</span><span class="token keyword">assign</span>empty <span class="token operator">=</span> <span class="token punctuation">(</span> wr_ptr <span class="token operator">==</span> rd_ptr <span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1'b1</span> <span class="token punctuation">:</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token comment">//当最高位不同但是其他位相等时，写指针超过读指针一圈，FIFO被写满</span><span class="token keyword">assign</span>full  <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>wr_ptr_msb <span class="token operator">!=</span> rd_ptr_msb <span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span> wr_ptr_true <span class="token operator">==</span> rd_ptr_true <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">?</span> <span class="token number">1'b1</span> <span class="token punctuation">:</span> <span class="token number">1'b0</span><span class="token punctuation">;</span></code></pre></div></figure><p>同样进行仿真测试：基本单次读写测试、FIFO写满测试、FIFO读空测试、同时读写操作测试、边界条件测试</p><figure><img src="/img/同步fifo/image1.png" alt="高位扩展法-同步FIFO-仿真" /><figcaption aria-hidden="true">高位扩展法-同步FIFO-仿真</figcaption></figure><h1 id="代码下载">3、代码下载</h1><p>博客中涉及到的代码均在我的<ahref="https://github.com/yao-jiangyu/MyBlogCode">GitHub仓库</a>中，欢迎大家下载学习。</p><h1 id="参考资料">4、参考资料</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><ahref="https://www.cnblogs.com/DoreenLiu/p/17348480.html">掰开揉碎讲FIFO（同步FIFO和异步FIFO）</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><ahref="https://blog.csdn.net/wuzhikaidetb/article/details/121136040?ops_request_misc=%257B%2522request%255Fid%2522%253A%252227622c9b4e0ef88928f3ab4dfabed8fd%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=27622c9b4e0ef88928f3ab4dfabed8fd&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-121136040-null-null.nonecase&amp;utm_term=fifo&amp;spm=1018.2226.3001.4450">同步FIFO的两种Verilog设计方法（计数器法、高位扩展法）</a><a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>FPGA基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>FIFO</tag>
      
      <tag>Verilog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDLBits刷题日记（四）</title>
    <link href="/HDLBits_four/"/>
    <url>/HDLBits_four/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>打算利用碎片化时间重温一遍Verilog语法，好记忆不如烂笔头，在此记录一下HDLBits刷题的过程，记录一些知识点，方便日后再次复习。</p>          </div><h1 id="verilog-language---vectors">1、Verilog Language - Vectors</h1><h2 id="problem-15-vector-concatenation-operator">Problem 15 : Vectorconcatenation operator</h2><p>片选操作符用于选择向量的一部分比特。而连接操作符 { a,b,c}，将较小的向量连接在一起，用于创建更大的向量。</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token operator">&#123;</span><span class="token number">3'b111</span><span class="token punctuation">,</span> <span class="token number">3'b000</span><span class="token operator">&#125;</span> <span class="token operator">=></span> <span class="token number">6'b111000</span><span class="token operator">&#123;</span><span class="token number">1'b1</span><span class="token punctuation">,</span> <span class="token number">1'b0</span><span class="token punctuation">,</span> <span class="token number">3'b101</span><span class="token operator">&#125;</span> <span class="token operator">=></span> <span class="token number">5'b10101</span><span class="token operator">&#123;</span><span class="token number">4'ha</span><span class="token punctuation">,</span> <span class="token number">4'd10</span><span class="token operator">&#125;</span> <span class="token operator">=></span> <span class="token number">8'b10101010</span>     <span class="token comment">// 4'ha and 4'd10 are both 4'b1010 in binary</span></code></pre></div></figure><p>连接操作符的基本语法使用 { } 将较小的向量括起来，每个 { }内的向量使用逗号作为间隔。</p><p>连接运算符中的向量务必需要标注位宽，不然综合器怎么能知道你的结果需要多宽的位宽。因此{ 1,2,3 } 这样的操作是非法的，并会产生一个 Error：unsized constants arenot allowed in concatenations.</p><p>连接运算符可用于赋值的左侧和右侧。</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> in<span class="token punctuation">;</span><span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> out<span class="token punctuation">;</span><span class="token keyword">assign</span> <span class="token operator">&#123;</span>out<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> out<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token operator">&#125;</span> <span class="token operator">=</span> in<span class="token punctuation">;</span>         <span class="token comment">// Swap two bytes. Right side and left side are both 16-bit vectors.</span><span class="token keyword">assign</span> out<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&#123;</span>in<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> in<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// This is the same thing.</span><span class="token keyword">assign</span> out <span class="token operator">=</span> <span class="token operator">&#123;</span>in<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> in<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span>       <span class="token comment">// This is different. The 16-bit vector on the right is extended to</span>                                        <span class="token comment">// match the 24-bit vector on the left, so out[23:16] are zero.</span>                                        <span class="token comment">// In the first two examples, out[23:16] are not assigned.</span><span class="token keyword">assign</span> <span class="token operator">&#123;</span>cout<span class="token punctuation">,</span>sum<span class="token operator">&#125;</span> <span class="token operator">=</span> a <span class="token operator">+</span> b <span class="token operator">+</span> cin<span class="token punctuation">;</span><span class="token comment">// 在表示全加器时，可以使用一句 assign 语句实现结果和进位的赋值。</span></code></pre></div></figure><p>Given several input vectors, concatenate them together then splitthem up into several output vectors. There are six 5-bit input vectors:a, b, c, d, e, and f, for a total of 30 bits of input. There are four8-bit output vectors: w, x, y, and z, for 32 bits of output. The outputshould be a concatenation of the input vectors followed by two 1bits:</p><p>给定几个输入向量，将它们连接在一起，然后将它们分成几个输出向量。有六个5 位输入向量：a、b、c、d、e 和 f，总共有 30 位输入。有四个 8位输出向量：w、x、y 和 z，总共有 32位输出。输出应该是输入向量的连接，后面跟着两个 1 位：</p><figure><img src="/img/HDLBits_four/Vector3.png"alt="Vector concatenation operator" /><figcaption aria-hidden="true">Vector concatenationoperator</figcaption></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> top_module <span class="token punctuation">(</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> e<span class="token punctuation">,</span> f<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> w<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//</span>    <span class="token comment">// assign &#123; ... &#125; = &#123; ... &#125;;</span>        <span class="token comment">// assign w = &#123;a,b[4:2]&#125;;</span>    <span class="token comment">// assign x = &#123;b[1:0],c,d[4]&#125;;</span>    <span class="token comment">// assign y = &#123;d[3:0],e[4:1]&#125;;</span>    <span class="token comment">// assign z = &#123;e[0],f,2'b11&#125;;</span>    <span class="token keyword">assign</span> <span class="token operator">&#123;</span>w<span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token operator">&#125;</span> <span class="token operator">=</span> <span class="token operator">&#123;</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">,</span>e<span class="token punctuation">,</span>f<span class="token punctuation">,</span><span class="token number">2'b11</span><span class="token operator">&#125;</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre></div></figure><h2 id="problem-16-vector-reversal-1">Problem 16 : Vector reversal1</h2><p>Given an 8-bit input vector [7:0], reverse its bit ordering.</p><p>给定一个 8 位输入向量 [7:0]，反转其位序。</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">top_module</span><span class="token punctuation">(</span>     <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> in<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> out <span class="token operator">=</span> <span class="token operator">&#123;</span>in<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>in<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>in<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>in<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>in<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span>in<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>in<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span>in<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// assign &#123;out[0],out[1],out[2],out[3],out[4],out[5],out[6],out[7]&#125; = in;</span><span class="token keyword">endmodule</span></code></pre></div></figure><p>假设输入为超级超级长的向量，比如 2048 bit这种，此时不在合适使用上面的方式了。</p><p>此时可以使用一个 for 循环或者使用 generate 语句来实现。</p><ul><li>for 循环</li></ul><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">top_module</span><span class="token punctuation">(</span>     <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> in<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">integer</span> i<span class="token punctuation">;</span>    <span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token comment">//Use integer for pure Verilog.</span>             out<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> in<span class="token punctuation">[</span><span class="token number">8</span><span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">endmodule</span></code></pre></div></figure><p>我们可以在创建一个组合逻辑 always块，在块中的组合逻辑将会按照一定的顺序运行。for循环描述了电路的行为，而不是电路的结构，因此，for 循环必须置于比如always 块这样的过程块中。（描述电路行为）</p><p>for循环中的“循环”指的是代码层面的循环，其实，电路是不存在循环这种的东西的，无论是信号而是门电路，都不存在循环一说。实际上，for循环表示的代码将被综合器解析，for循环将被分别解析为硬件电路。（不过在仿真中，确实按照循环处理）。</p><p>所以 for循环可以理解为代码循环的语法，减少编码量，但真正的硬件电路不存在循环。</p><p>Verilog 的语法需要提前定义 integer 变量，即整形。</p><ul><li>generate 语句</li></ul><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">top_module</span><span class="token punctuation">(</span>     <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> in<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">genvar</span> i<span class="token punctuation">;</span>    <span class="token keyword">generate</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token punctuation">:</span> gen_name            <span class="token keyword">assign</span> out<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> in<span class="token punctuation">[</span><span class="token number">7</span><span class="token operator">-</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">end</span>    <span class="token keyword">endgenerate</span><span class="token keyword">endmodule</span></code></pre></div></figure><p>虽然在 generate ，endgenerate 之间使用的仍然是 for循环，但生成块的概念和上面的 for 循环完全不同。</p><p>生成块可以例化 assign 语句，模块，信号和变量的声明以及 always initial这样的过程块。循环生成块是生成块中的一种类型，在综合过程中同样被综合器进行编译，这个过程可以看做综合过程中动态生成更多Verilog 代码的预处理过程。在上面的例子中，generate块在综合的过程中，综合了 8 句 assign 赋值语句。</p><p>总的来说，for循环强调了对电路的行为描述，在综合的过程中循环展开，而生成块则用于综合过程中，动态生成代码，两者有本质上的不同。</p><h2 id="problem-17-replication-operator">Problem 17 : Replicationoperator</h2><p>连接操作符允许我们将短小的向量连接在一起构成更宽的向量。很方便，但有的时候需要将多个重复的向量连接在一起，诸如assign a = {b,b,b,b,b,b};这样的操作仍然很繁琐。而重复操作符语法就可以在这种情况下允许你将一个向量重复多次，并将它们连接在一起，语法是这样：{num{vector}}，也就是{ 重复次数 { 向量 } }</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token operator">&#123;</span><span class="token number">5</span><span class="token operator">&#123;</span><span class="token number">1'b1</span><span class="token operator">&#125;&#125;</span>           <span class="token comment">// 5'b11111 (or 5'd31 or 5'h1f)</span><span class="token operator">&#123;</span><span class="token number">2</span><span class="token operator">&#123;</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token operator">&#125;&#125;</span>          <span class="token comment">// The same as &#123;a,b,c,a,b,c&#125;</span><span class="token operator">&#123;</span><span class="token number">3'd5</span><span class="token punctuation">,</span> <span class="token operator">&#123;</span><span class="token number">2</span><span class="token operator">&#123;</span><span class="token number">3'd6</span><span class="token operator">&#125;&#125;&#125;</span>   <span class="token comment">// 9'b101_110_110. It's a concatenation of 101 with</span>                    <span class="token comment">// the second vector, which is two copies of 3'b110.</span></code></pre></div></figure><p>One common place to see a replication operator is when sign-extendinga smaller number to a larger one, while preserving its signed value.This is done by replicating the sign bit (the most significant bit) ofthe smaller number to the left. For example, sign-extending 4'b0101 (5)to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3)to 8 bits results in 8'b11111101 (-3).</p><p>Build a circuit that sign-extends an 8-bit number to 32 bits. Thisrequires a concatenation of 24 copies of the sign bit (i.e., replicatebit[7] 24 times) followed by the 8-bit number itself.</p><p>重复操作符的一个常见用法是将较小的数字符号扩展到较大的数字，同时保留其符号值。这是通过复制较小数字的符号位（最高有效位）来实现的。例如，将4'b0101（5）符号扩展到 8 位，结果为 8'b00000101（5），而将4'b1101（-3）符号扩展到 8 位，结果为 8'b11111101（-3）。</p><p>构建一个电路，将 8 位数字符号扩展到 32 位。这需要将符号位（即，复制bit[7] 24 次）连接在一起，然后是 8 位数字本身。</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">top_module</span><span class="token punctuation">(</span>     <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> in<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> out <span class="token operator">=</span> <span class="token operator">&#123;</span> <span class="token operator">&#123;</span><span class="token number">24</span><span class="token operator">&#123;</span>in<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token operator">&#125;&#125;</span><span class="token punctuation">,</span> in <span class="token operator">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 24 copies of in[7] followed by in itself.</span><span class="token keyword">endmodule</span></code></pre></div></figure><h2 id="problem-18-more-replication">Problem 18 : More Replication</h2><p>Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwiseone-bit comparisons in the 25-bit output vector. The output should be 1if the two bits being compared are equal.</p><p>给定 5 个 1 bit 信号（a、b、c、d 和 e），将 5 个 1bit信号分别组成下图中两个 25 bit 信号，输出向量为这两个 25 bit向量的逐位操作的结果。如果被比较的两个比特相等，则输出为 1。</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog">out<span class="token punctuation">[</span><span class="token number">24</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">~</span>a <span class="token operator">^</span> a<span class="token punctuation">;</span>   <span class="token comment">// a == a, so out[24] is always 1.</span>out<span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">~</span>a <span class="token operator">^</span> b<span class="token punctuation">;</span>out<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">~</span>a <span class="token operator">^</span> c<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>out<span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">~</span>e <span class="token operator">^</span> d<span class="token punctuation">;</span>out<span class="token punctuation">[</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">~</span>e <span class="token operator">^</span> e<span class="token punctuation">;</span></code></pre></div></figure><figure><img src="/img/HDLBits_four/Vector5.png" alt="More Replication" /><figcaption aria-hidden="true">More Replication</figcaption></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">top_module</span><span class="token punctuation">(</span>     <span class="token keyword">input</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> e<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">24</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// The output is XNOR of two vectors created by </span>    <span class="token comment">// concatenating and replicating the five inputs.</span>    <span class="token comment">// assign out = ~&#123; ... &#125; ^ &#123; ... &#125;;</span>    <span class="token keyword">assign</span> out <span class="token operator">=</span> <span class="token operator">~&#123;&#123;</span><span class="token number">5</span><span class="token operator">&#123;</span>a<span class="token operator">&#125;&#125;</span><span class="token punctuation">,</span><span class="token operator">&#123;</span><span class="token number">5</span><span class="token operator">&#123;</span>b<span class="token operator">&#125;&#125;</span><span class="token punctuation">,</span><span class="token operator">&#123;</span><span class="token number">5</span><span class="token operator">&#123;</span>c<span class="token operator">&#125;&#125;</span><span class="token punctuation">,</span><span class="token operator">&#123;</span><span class="token number">5</span><span class="token operator">&#123;</span>d<span class="token operator">&#125;&#125;</span><span class="token punctuation">,</span><span class="token operator">&#123;</span><span class="token number">5</span><span class="token operator">&#123;</span>e<span class="token operator">&#125;&#125;&#125;</span> <span class="token operator">^</span> <span class="token operator">&#123;&#123;</span><span class="token number">5</span><span class="token operator">&#123;</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">,</span>e<span class="token operator">&#125;&#125;&#125;</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>HDLBits刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>HDLBits</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDLBits刷题日记（三）</title>
    <link href="/HDLBits_three/"/>
    <url>/HDLBits_three/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>打算利用碎片化时间重温一遍Verilog语法，好记性不如烂笔头，在此记录一下HDLBits刷题的过程，记录一些知识点，方便日后再次复习。</p>          </div><h1 id="verilog-language---vectors">1、Verilog Language - Vectors</h1><h2 id="problem-10-vectors">Problem 10 : Vectors</h2><p>向量是一组 wire信号的集合，通过赋予这一组信号的集合一个名称，以便于访问其中的 wire信号</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> w <span class="token punctuation">;</span> <span class="token comment">// 声明了一个 8 bit 位宽的信号，向量名为 w，等价于 8 个 1bit 位宽的 wire 信号。</span></code></pre></div></figure><p>请注意声明向量时，位宽位于向量名之前。但在片选向量中某个 bit时，使用的语法同 C 语言数组中取出某个数的语法相同。</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">99</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> my_vector<span class="token punctuation">;</span>      <span class="token comment">// Declare a 100-element vector </span><span class="token keyword">assign</span> out <span class="token operator">=</span> my_vector<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Part-select one bit out of the vector </span></code></pre></div></figure><p>在同时声明多个向量时，位宽对于声明的多个向量都是起作用的，比如：</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span> <span class="token comment">// Declares three 8-bit vectors</span></code></pre></div></figure><p>Build a circuit that has one 3-bit input, then outputs the samevector, and also splits it into three separate 1-bit outputs.</p><p>构建一个电路，有一个 3位输入，然后输出相同的向量，并将其分成三个单独的 1 位输出。</p><figure><img src="/img/HDLBits_three/Vector0.png" alt="Vector0" /><figcaption aria-hidden="true">Vector0</figcaption></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">top_module</span><span class="token punctuation">(</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> vec<span class="token punctuation">,</span>     <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> outv<span class="token punctuation">,</span>    <span class="token keyword">output</span> o2<span class="token punctuation">,</span>    <span class="token keyword">output</span> o1<span class="token punctuation">,</span>    <span class="token keyword">output</span> o0<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> outv <span class="token operator">=</span> vec<span class="token punctuation">;</span>    <span class="token comment">// This is ok too: assign &#123;o2, o1, o0&#125; = vec;</span>    <span class="token keyword">assign</span> o0 <span class="token operator">=</span> vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> o1 <span class="token operator">=</span> vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> o2 <span class="token operator">=</span> vec<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre></div></figure><p>如果想要片选多个 bit，那么可以通过如下操作实现:</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> w <span class="token operator">=</span> vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> </code></pre></div></figure><h2 id="problem-11-vectors-in-more-detail">Problem 11 : Vectors in moredetail</h2><p>向量的声明规则如下：</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">type</span> <span class="token punctuation">[</span>upper<span class="token punctuation">:</span>lower<span class="token punctuation">]</span> vector_name<span class="token punctuation">;</span></code></pre></div></figure><p>其中 type 指定了向量的类型，一般为 wire 或者 reg 型。关于 reg型，会在后续介绍中引入。如果向量为模块的输入输出端口，那么可以在 type中添加 input/output 定义。</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> w<span class="token punctuation">;</span>         <span class="token comment">// 8-bit wire</span><span class="token keyword">reg</span>  <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span> x<span class="token punctuation">;</span>         <span class="token comment">// 4-bit reg</span><span class="token keyword">output</span> <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> y<span class="token punctuation">;</span>   <span class="token comment">// 1-bit reg  output port (但仍然是一个向量)</span><span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> z<span class="token punctuation">;</span>  <span class="token comment">// 6-bit wire input (在位宽中使用负数作为 index 是可以的，代表倒数第二位)</span><span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">;</span>       <span class="token comment">// 4-bit output wire. wire 为默认定义，在没有显式声明的情况下</span><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">]</span> b<span class="token punctuation">;</span>         <span class="token comment">// 8-bit wire b[0]是这个向量的 最高位 MSB（most-significant bit）</span></code></pre></div></figure><p>声明为 [3:0] w 的向量，LSB 是 w[0]，如果声明为 [0:3] w,那么 w[3] 是LSB 。LSB 指的是二进制数中权值最低的一位。</p><p>在 Verilog 语法中，可以将向量声明为 [3:0],这种语法最为常见，但也可以将向量声明为[0:3]。这都是可以的，但必须在声明和使用时保持一致。如果声明为 wire [3:0]w ，但使用 w[0:3]赋值，这是不允许的，保持前后如一的比特顺序是很重要的一点。</p><p>信号变量有两种声明方式，一是使用 wire 或者 assign语句进行显示声明和定义，二是综合器的隐式声明和定义。变量隐式声明的危害在于，当你将一个未定义声明的信号连接到模块的输入输出端口时，综合器会“热心”地帮助你声明这个信号，但它只会将其声明为1 bit wire 型信号。</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> c<span class="token punctuation">;</span>   <span class="token comment">// Two vectors</span><span class="token keyword">assign</span> a <span class="token operator">=</span> <span class="token number">3'b101</span><span class="token punctuation">;</span>  <span class="token comment">// a = 101</span><span class="token keyword">assign</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>       <span class="token comment">// b =   1  implicitly-created wire</span><span class="token keyword">assign</span> c <span class="token operator">=</span> b<span class="token punctuation">;</span>       <span class="token comment">// c = 001  &lt;-- bug</span>my_module i1 <span class="token punctuation">(</span>d<span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// d and e are implicitly one-bit wide if not declared.</span>                    <span class="token comment">// This could be a bug if the port was intended to be a vector.</span></code></pre></div></figure><p>通过添加 `default_nettype none宏定义会关闭隐式声明功能，那么这样一来，使用未声明的变量就会变成一个Error 而不再只是 Warning。</p><p>unpacked 和 packed数组：在声明向量时，一般向量的位宽写在向量名之前。位宽定义了向量的packed维度，该向量中每位信号都被视作一个块进行操作（在仿真中，硬件中有所不同）。unpacked维度定义在向量名之后，通常用来定义向量数组长度。</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> mem <span class="token punctuation">[</span><span class="token number">255</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// 256 unpacked elements, each of which is a 8-bit packed vector of reg.</span><span class="token keyword">reg</span> mem2 <span class="token punctuation">[</span><span class="token number">28</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">// 29 unpacked elements, each of which is a 1-bit reg.</span></code></pre></div></figure><p>获取向量元素，也称片选：</p><p>通过向量名可以获得整个向量，在下方的 assign 语句中，向量名 a代表了向量中的所有比特为信号。</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">;</span><span class="token keyword">assign</span> w <span class="token operator">=</span> a<span class="token punctuation">;</span> </code></pre></div></figure><p>在 assign赋值操作中，如果等号左右两侧信号的位宽不同，那么就会进行截断或者补零操作。左侧信号位宽大于右侧信号位宽，右值的低位赋予左值对应的低位，左值高位的部分赋零。左侧信号位宽小于右侧信号位宽，右值的低位赋予左值对应的低位，右值高位的部分直接被截断。即保留右值的低位。</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog">w<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>      <span class="token comment">// Only the lower 4 bits of w</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token comment">// The lowest bit of x</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span>      <span class="token comment">// ...also the lowest bit of x</span>z<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span>    <span class="token comment">// Z 最低两位</span>b<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>      <span class="token comment">// 如果 b 在声明时 声明为 wire [0:3] b;则不能使用 b [3:0]进行选择</span>b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>      <span class="token comment">// b的高四位.</span><span class="token keyword">assign</span> w<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 将 b 的高位赋予 w 的低位 w[3]=b[0], w[2]=b[1], etc.</span></code></pre></div></figure><p>Build a combinational circuit that splits an input half-word (16bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.</p><p>构建一个组合电路，将输入的半字（16 位，[15:0]）分为低位 [7:0] 和高位[15:8] 字节。</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`default_nettype</span> none     <span class="token comment">// Disable implicit nets. Reduces some types of bugs.</span><span class="token keyword">module</span> <span class="token function">top_module</span><span class="token punctuation">(</span>     <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> in<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> out_hi<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> out_lo <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> out_hi <span class="token operator">=</span> in<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> out_lo <span class="token operator">=</span> in<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre></div></figure><h2 id="problem-12-vector-part-select">Problem 12 : Vector partselect</h2><p>A 32-bit vector can be viewed as containing 4 bytes (bits [31:24],[23:16], etc.). Build a circuit that will reverse the byte ordering ofthe 4-byte word.</p><p>一个 32 位向量可以看作包含 4 个字节（位 [31:24], [23:16],etc.）。构建一个电路，将 4 字节的字节顺序反转。</p><p>AaaaaaaaBbbbbbbbCcccccccDddddddd =&gt;DdddddddCcccccccBbbbbbbbAaaaaaaa</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">top_module</span><span class="token punctuation">(</span>     <span class="token keyword">input</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> in<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> out <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> out<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">24</span><span class="token punctuation">]</span> <span class="token operator">=</span> in<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> out<span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">]</span> <span class="token operator">=</span> in<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> out<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> in<span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> out<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> in<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//或者使用&#123;&#125;拼接符</span>    <span class="token comment">// assign out = &#123;in[7:0], in[15:8], in[23:16], in[31:24]&#125;;</span><span class="token keyword">endmodule</span></code></pre></div></figure><h2 id="problem-13-bitwise-operators">Problem 13 : Bitwiseoperators</h2><p>Build a circuit that has two 3-bit inputs that computes thebitwise-OR of the two vectors, the logical-OR of the two vectors, andthe inverse (NOT) of both vectors. Place the inverse of b in the upperhalf of out_not (i.e., bits [5:3]), and the inverse of a in the lowerhalf.</p><p>构建一个电路，有两个 3位输入，计算两个向量的按位或，两个向量的逻辑或，以及两个向量的逆（NOT）。将b 的逆放在 out_not 的上半部分（即，位 [5:3]），将 a的逆放在下半部分。</p><figure><img src="/img/HDLBits_three/Vectorgates.png" alt="Vectorgates" /><figcaption aria-hidden="true">Vectorgates</figcaption></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">top_module</span><span class="token punctuation">(</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> out_or_bitwise<span class="token punctuation">,</span>    <span class="token keyword">output</span> out_or_logical<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> out_not<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> out_or_bitwise <span class="token operator">=</span> a <span class="token operator">|</span> b<span class="token punctuation">;</span>    <span class="token keyword">assign</span> out_or_logical <span class="token operator">=</span> a <span class="token operator">||</span> b<span class="token punctuation">;</span>    <span class="token keyword">assign</span> out_not <span class="token operator">=</span> <span class="token operator">&#123;~</span>b<span class="token punctuation">,</span> <span class="token operator">~</span>a<span class="token operator">&#125;</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre></div></figure><h2 id="problem-14-four-input-gates">Problem 14 : Four-input gates</h2><p>Build a combinational circuit with four inputs, in[3:0]. There are 3outputs:</p><p>out_and: output of a 4-input AND gate. out_or: output of a 4-input ORgate.out_xor: output of a 4-input XOR gate</p><p>构建一个具有四个输入 in[3:0] 的组合电路。有 3 个输出：</p><p>out_and：4 输入 AND 门的输出。out_or：4 输入 OR 门的输出。out_xor：4输入 XOR 门的输出。</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">top_module</span><span class="token punctuation">(</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> in<span class="token punctuation">,</span>    <span class="token keyword">output</span> out_and<span class="token punctuation">,</span>    <span class="token keyword">output</span> out_or<span class="token punctuation">,</span>    <span class="token keyword">output</span> out_xor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> out_and <span class="token operator">=</span> <span class="token operator">&amp;</span>in<span class="token punctuation">;</span>    <span class="token keyword">assign</span> out_or <span class="token operator">=</span> <span class="token operator">|</span>in<span class="token punctuation">;</span>    <span class="token keyword">assign</span> out_xor <span class="token operator">=</span> <span class="token operator">^</span>in<span class="token punctuation">;</span>    <span class="token comment">// 繁琐点的写法</span>    <span class="token comment">// assign out_and = in[3] &amp; in[2] &amp; in[1] &amp; in[0]; </span><span class="token keyword">endmodule</span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>HDLBits刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>HDLBits</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GTY高速收发器（一）：基本架构和时钟架构</title>
    <link href="/GTY%E9%AB%98%E9%80%9F%E6%94%B6%E5%8F%91%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/GTY%E9%AB%98%E9%80%9F%E6%94%B6%E5%8F%91%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>最近在学习高速收发器相关内容，本系列将结合Xilinx官方手册UG578及个人理解，对于GT收发器的一些主要内容进行整理和记录。本文主要介绍GTY的基本架构和时钟架构。</p>          </div><h1 id="gty简介">1. GTY简介</h1><p>通过<ahref="https://docs.amd.com/v/u/en-US/ds890-ultrascale-overview">DS890</a>手册可以查询到我们手头的芯片，拥有76个GTY收发器，无GTM收发器，这个需要更高级别的芯片才会有，如下图所示：</p><figure><img src="/img/GTY高速收发器（一）/image-2.png" alt="图1 GT资源图" /><figcaption aria-hidden="true">图1 GT资源图</figcaption></figure><p>UltraScale 架构中的 GTY 收发器是高能效的收发器，在 UltraScale FPGA中支持 500 Mb/s 到 30.5 Gb/s 的线速率，在 UltraScale+ FPGA 中则支持到<strong>32.75 Gb/s</strong> 的线速率。</p><p>4个<code>GTYE3/4_CHANNEL</code> 和 1个<code>GTYE3/4_COMMON</code>形成一个 Quad，如下图所示。<strong>GTY 收发器原语在 UltraScale FPGA中称为 GTYE3_COMMON 和 GTYE3_CHANNEL，在 UltraScale+ FPGA 中称为GTYE4_COMMON 和 GTYE4_CHANNEL。</strong></p><figure><img src="/img/GTY高速收发器（一）/image.png"alt="图2 GTY收发器Quad配置" /><figcaption aria-hidden="true">图2 GTY收发器Quad配置</figcaption></figure><ul><li><p><strong>GTYE3/4_COMMON原语包含两个LC谐振回路PLL（QPLL0和QPLL1）。</strong>仅当应用中需要使用该PLL时，才需要实例化GTYE3/4_COMMON 原语。QPLL 中的 Q 表示 Quad，表示这个 PLL 是为 Quad 中的4 个通道共享的。QPLL 用于为 Quad 中的所有通道提供时钟。</p></li><li><p><strong>GTYE3/4_CHANNEL 原语由 ChannelPLL（CPLL）、发射端和接收端组成。</strong>之所以叫做 ChannelPLL，是因为它是一个独立的 PLL，用于为每个通道提供时钟。每个GTYE3/4_CHANNEL 原语都有一个独立的 CPLL。</p></li><li><p><strong>一个 GTYE4_CHANNEL 就是我们常说的一个 GTTransceiver，</strong>一个 Quad 就是四个 GT Transceiver。在一个 Quad中，四个 GT Transceiver 共享一个 GTY_COMMON，也就是共享时钟。</p></li></ul><p>GT收发器的TX发送端和RX接收端功能独立，且均由<code>PMA（Physical Media Attachment，物理媒介适配层）</code> 和<code>PCS（Physical Coding Sublayer，物理编码子层）</code>两个子层组成，如下图所示：</p><figure><img src="/img/GTY高速收发器（一）/image-1.png"alt="图3 GTYE3/4_CHANNEL原始拓扑" /><figcaption aria-hidden="true">图3 GTYE3/4_CHANNEL原始拓扑</figcaption></figure><div class="note note-info">            <ul><li><p><strong>PMA子层内部集成了高速串并转换、预加重、接收均衡、时钟发生器及时钟恢复等电路（模拟电路部分）。</strong>SERDES是一个串并转换器，负责FPGA内部的并行数据与GTY接口串行数据之间的转换。预加重技术是针对典型物理连接系统中高频部分的补偿，在发送端加一个高通滤波器，放大高频成分，提高信号质量。预加重只在必要情况下使用，因为预加重会导致功耗和EMC辐射的增加。接收均衡主要用于补偿由频率不同而引起的阻抗/衰减差异。时钟发生器及时钟恢复电路在发送端将时钟与数据绑定发送，在接收端对接收到的数据流恢复时钟，从而避免了在高速传输条件下时钟与数据分开传输所带来的时钟抖动等问题。</p></li><li><p><strong>PCS子层内部集成了8b/10b编/解码、弹性缓冲区、通道绑定和时钟修正等专用电路模块。</strong>8b/10b编码可以避免数据流中出现连续的‘0'或‘1'的情况，避免数据传输的不平衡。利用通道绑定通过在发送数据流中加入K码字符，将多个物理上独立的GTY通道绑定成一个时序逻辑上同步的并行通道，通过增加GTY通道数可以提高接口传输的吞吐率。弹性缓冲区解决恢复时钟与本地时钟的不一致问题，并通过对缓存区中的K码匹配对齐实现通道绑定功能。</p></li><li><p><strong>Transmitter的数据流大致为：</strong>FPGA用户逻辑的数据，进入FPGATX接口，进入PCS，再经过PMA，转换为高速串行数据输出。<strong>Receiver的数据流大致为：</strong>数据由PMA部分接收，转换为并行数据进入PCS，再经过RX接口输出给FPGA用户逻辑处理。</p></li></ul>          </div><p>关于 PMA 和 PCS 内部的细节，在后续的文章会逐步深入。</p><h1 id="gty的时钟架构">2. GTY的时钟架构</h1><p>如下图所示，差分时钟进入FPGA之后，先经过 IBUFDS_GTE3/4转换为单端时钟，<strong>然后作为 QPLL 或者 CPLL 的时钟输入，QPLL 或者CPLL 的输出时钟作为发送和接收部分的时钟信号。</strong></p><figure><img src="/img/GTY高速收发器（一）/image-3.png" alt="图4 四通道配置" /><figcaption aria-hidden="true">图4 四通道配置</figcaption></figure><p>当参考时钟来自 GTYE3/4_COMMON 的 QPLL 时，必须实例化 GTYE3/4_COMMON原语。又每个通道包含一个通道锁相环( Channel PLL，CPLL)，因此，参考时钟可以直接连接到 GTYE3/4_CHANNEL 原语，此时不需要实例化GTYE3/4_COMMON 原语。</p><h2 id="参考时钟输入输出结构">2.1 参考时钟输入/输出结构</h2><p>GTY收发器中的参考时钟结构支持两种操作模式：输入模式和输出模式。<strong>在输入工作模式下，</strong>在专用参考时钟I/O 引脚上提供时钟，用于驱动 Quad 或 ChannelPLLs。<strong>在输出工作模式下，</strong>来自于同一 Quad内四个通道中任意一个恢复时钟 (RXRECCLKOUT) 都可以路由到专用参考时钟 I/O引脚。然后，此输出时钟可用作不同位置的参考时钟输入。运行过程中无法改变操作模式。</p><h3 id="参考时钟输入结构">2.1.1 参考时钟输入结构</h3><figure><img src="/img/GTY高速收发器（一）/image-4.png"alt="图5 参考时钟输入结构" /><figcaption aria-hidden="true">图5 参考时钟输入结构</figcaption></figure><h3 id="参考时钟输出结构">2.1.2 参考时钟输出结构</h3><p>参考时钟输出模式可通过两个软件原语之一实现：OBUFDS_GTE3/4_ADV 和OBUFDS_GTE3/4。原语的选择取决于具体的应用。当 RXRECCLKOUT始终来自同一通道时，请使用 OBUFDS_GTE3/4。如果提供 RXRECCLKOUT的通道在运行时可能会发生变化，请使用 OBUFDS_GTE3/4_ADV。使用OBUFDS_GTE3/4_ADV 原语时，必须实例 GTHE3/4_COMMON 原语。使用OBUFDS_GTE3/4 原语时，不需要实例化 GTHE3/4_COMMON。</p><figure><img src="/img/GTY高速收发器（一）/image-5.png"alt="图6 参考时钟输出使用模型OBUFDS_GTE3/4" /><figcaption aria-hidden="true">图6参考时钟输出使用模型OBUFDS_GTE3/4</figcaption></figure><figure><img src="/img/GTY高速收发器（一）/image-6.png"alt="图7 参考时钟输出使用模型OBUFDS_GTE3/4_ADV" /><figcaption aria-hidden="true">图7参考时钟输出使用模型OBUFDS_GTE3/4_ADV</figcaption></figure><p>GTHE3/4_COMMON 上的端口 RXRECCLK0_SEL 和 RXRECCLK1_SEL控制多路复用器，该多路复用器从 Quad 中的四个不同通道中选择RXRECCLKOUT。</p><p>参考时钟有输入输出两种模式，区别在于输入模式参考的时钟源来自于外部的专用参考时钟引脚，输出模式下参考时钟通过从Quad 中的 Channel 中恢复出来的 RXRECCLKOUT 路由而来。</p><h2 id="参考时钟方案选择">2.2 参考时钟方案选择</h2><p><strong>从架构上看，Quad（Q）包含四个 GTHE3/4_CHANNEL 原语、一个GTHE3/4_COMMON原语、两个专用外部参考时钟引脚对和专用参考时钟路由。</strong>每个收发器使用中必须实例化GTHE3/4_CHANNEL 原语。如果需要高性能 QPLL，还必须实例化 GTHE3/4_COMMON原语。通常，Quad（Q(n)）的参考时钟可以通过 GTNORTHREFCLK从最多下方两个位置的 Quad（Q(n–1) 或 Q(n-2)）获取，或通过 GTSOUTHREFCLK从最多上方两个的 Quad（Q(n+1) 或 Q(n+2)）获取。<strong>（即当前 Quad的参考时钟可以通过南北不超过2个 Quad区域的参考时钟路由而来）。</strong></p><p>Quad 中的每个 GTY 收发器通道都有六个可用的时钟输入：</p><p>（1）两个本地参考时钟引脚对：GTREFCLK0 或 GTREFCLK1</p><p>（2）上方 Quad 的两个参考时钟引脚对：GTSOUTHREFCLK0 或GTSOUTHREFCLK1</p><p>（3）下方 Quad 的两个参考时钟引脚对：GTNORTHREFCLK0 或GTNORTHREFCLK1</p><p>单个 GTHE3/4_COMMON 原语内的参考时钟多路复用器结构如下图所示：</p><figure><img src="/img/GTY高速收发器（一）/image-7.png"alt="图8 QPLL参考时钟选择复用器" /><figcaption aria-hidden="true">图8 QPLL参考时钟选择复用器</figcaption></figure><p>单个 GTHE3/4_CHANNEL 原语内的参考时钟多路复用器结构如下图所示：</p><figure><img src="/img/GTY高速收发器（一）/image-8.png"alt="图9 CPLL参考时钟选择复用器" /><figcaption aria-hidden="true">图9 CPLL参考时钟选择复用器</figcaption></figure><h3 id="单个外部参考钟使用模型">2.2.1 单个外部参考钟使用模型</h3><p>下图显示了单个外部参考时钟连接到单个 Quad 内的多个收发器。</p><figure><img src="/img/GTY高速收发器（一）/image-9.png"alt="图10 单个外部参考时钟连接到单个QUAD内的多个收发器" /><figcaption aria-hidden="true">图10单个外部参考时钟连接到单个QUAD内的多个收发器</figcaption></figure><p>下图展示了单个外部参考时钟连接到多个 Quad 内的多个收发器。</p><figure><img src="/img/GTY高速收发器（一）/image-10.png"alt="图11 单个外部参考时钟连接到多个Quad内的多个收发器" /><figcaption aria-hidden="true">图11单个外部参考时钟连接到多个Quad内的多个收发器</figcaption></figure><p>共享参考时钟时必须遵守以下规则，以确保满足高速设计的抖动裕度：</p><ul><li><p>源 Quad 上方的 Quad 数量不得超过两个。</p></li><li><p>源 Quad 下方的 Quad 数量不得超过两个。</p></li><li><p>外部时钟引脚对 (MGTREFCLKN/MGTREFCLKP) 作为源的 Quad总数不得超过五个 (或者说作为源的收发器不能超过20个)。</p></li></ul><h3 id="多个外部参考时钟使用模型">2.2.2 多个外部参考时钟使用模型</h3><p>下图展示了同一 Quad 中多个 GTY 收发器使用多个参考时钟。</p><figure><img src="/img/GTY高速收发器（一）/image-11.png"alt="图12 在单个QUAD中具有多个参考时钟的多个GTY收发器" /><figcaption aria-hidden="true">图12在单个QUAD中具有多个参考时钟的多个GTY收发器</figcaption></figure><p>图13和图14给出了属于一个 Quad 的收发器如何使用 GTNORTHREFCLK 和GTSOUTHREFCLK 端口从另一个 Quad 访问专用参考时钟的例子。在每个 GTY收发器 PLL 有多个参考时钟选项的情况下，用户设计需要根据设计需求设置QPLL0/1REFCLKSEL[2:0] 和 CPLLREFCLKSEL[2:0]。</p><figure><img src="/img/GTY高速收发器（一）/image-12.png"alt="图13 多个GTY收发器使用CPLLs，在不同的Quads中具有多个参考时钟" /><figcaption aria-hidden="true">图13多个GTY收发器使用CPLLs，在不同的Quads中具有多个参考时钟</figcaption></figure><figure><img src="/img/GTY高速收发器（一）/image-13.png"alt="图14 多个GTY收发器使用QPLLs，在不同的Quads中具有多个参考时钟" /><figcaption aria-hidden="true">图14多个GTY收发器使用QPLLs，在不同的Quads中具有多个参考时钟</figcaption></figure><div class="note note-info">            <p>上面的 Quad 位于下面 Quad 的北面，那么下面的 Quad 可以将北面 Quad的差分时钟通过 GTSOUTHREFCLK0、GTSOUTHREFCLK1 端口作为自己的 QPLL的时钟输入。</p><p>同样的道理下面的 Quad 位于上面 Quad 的南面，上面 Quad 可以通过GTNORTHREFCLK0、GTNORTHREFCLK1 把下面 Quad 的差分时钟作为自己的 QPLL的输入时钟。</p><p>注意这里的 NORTH 和 SOUTH 不是表示时钟来自 NORTH 还是SOUTH，而是表示自己 Quad 所在的位置。举个例子，Quad0、Quad1 和 Quad2从北到南依次排布，Quad1 位于正中，那么从 Quad0也就是北边来的时钟就要接到 GTSOUTHREFCLK0 和 GTSOUTHREFCLK1这两个端口，因为 Quad1 相对于 Quad0 它处于南边；同样的从 Quad2也就是南边来的时钟就要接到 GTNORTHREFCLK0 和 GTNORTHREFCLK1这两个端口，因为 Quad1 相对于 Quad2 它处于北边。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>高速收发器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>GTY</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDLBits刷题日记（二）</title>
    <link href="/HDLBits_two/"/>
    <url>/HDLBits_two/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>打算利用碎片化时间重温一遍Verilog语法，好记性不如烂笔头，在此记录一下HDLBits刷题的过程，记录一些知识点，方便日后再次复习。</p>          </div><h1 id="verilog-language---basics">1、Verilog Language - Basics</h1><h2 id="problem-4-notgate">Problem 4 : Notgate</h2><p>Create a module that implements a NOT gate.</p><p>创建一个模块，实现一个非门。</p><figure><img src="/img/HDLBits_two/Notgate.png" alt="Notgate" /><figcaption aria-hidden="true">Notgate</figcaption></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> top_module <span class="token punctuation">(</span>    <span class="token keyword">input</span> in<span class="token punctuation">,</span>    <span class="token keyword">output</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> out <span class="token operator">=</span> <span class="token operator">~</span> in<span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre></div></figure><div class="note note-success">            <ul><li><p><code>~</code> 是逐位取反。</p></li><li><p><code>！</code> 是逻辑取反。</p></li></ul>          </div><h2 id="problem-5-andgate">Problem 5 : Andgate</h2><p>Create a module that implements an AND gate.</p><p>创建一个模块，实现一个与门。</p><figure><img src="/img/HDLBits_two/Andgate.png" alt="Andgate" /><figcaption aria-hidden="true">Andgate</figcaption></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">top_module</span><span class="token punctuation">(</span>    <span class="token keyword">input</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> b<span class="token punctuation">,</span>    <span class="token keyword">output</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> out <span class="token operator">=</span> a <span class="token operator">&amp;</span> b<span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre></div></figure><div class="note note-success">            <ul><li><p><code>&amp;</code> 是逐位与。</p></li><li><p><code>&amp;&amp;</code> 是逻辑与。</p></li></ul>          </div><h2 id="problem-6-norgate">Problem 6 : Norgate</h2><p>Create a module that implements a NOR gate. A NOR gate is an OR gatewith its output inverted. A NOR function needs two operators whenwritten in Verilog.</p><p>创建一个模块，实现一个或非门。一个或非门是一个或门，其输出被反转。在Verilog中，一个或非函数需要两个运算符。</p><figure><img src="/img/HDLBits_two/Norgate.png" alt="Norgate" /><figcaption aria-hidden="true">Norgate</figcaption></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">top_module</span><span class="token punctuation">(</span>    <span class="token keyword">input</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> b<span class="token punctuation">,</span>    <span class="token keyword">output</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> out <span class="token operator">=</span> <span class="token operator">~</span><span class="token punctuation">(</span>a <span class="token operator">|</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre></div></figure><div class="note note-success">            <ul><li><p><code>|</code> 是逐位或。</p></li><li><p><code>||</code> 是逻辑或。</p></li><li><p>注意括号的由来，因为 ~ 非逻辑的优先级大于 | 或。</p></li></ul>          </div><h2 id="problem-7-xnorgate">Problem 7 : Xnorgate</h2><p>Create a module that implements an XNOR gate.</p><p>创建一个模块，实现一个同或门（异或非门）。</p><figure><img src="/img/HDLBits_two/Xnorgate.png" alt="Xnorgate" /><figcaption aria-hidden="true">Xnorgate</figcaption></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">top_module</span><span class="token punctuation">(</span>    <span class="token keyword">input</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> b<span class="token punctuation">,</span>    <span class="token keyword">output</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> out <span class="token operator">=</span> <span class="token operator">~</span><span class="token punctuation">(</span>a <span class="token operator">^</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre></div></figure><div class="note note-success">            <ul><li><p>同或门 （XNor Gate） 是异或门 (Xor Gate) 的取反输出。</p></li><li><p>异或门的输入输出可以概括为：（输入）相同（输出）为 0 ，不同为1。</p></li><li><p><code>^</code> 为逐位异或，Verilog中不存在逻辑异或符号。</p></li></ul>          </div><h2 id="problem-8-declaring-wires">Problem 8 : Declaring wires</h2><p>信号定义语句需要放置于模块的 body 中，模块的 body 指的就是 module 和endmodule 中间的部分。</p><p>举个例子：</p><figure><img src="/img/HDLBits_two/Wiredecl1.png" alt="Wiredecl1" /><figcaption aria-hidden="true">Wiredecl1</figcaption></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> top_module <span class="token punctuation">(</span>    <span class="token keyword">input</span> in<span class="token punctuation">,</span>              <span class="token comment">// Declare an input wire named "in"</span>    <span class="token keyword">output</span> out             <span class="token comment">// Declare an output wire named "out"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">wire</span> not_in<span class="token punctuation">;</span>           <span class="token comment">// Declare a wire named "not_in"</span>    <span class="token keyword">assign</span> out <span class="token operator">=</span> <span class="token operator">~</span>not_in<span class="token punctuation">;</span>  <span class="token comment">// Assign a value to out (create a NOT gate).</span>    <span class="token keyword">assign</span> not_in <span class="token operator">=</span> <span class="token operator">~</span>in<span class="token punctuation">;</span>   <span class="token comment">// Assign a value to not_in (create another NOT gate).</span><span class="token keyword">endmodule</span>   <span class="token comment">// End of module "top_module"</span></code></pre></div></figure><p>在上面的模块中，有三个 wire (in、out 和 not_in)，其中两个已经声明为模块的输入和输出端口的一部分(这就是为什么在前面的练习中不需要声明任何连接)。wire not_in需要在模块内部声明。从模块外部不可见。然后，使用两个 assign赋值语句创建两个 NOT 门。注意，先创建哪个 NOT门并不重要，最终还是会得到相同的电路。</p><p>小试牛刀：</p><p>Implement the following circuit. Create two intermediate wires (namedanything you want) to connect the AND and OR gates together.</p><p>实现以下电路：创建两个中间线 (命名任意)，以便连接与门、或门一起。</p><figure><img src="/img/HDLBits_two/Wiredecl2.png" alt="Wiredecl2" /><figcaption aria-hidden="true">Wiredecl2</figcaption></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`default_nettype</span> none<span class="token keyword">module</span> top_module <span class="token punctuation">(</span>    <span class="token keyword">input</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> b<span class="token punctuation">,</span>    <span class="token keyword">input</span> c<span class="token punctuation">,</span>    <span class="token keyword">input</span> d<span class="token punctuation">,</span>    <span class="token keyword">output</span> out，    <span class="token keyword">output</span> out_n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">wire</span> w1<span class="token punctuation">,</span> w2<span class="token punctuation">;</span>    <span class="token keyword">assign</span> w1 <span class="token operator">=</span> a <span class="token operator">&amp;</span> b<span class="token punctuation">;</span>    <span class="token keyword">assign</span> w2 <span class="token operator">=</span> c <span class="token operator">&amp;</span> d<span class="token punctuation">;</span>    <span class="token keyword">assign</span> out <span class="token operator">=</span> w1 <span class="token operator">|</span> w2<span class="token punctuation">;</span>    <span class="token keyword">assign</span> out_n <span class="token operator">=</span> <span class="token operator">~</span>out<span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre></div></figure><div class="note note-success">            <ul><li>在定义信号的同时，可以对其赋值，如<code>wire w1 = a &amp; b;</code>。</li></ul>          </div><h2 id="problem-9-7458">Problem 9 : 7458</h2><p>The 7458 is a chip with four AND gates and two OR gates.</p><p>7458 是一个具有四个与门和两个或门的芯片。</p><figure><img src="/img/HDLBits_two/7458.png" alt="7458" /><figcaption aria-hidden="true">7458</figcaption></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> top_module <span class="token punctuation">(</span>    <span class="token keyword">input</span> p1a<span class="token punctuation">,</span>    <span class="token keyword">input</span> p1b<span class="token punctuation">,</span>    <span class="token keyword">input</span> p1c<span class="token punctuation">,</span>    <span class="token keyword">input</span> p1d<span class="token punctuation">,</span>    <span class="token keyword">input</span> p1e<span class="token punctuation">,</span>    <span class="token keyword">input</span> p1f<span class="token punctuation">,</span>    <span class="token keyword">output</span> p1y<span class="token punctuation">,</span>    <span class="token keyword">input</span> p2a<span class="token punctuation">,</span>    <span class="token keyword">input</span> p2b<span class="token punctuation">,</span>    <span class="token keyword">input</span> p2c<span class="token punctuation">,</span>    <span class="token keyword">input</span> p2d<span class="token punctuation">,</span>    <span class="token keyword">output</span> p2y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">wire</span> w1<span class="token punctuation">,</span> w2<span class="token punctuation">,</span> w3<span class="token punctuation">,</span> w4<span class="token punctuation">,</span> w5<span class="token punctuation">,</span> w6<span class="token punctuation">;</span>    <span class="token keyword">assign</span> w1 <span class="token operator">=</span> p1a <span class="token operator">&amp;</span> p1b <span class="token operator">&amp;</span> p1c<span class="token punctuation">;</span>    <span class="token keyword">assign</span> w2 <span class="token operator">=</span> p1d <span class="token operator">&amp;</span> p1e <span class="token operator">&amp;</span> p1f<span class="token punctuation">;</span>    <span class="token keyword">assign</span> w3 <span class="token operator">=</span> p2a <span class="token operator">&amp;</span> p2b<span class="token punctuation">;</span>    <span class="token keyword">assign</span> w4 <span class="token operator">=</span> p2c <span class="token operator">&amp;</span> p2d<span class="token punctuation">;</span>    <span class="token keyword">assign</span> p1y <span class="token operator">=</span> w1 <span class="token operator">|</span> w2<span class="token punctuation">;</span>    <span class="token keyword">assign</span> p2y <span class="token operator">=</span> w3 <span class="token operator">|</span> w4<span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre></div></figure><p>或者对每个输出信号，使用一个 assign 语句，不需要中间信号。</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> top_module <span class="token punctuation">(</span>    <span class="token keyword">input</span> p1a<span class="token punctuation">,</span>    <span class="token keyword">input</span> p1b<span class="token punctuation">,</span>    <span class="token keyword">input</span> p1c<span class="token punctuation">,</span>    <span class="token keyword">input</span> p1d<span class="token punctuation">,</span>    <span class="token keyword">input</span> p1e<span class="token punctuation">,</span>    <span class="token keyword">input</span> p1f<span class="token punctuation">,</span>    <span class="token keyword">output</span> p1y<span class="token punctuation">,</span>    <span class="token keyword">input</span> p2a<span class="token punctuation">,</span>    <span class="token keyword">input</span> p2b<span class="token punctuation">,</span>    <span class="token keyword">input</span> p2c<span class="token punctuation">,</span>    <span class="token keyword">input</span> p2d<span class="token punctuation">,</span>    <span class="token keyword">output</span> p2y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> p1y <span class="token operator">=</span> <span class="token punctuation">(</span>p1a <span class="token operator">&amp;</span> p1b <span class="token operator">&amp;</span> p1c<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>p1d <span class="token operator">&amp;</span> p1e <span class="token operator">&amp;</span> p1f<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> p2y <span class="token operator">=</span> <span class="token punctuation">(</span>p2a <span class="token operator">&amp;</span> p2b<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>p2c <span class="token operator">&amp;</span> p2d<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre></div></figure><h1 id="逻辑门总结">2、逻辑门总结</h1><div class="note note-info">            <ul><li><p><code>&amp;</code> 是逐位与，而 <code>&amp;&amp;</code>是逻辑与。</p></li><li><p><code>~</code> 是逐位取反，而 <code>!</code>是逻辑取反。</p></li><li><p><code>|</code> 是逐位或， 而 <code>||</code> 是逻辑或。</p></li><li><p><code>^</code> 为逐位异或，Verilog中不存在逻辑异或符号。</p></li><li><p>同或门 （XNor Gate） 是异或门 (Nor Gate) 的取反输出。</p></li><li><p>异或门的输入输出可以概括为：（输入）相同（输出）为 0 ，不同为1。</p></li></ul>          </div>]]></content>
    
    
    <categories>
      
      <category>HDLBits刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>HDLBits</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDLBits刷题日记（一）</title>
    <link href="/HDLBits_one/"/>
    <url>/HDLBits_one/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>打算利用碎片化时间重温一遍Verilog语法，好记性不如烂笔头，在此记录一下HDLBits刷题的过程，记录一些知识点，方便日后再次复习。</p>          </div><h1 id="getting-started">1、Getting Started</h1><h2 id="problem-0-step-one">Problem 0 : Step one</h2><p>Build a circuit with no inputs and one output. That output shouldalways drive 1 (or logic high).</p><p>构建一个电路，没有输入端口，只有一个输出端口，输出端口时钟驱动逻辑 1，即逻辑高电平。</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> top_module <span class="token punctuation">(</span>    <span class="token keyword">output</span> one<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> one <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre></div></figure><div class="note note-success">            <p>1 在数字逻辑中代表 logic high，而 0 代表 logic low。</p>          </div><h2 id="problem-1-zero">Problem 1 : Zero</h2><p>Build a circuit with no inputs and one output that outputs a constant0.</p><p>构建一个电路，没有输入端口，只有一个输出端口，但这次输出端口时钟驱动逻辑0 ，即逻辑低电平。</p><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> top_module <span class="token punctuation">(</span>    <span class="token keyword">output</span> zero<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Module body starts after semicolon</span>    <span class="token keyword">assign</span> zero <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre></div></figure><h1 id="verilog-language---basics">2、Verilog Language - Basics</h1><h2 id="problem-2-wire">Problem 2 : Wire</h2><p>Create a module with one input and one output that behaves like awire.</p><p>创建一个具有一个输入和一个输出的模块，其行为类似于导线（wire）。</p><p>不同于物理导线，Verilog中的导线（和其他信号）是有<strong>方向性</strong>的。这意味着信息只能从源（source）单向流向接收端（sink）（源通常也被称为驱动器，用于向导线驱动一个值）。在Verilog的"连续赋值"语句中（<code>assign left_side = right_side;</code>），右侧信号的值被驱动到左侧的导线上。这种赋值被称为"连续的"，是因为即使右侧的值发生变化，赋值也会持续进行。连续赋值不是一次性的事件。</p><p>模块的端口也具有方向性（通常是输入或输出）。输入端口由模块外部的元件驱动，而输出端口则驱动模块外部的元件。从模块内部来看，输入端口是一个驱动器或源，而输出端口是一个接收端。</p><p>下图说明了电路的每个部分如何对应Verilog代码的每个位。模块和端口声明创建了电路的黑色部分。我们的任务是通过添加一个<code>assign</code>语句来创建一条导线（绿色部分），将输入(<code>in</code>)连接到输出(<code>out</code>)。模块外部的部分不是我们需要关心的，但应该知道，我们设计的电路将通过官方的测试工具连接到<code>top_module</code>的端口来进行测试。</p><figure><img src="/img/HDLBits_one/image.png" alt="Wire" /><figcaption aria-hidden="true">Wire</figcaption></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> top_module <span class="token punctuation">(</span>    <span class="token keyword">input</span> in<span class="token punctuation">,</span>    <span class="token keyword">output</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Note that wires are directional, so "assign in = out" is not equivalent.</span>    <span class="token comment">// 注意 wire 是有方向的 因此 assign in = out 是不等价的</span>    <span class="token keyword">assign</span> out <span class="token operator">=</span> in<span class="token punctuation">;</span><span class="token keyword">endmodule</span></code></pre></div></figure><div class="note note-success">            <ul><li><p>wire 一般只有一个 source，即从某一点输出，但可以有多个sinks，即输入到多个点</p></li><li><p>assign语句映射到具体的硬件上，就是产生了信号的驱动，由右值驱动左值。</p></li></ul>          </div><h2 id="problem-3-wire4">Problem 3 : Wire4</h2><p>Create a module with 3 inputs and 4 outputs that behaves like wiresthat makes these connections:</p><p>创建一个具有3个输入和4个输出的模块，要实现如下连接：</p><p>a -&gt; w</p><p>b -&gt; x</p><p>b -&gt; y</p><p>c -&gt; z</p><figure><img src="/img/HDLBits_one/image-1.png" alt="Wire4" /><figcaption aria-hidden="true">Wire4</figcaption></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">top_module</span><span class="token punctuation">(</span>    <span class="token keyword">input</span> a<span class="token punctuation">,</span>    <span class="token keyword">input</span> b<span class="token punctuation">,</span>    <span class="token keyword">input</span> c<span class="token punctuation">,</span>    <span class="token keyword">output</span> w<span class="token punctuation">,</span>    <span class="token keyword">output</span> x<span class="token punctuation">,</span>    <span class="token keyword">output</span> y<span class="token punctuation">,</span>    <span class="token keyword">output</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 这里的顺序可以任意调换</span>    <span class="token keyword">assign</span> w <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token keyword">assign</span> x <span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token keyword">assign</span> y <span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token comment">// 注意这里 b 连接到两个输出</span>    <span class="token keyword">assign</span> z <span class="token operator">=</span> c<span class="token punctuation">;</span>    <span class="token keyword">endmodule</span></code></pre></div></figure><div class="note note-success">            <ul><li><p>多个 assign语句的顺序并不重要，因为它们描述的是连接关系，而不是执行顺序。</p></li><li><p>输入输出端口声明会自动声明 wire类型（除非特别指定其他类型），模块端口声明 <code>input a</code> 等同于<code>input wire a</code> 。</p></li><li><p>assign语句不是创建新的导线，而是在已存在的导线之间建立连接</p></li></ul>          </div><p>注意 b 连接到了两个输出（x 和y），这是允许的，因为一个输入信号可以驱动多个输出；虽然看起来有4条assign 语句，但我们实际上是在7个已经存在的导线之间建立连接。</p>]]></content>
    
    
    <categories>
      
      <category>HDLBits刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>HDLBits</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三大低速总线之SPI详解</title>
    <link href="/spi-introduction/"/>
    <url>/spi-introduction/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>本科阶段在搞硬件设计的时候就经常碰到三大低速总线(UART、SPI、IIC)，奈何好记忆不如烂笔头，趁着现在基于github搭建了个人博客，就把这三大低速总线的原理和应用做一个详细的总结吧，以便日后查阅。</p>          </div><h1 id="spi简介">1、SPI简介</h1><p>SPI (Serial Peripheral Interface)是一种同步通信协议，可以实现微控制器和外围设备之间的数据传输。它是一个全双工的主从协议，这意味着数据可以同时发送和接收。当主设备向从设备发送数据时，从设备可以将数据发送回主设备，而无需等待单独的读操作。它通常用于嵌入式系统，特别是需要高速数据传输的应用程序。</p><h2 id="引脚配置-mosimisosclk-和-cs">1.1、引脚配置： MOSI，MISO，SCLK 和CS</h2><p>SPI 通信需要四个引脚：</p><ul><li><p>MOSI (Master Output Slave Input) : 主设备使用 MOSI引脚向从设备传输数据。</p></li><li><p>MISO (Master Input Slave Output) : 从设备使用 MISO引脚将数据传输回主设备。</p></li><li><p>SCLK (Serial Clock) : SCLK引脚提供时钟信号，用于同步主从设备之间的数据传输。</p></li><li><p>CS (Slave Select) : CS引脚被主设备用来选择它想要与之通信的从设备。</p></li></ul><h2 id="spi-数据传输">1.2、SPI 数据传输</h2><p>数据传输可以由主设备或从设备启动。SPI数据传输过程包括以下几个步骤：</p><p><strong>选择从设备：</strong> 主设备通过拉低 CS线低来选择从设备。这将告诉从设备它正在被寻址，并且应该准备接收或传输数据。</p><p><strong>配置数据传输参数：</strong>主设备设置数据传输参数，如时钟频率、数据格式和每个事务要传输的位数。</p><p><strong>发送数据：</strong> 主设备通过 MOSI线路向从设备发送数据。数据以串行格式发送，从最重要的位开始，一次一位。</p><p><strong>接收数据：</strong> 在发送数据时，主设备也通过 MISO线从从设备接收数据。接收到的数据也是串行格式，一次一位，从最有意义的位开始。</p><p><strong>时钟数据：</strong> 数据传输由 SCK线上的时钟信号同步。所述时钟信号由所述主设备产生，所述从设备将其数据传输与所述时钟信号同步。</p><p><strong>完成数据传输：</strong> 数据传输完成后，主设备将拉高 CS行，表明从设备不再被寻址。然后，从设备可以释放在数据传输期间使用的任何资源。</p><figure><imgsrc="/img/spi-introduction/img_temp_6421dddc954f14-18738137-83373518.png"alt="图 1 数据传输示意图" /><figcaption aria-hidden="true">图 1 数据传输示意图</figcaption></figure><h2 id="spi-寄存器级数据传输">1.3、SPI 寄存器级数据传输</h2><p>在寄存器级，数据一次在主设备和从设备之间传输一个字节。数据传输发生在设备中的特定寄存器之间。每个寄存器都包含一个需要传输的特定函数或数据。</p><ul><li><p>主设备在 SCLK 线路上发送时钟信号来同步数据传输。</p></li><li><p>主设备将 MOSI线设置为适当的逻辑电平，以便将字节的第一位发送给从设备。</p></li><li><p>从设备接收 MISO 线上的位并将其存储在移位寄存器中。</p></li><li><p>时钟信号被切换，字节的下一位由 MOSI 线上的主设备发送。</p></li><li><p>从设备接收 MISO 线上的位并将其移入移位寄存器。</p></li><li><p>这个过程一直持续到所有 8 位的字节都被传输完毕为止。</p></li></ul><p><img src="/img/spi-introduction/image.png"alt="图 2 寄存器级数据传输示意图（a）" /> <imgsrc="/img/spi-introduction/img_temp_64207d4bad0069-44022866-18941375.gif"alt="图 2 寄存器级数据传输示意图（b）" /></p><h2 id="菊花链连接多个设备">1.4、菊花链：连接多个设备</h2><p>SPI 支持多个设备的菊花链，允许多个设备共享一个 SPI总线。在菊花链配置中，每个从设备的 CS 引脚连接到前一个从设备的 MOSI引脚，形成一个链。主设备发送单个 CS信号，选择链路中的第一个从设备，然后通过发送数据和时钟信号与链路中的所有从设备进行通信。</p><figure><imgsrc="/img/spi-introduction/img_temp_6421dddcbf7866-20126192-46942657.png"alt="图 3 连接多个设备" /><figcaption aria-hidden="true">图 3 连接多个设备</figcaption></figure><h2id="错误检测时钟极性和相位等方面">1.5、错误检测，时钟极性和相位等方面</h2><p>SPI 通信还包括其他方面，如错误检测、时钟极性和时钟相位。像 CRC(循环冗余校验)这样的错误检测机制可以用来确保数据的完整性。时钟极性和时钟相位设置决定数据何时被采样和何时被传输，允许协议的灵活性。</p><p>SPI 总线传输一共有 4 种模式，这 4种模式分别由<strong>时钟极性（CPOL，ClockPolarity）和时钟相位（CPHA，Clock Phase）来定义，其中 CPOL 参数规定了SCLK 时钟信号空闲状态的电平，CPHA 规定了数据是在 SCLK时钟的上升沿被采样还是下降沿被采样。</strong></p><ul><li><p>时钟极性决定 SPI 总线空闲时的 SCLK时钟信号是高电平还是低电平。</p><p>CPOL = 1：表示空闲时是高电平；</p><p>CPOL = 0：表示空闲时是低电平。</p></li><li><p>时钟相位决定 SPI 总线从哪个跳变沿开始采样数据。</p><p>CPHA = 0：在时钟信号SCK的第1个跳变沿采样；</p><p>CPHA = 1：在时钟信号SCK的第2个跳变沿采样。</p></li></ul><table style="width:100%;"><thead><tr><th style="text-align: center;">SPI 模式</th><th style="text-align: center;">CPOL</th><th style="text-align: center;">CPHA</th><th style="text-align: center;">空闲时 SCLK 时钟</th><th style="text-align: center;">数据采样时刻</th><th style="text-align: center;">数据切换时刻</th></tr></thead><tbody><tr><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">低电平</td><td style="text-align: center;">上升沿</td><td style="text-align: center;">下降沿</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">低电平</td><td style="text-align: center;">下降沿</td><td style="text-align: center;">上升沿</td></tr><tr><td style="text-align: center;">2</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">高电平</td><td style="text-align: center;">下降沿</td><td style="text-align: center;">上升沿</td></tr><tr><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">高电平</td><td style="text-align: center;">上升沿</td><td style="text-align: center;">下降沿</td></tr></tbody></table><figure><img src="/img/spi-introduction/SPIMode.png" alt="图 4 SPI Mode" /><figcaption aria-hidden="true">图 4 SPI Mode</figcaption></figure><h2 id="spi-的优缺点">1.6、SPI 的优缺点</h2><h3 id="优点">1.6.1、优点</h3><p>与 I2C 和 UART 等其他通信协议相比，SPI 有以下几个优点：</p><p><strong>高速数据传输：</strong> 与其他协议相比，SPI可以实现更高的数据传输速率，使其成为需要快速数据传输的应用程序的极佳选择。</p><p><strong>低开销：</strong> 由于 SPI对数据和时钟信号使用单独的线路，因此与通信协议相关的开销最小。</p><p><strong>简单协议：</strong> SPI是一个开销较少的简单协议，使其成为一些应用程序更有效的选择，易于在硬件和软件中实现。</p><p><strong>全双工通信：</strong> SPI允许在两个方向上同时传输数据，比其他需要单独读写操作的协议 (如 I2C)更有效率。</p><p><strong>灵活的配置：</strong> SPI通信的不同模式允许灵活地配置通信的时间和极性，同时支持多个设备的菊花链，使其成为一些应用程序更灵活的选择。</p><h3 id="缺点">1.6.2、缺点</h3><p>使用 SPI 通信的一些缺点包括：</p><p><strong>有限的距离：</strong> SPI通常用于设备之间的短距离通信，不适合长距离通信。</p><p><strong>设备数量有限：</strong> 尽管 SPI允许多个设备连接到同一总线，但设备数量受到可用 CS 线路数量的限制。</p><p><strong>缺乏错误检测：</strong> 与其他串行通信协议 (如 CAN) 不同，SPI没有内置的纠错机制，这可能使其不太适合需要高可靠性的应用程序。</p>]]></content>
    
    
    <categories>
      
      <category>三大低速总线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>通信协议</tag>
      
      <tag>SPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三大低速总线之UART详解</title>
    <link href="/uart-introduction/"/>
    <url>/uart-introduction/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>本科阶段在搞硬件设计的时候就经常碰到三大低速总线(UART、SPI、IIC)，奈何好记忆不如烂笔头，趁着现在基于github搭建了个人博客，就把这三大低速总线的原理和应用做一个详细的总结吧，以便日后查阅。</p>          </div><h1 id="uart简介">1、UART简介</h1><p>UART是一种采用<strong>异步串行通信方式</strong>的通用异步收发传输器(universalasynchronous receiver-transmitter)，它在发送数据时将并行数据转换成串行数据来传输，在接收数据时将接收到的串行数据转换成并行数据。</p><p>UART串口通信需要两根信号线来实现，一根用于串口发送，另外一根负责串口接收，如图1 所示。对于 PC 来说它的 TX 要和对于 FPGA 来说的 RX 连接，同样 PC 的 RX要和 FPGA 的 TX 连接，如果是两个 TX 或者两个 RX连接那数据就不能正常被发送出去或者接收到。</p><figure><img src="/img/uart-introduction/image.png" alt="图 1 串口通信连接图" /><figcaption aria-hidden="true">图 1 串口通信连接图</figcaption></figure><p>UART 在发送或接收过程中的一帧数据由 4部分组成，起始位、数据位、奇偶校验位和停止位，如图 2 所示。</p><figure><img src="/img/uart-introduction/image-1.png"alt="图 2 异步串行通信数据格式" /><figcaption aria-hidden="true">图 2 异步串行通信数据格式</figcaption></figure><p><spanclass="label label-success"><strong>起始位：</strong></span>当不传输数据时，UART数据传输线通常保持高电压电平。若要开始数据传输，发送UART会将传输线从高电平拉到低电平并保持 1 个波特率周期。当接收 UART检测到高到低电压跃迁时，便开始以波特率对应的频率读取数据帧中的位。</p><p><spanclass="label label-success"><strong>数据帧：</strong></span>其包含所传输的实际数据。如果使用奇偶校验位，数据帧长度可以是5 位到 8 位。如果不使用奇偶校验位，数据帧长度可以是 9位。在大多数情况下，数据以最低有效位优先方式发送。</p><p><spanclass="label label-success"><strong>奇偶校验：</strong></span>奇偶性描述数字是偶数还是奇数。通过奇偶校验位，接收UART判断传输期间是否有数据发生改变。电磁辐射、不一致的波特率或长距离数据传输都可能改变数据位。接收UART 读取数据帧后，将计数值为 1的位，检查总数是偶数还是奇数。如果奇偶校验位为0（偶数奇偶校验），则数据帧中的 1或逻辑高位总计应为偶数。如果奇偶校验位为 1（奇数奇偶校验），则数据帧中的1 或逻辑高位总计应为奇数。当奇偶校验位与数据匹配时，UART认为传输未出错。但是，如果奇偶校验位为 0，而总和为奇数，或者奇偶校验位为1，而总和为偶数，则 UART 认为数据帧中的位已改变。</p><p><spanclass="label label-success"><strong>停止位：</strong></span>为了表示数据包结束，发送UART 将数据传输线从低电压驱动到高电压并保持 1 到 2 位时间。</p><p>UART通信过程中的数据格式及传输速率是可设置的，为了正确的通信，收发双方应约定并遵循同样的设置。数据位可选择为5、6、7、8 位，其中 8 位数据位是最常用的，在实际应用中一般都选择 8位数据 位；校验位可选择奇校验、偶校验或者无校验位；停止位可选择 1位（默认），1.5 或 2位。串口通信的速率用波特率表示，它表示每秒传输二进制数据的位数，单位是bps（位/秒），常用的波特率有 9600、 19200、38400、57600 以及 115200等。</p><div class="note note-primary">            <p>波特率：每秒通过信号传输的码元数称为码元的传输速率，常用符号“Baud”表示，其单位为“波特每秒”(Bps)。在信息传输通道中，携带数据信息的信号单元叫作码元(因为串口是1bit 进行传输的，所以其码元就代表一个二进制数)，串口常见的波特率有4800、9600、19200、115200等，其实意思就是每秒传输这么多个比特位数(bit)。</p><p>通信信道每秒传输的信息量称为位传输速率，简称“比特率”，其单位为“每秒比特数”（bps）。比特率可由波特率计算得出，公式为比特率=波特率×单个调制状态对应的二进制位数。</p><p>如果使用的是 115200 的波特率，其串口的比特率为 115200Bps×1bit =115200bps，由计算得串口发送或者接收 1bit 数据的时间为一个波特，即1/115200s。</p>          </div><p>目前在各种设备中，都是利用CH340、CP2102等 USB转串口芯片来实现串口通信，这些芯片内部集成了 USB转串口的功能，只需要通过 USB 接口连接到 PC 上，就可以实现串口通信。</p><figure><img src="/img/uart-introduction/image-2.png"alt="图 3 USB 串口通信连接示意图" /><figcaption aria-hidden="true">图 3 USB 串口通信连接示意图</figcaption></figure><h1id="uart接收模块uart_rx.v设计">2、UART接收模块(<code>uart_rx.v</code>)设计</h1><p>该模块实现了一个基于AXI4-Stream接口的UART接收器，支持可配置的数据位宽(<code>DATA_WIDTH</code>)和波特率(通过<code>prescale</code>参数)。主要功能包括：</p><ul><li><p><strong>串行数据接收</strong>：通过<code>rxd</code>引脚接收数据。</p></li><li><p><strong>AXI4-Stream接口输出</strong>：通过<code>m_axis_tdata</code>和<code>m_axis_tvalid</code>输出数据。</p></li><li><p><strong>错误检测</strong>：支持帧错误（<code>frame_error</code>）和溢出错误（<code>overrun_error</code>）。</p></li><li><p><strong>状态指示</strong>：通过<code>busy</code>信号指示接收状态。</p></li></ul><h2 id="关键信号与寄存器">2.1、关键信号与寄存器</h2><h3 id="输入输出接口">2.1.1、输入/输出接口</h3><table><thead><tr><th>类型</th><th>名称</th><th>位宽</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>parameter</td><td><code>DATA_WIDTH</code></td><td>-</td><td>-</td><td>数据宽度，默认值为8</td></tr><tr><td>parameter</td><td><code>CLK_FREQ</code></td><td>-</td><td>-</td><td>输入时钟频率，默认值为200MHz</td></tr><tr><td>parameter</td><td><code>BAUD_RATE</code></td><td>-</td><td>-</td><td>目标波特率，默认值为115200bps</td></tr><tr><td>localparam</td><td><code>prescale</code></td><td>-</td><td>-</td><td>分频系数 = CLK_FREQ/(BAUD_RATE*8)</td></tr><tr><td>wire</td><td><code>clk</code></td><td>1</td><td>input</td><td>系统时钟</td></tr><tr><td>wire</td><td><code>rst</code></td><td>1</td><td>input</td><td>系统复位，高电平有效</td></tr><tr><td>wire</td><td><code>m_axis_tdata</code></td><td>DATA_WIDTH</td><td>output</td><td>AXI Stream数据输出</td></tr><tr><td>wire</td><td><code>m_axis_tvalid</code></td><td>1</td><td>output</td><td>AXI Stream数据有效信号</td></tr><tr><td>wire</td><td><code>m_axis_tready</code></td><td>1</td><td>input</td><td>AXI Stream就绪信号</td></tr><tr><td>wire</td><td><code>rxd</code></td><td>1</td><td>input</td><td>UART接收数据线</td></tr><tr><td>wire</td><td><code>busy</code></td><td>1</td><td>output</td><td>接收器忙状态指示</td></tr><tr><td>wire</td><td><code>overrun_error</code></td><td>1</td><td>output</td><td>数据溢出错误指示</td></tr><tr><td>wire</td><td><code>frame_error</code></td><td>1</td><td>output</td><td>帧格式错误指示</td></tr></tbody></table><h3 id="内部寄存器">2.2.2、内部寄存器</h3><table><thead><tr><th>寄存器</th><th>功能说明</th></tr></thead><tbody><tr><td><code>rxd_reg</code></td><td>同步后的<code>rxd</code>输入，避免亚稳态</td></tr><tr><td><code>prescale_reg</code></td><td>分频计数器，控制采样时机</td></tr><tr><td><code>bit_cnt</code></td><td>比特计数器，跟踪当前接收的比特位</td></tr><tr><td><code>data_reg</code></td><td>临时存储接收到的数据位</td></tr><tr><td><code>busy_reg</code></td><td>接收状态标志（忙/空闲）</td></tr><tr><td><code>overrun_error_reg</code></td><td>溢出错误标志</td></tr><tr><td><code>frame_error_reg</code></td><td>帧错误标志</td></tr><tr><td><code>m_axis_tdata_reg</code></td><td>输出数据寄存器</td></tr><tr><td><code>m_axis_tvalid_reg</code></td><td>输出数据有效标志</td></tr></tbody></table><h2 id="实现流程详解">2.2、实现流程详解</h2><h3 id="复位初始化">2.2.1、复位初始化</h3><ul><li><strong>寄存器清零</strong>：在复位信号(<code>rst</code>)为高电平时，所有寄存器和状态标志被清零，rxd_reg初始化为高电平(UART空闲状态)。</li></ul><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>rst<span class="token punctuation">)</span> <span class="token keyword">begin</span>        m_axis_tdata_reg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        m_axis_tvalid_reg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        rxd_reg <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token comment">// UART空闲状态为高电平</span>        prescale_reg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        bit_cnt <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        busy_reg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        overrun_error_reg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        frame_error_reg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span>     <span class="token keyword">else</span> <span class="token keyword">begin</span>        <span class="token comment">// 正常操作逻辑</span>    <span class="token keyword">end</span><span class="token keyword">end</span></code></pre></div></figure><h3 id="同步与状态更新">2.2.2、同步与状态更新</h3><ul><li><p><strong>同步输入</strong>：<code>rxd_reg</code>在每个时钟上升沿采样<code>rxd</code>，避免亚稳态。</p></li><li><p><strong>错误标志清零</strong>：<code>overrun_error_reg</code>和<code>frame_error_reg</code>在每个周期开始时清零，仅在有错误时置位。</p></li></ul><h3 id="接收逻辑">2.2.3、接收逻辑</h3><h4 id="空闲状态bit_cnt-0">空闲状态(bit_cnt = 0)</h4><ul><li>检测<strong>起始位</strong>：当<code>rxd_reg</code>从高电平跳变为低电平时，启动接收流程。</li></ul><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rxd_reg<span class="token punctuation">)</span> <span class="token keyword">begin</span>    prescale_reg <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>prescale <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 起始位采样点</span>    bit_cnt <span class="token operator">&lt;=</span> DATA_WIDTH <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token comment">// 总比特数：起始位 + 数据位 + 停止位</span>    data_reg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>                        <span class="token comment">// 清空数据寄存器</span>    busy_reg <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>                        <span class="token comment">// 进入忙状态</span><span class="token keyword">end</span></code></pre></div></figure><h4 id="接收数据位bit_cnt-data_width-1">接收数据位(bit_cnt &gt;DATA_WIDTH + 1)</h4><ul><li><strong>起始位确认</strong>：确保起始位有效。</li></ul><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">if</span> <span class="token punctuation">(</span>bit_cnt <span class="token operator">></span> DATA_WIDTH <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rxd_reg<span class="token punctuation">)</span> <span class="token keyword">begin</span>                   <span class="token comment">// 起始位有效</span>        bit_cnt <span class="token operator">&lt;=</span> bit_cnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        prescale_reg <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>prescale <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 数据位采样点：1倍波特率周期</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>                        <span class="token comment">// 起始位无效，中止接收</span>        bit_cnt <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        prescale_reg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span></code></pre></div></figure><h4 id="数据位采集bit_cnt-1">数据位采集(bit_cnt &gt; 1)</h4><ul><li><strong>移位接收</strong>：每个数据位在中间点采样，并右移存入<code>data_reg</code>。</li></ul><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bit_cnt <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>    bit_cnt <span class="token operator">&lt;=</span> bit_cnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    prescale_reg <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>prescale <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 更新分频计数器</span>    data_reg <span class="token operator">&lt;=</span> <span class="token operator">&#123;</span>rxd_reg<span class="token punctuation">,</span> data_reg<span class="token punctuation">[</span>DATA_WIDTH<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 右移并插入新比特</span><span class="token keyword">end</span></code></pre></div></figure><h4 id="停止位确认bit_cnt-1">停止位确认(bit_cnt = 1)</h4><ul><li><strong>停止位检测</strong>：停止位应为高电平，否则触发帧错误。</li></ul><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bit_cnt <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>    bit_cnt <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>rxd_reg<span class="token punctuation">)</span> <span class="token keyword">begin</span>                    <span class="token comment">// 停止位有效</span>        m_axis_tdata_reg <span class="token operator">&lt;=</span> data_reg<span class="token punctuation">;</span>     <span class="token comment">// 输出数据</span>        m_axis_tvalid_reg <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>           <span class="token comment">// 置位有效信号</span>        overrun_error_reg <span class="token operator">&lt;=</span> m_axis_tvalid_reg<span class="token punctuation">;</span> <span class="token comment">// 若前次数据未读，触发溢出错误</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>        frame_error_reg <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>             <span class="token comment">// 停止位无效，触发帧错误</span>    <span class="token keyword">end</span><span class="token keyword">end</span></code></pre></div></figure><h3 id="错误处理">2.2.4、错误处理</h3><ul><li><p><strong>溢出错误(OverrunError)</strong>：当新数据已接收(<code>m_axis_tvalid_reg == 1</code>)，但前次数据未被读取(<code>m_axis_tready == 0</code>)时触发。</p></li><li><p><strong>帧错误(FrameError)</strong>：停止位无效(停止位为低电平)，触发帧错误。</p></li></ul><h3 id="波特率控制">2.2.5、波特率控制</h3><ul><li><strong>分频计数器</strong>：<code>prescale_reg</code>控制采样时机，递减至0时触发下一次采样。</li></ul><h1id="uart发送模块uart_tx.v设计">3、UART发送模块(<code>uart_tx.v</code>)设计</h1><p>该模块实现了一个基于AXI4-Stream接口的UART发送器，将并行数据转换为串行数据输出，支持可配置的数据位宽(<code>DATA_WIDTH</code>)和波特率(通过<code>prescale</code>输入)。主要功能包括：</p><ul><li><p><strong>串行数据发送</strong>：通过<code>txd</code>引脚发送数据。</p></li><li><p><strong>AXI4-Stream输入</strong>：<code>s_axis_tdata</code>(数据)、<code>s_axis_tvalid</code>(数据有效)、<code>s_axis_tready</code>(模块就绪)。</p></li><li><p><strong>波特率控制</strong>：<code>prescale</code>(波特率分频系数)。</p></li><li><p><strong>状态指示</strong>：通过<code>busy</code>信号指示发送状态。</p></li></ul><h2 id="关键寄存器与信号">3.1、关键寄存器与信号</h2><h3 id="输入输出接口-1">3.1.1、输入/输出接口</h3><table><thead><tr><th>类型</th><th>名称</th><th>位宽</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>parameter</td><td><code>DATA_WIDTH</code></td><td>-</td><td>-</td><td>数据宽度，默认值为8</td></tr><tr><td>parameter</td><td><code>CLK_FREQ</code></td><td>-</td><td>-</td><td>输入时钟频率，默认值为200MHz</td></tr><tr><td>parameter</td><td><code>BAUD_RATE</code></td><td>-</td><td>-</td><td>目标波特率，默认值为115200bps</td></tr><tr><td>localparam</td><td><code>prescale</code></td><td>-</td><td>-</td><td>分频系数 = CLK_FREQ/(BAUD_RATE*8)</td></tr><tr><td>wire</td><td><code>clk</code></td><td>1</td><td>input</td><td>系统时钟</td></tr><tr><td>wire</td><td><code>rst</code></td><td>1</td><td>input</td><td>系统复位，高电平有效</td></tr><tr><td>wire</td><td><code>s_axis_tdata</code></td><td>DATA_WIDTH</td><td>input</td><td>AXI Stream数据输入</td></tr><tr><td>wire</td><td><code>s_axis_tvalid</code></td><td>1</td><td>input</td><td>AXI Stream数据有效信号</td></tr><tr><td>wire</td><td><code>s_axis_tready</code></td><td>1</td><td>output</td><td>AXI Stream就绪信号</td></tr><tr><td>wire</td><td><code>txd</code></td><td>1</td><td>output</td><td>UART发送数据线</td></tr><tr><td>wire</td><td><code>busy</code></td><td>1</td><td>output</td><td>发送器忙状态指示</td></tr></tbody></table><h3 id="内部寄存器-1">3.1.2、内部寄存器</h3><table><thead><tr><th>寄存器/信号</th><th>描述</th></tr></thead><tbody><tr><td><code>s_axis_tready_reg</code></td><td>控制AXI <code>tready</code>信号，表示模块是否可接收新数据。</td></tr><tr><td><code>txd_reg</code></td><td>存储当前发送的串行数据位（最终输出到<code>txd</code>）。</td></tr><tr><td><code>busy_reg</code></td><td>表示模块是否正在发送数据（高电平有效）。</td></tr><tr><td><code>data_reg</code></td><td>存储待发送的数据帧（包含数据位）。</td></tr><tr><td><code>prescale_reg</code></td><td>波特率分频计数器，用于控制每个位的持续时间。</td></tr><tr><td><code>bit_cnt</code></td><td>位计数器，跟踪当前发送的位位置。</td></tr></tbody></table><h2 id="发送流程详解">3.2、发送流程详解</h2><h3 id="初始状态空闲">3.2.1、初始状态（空闲）</h3><ul><li><p><code>txd_reg</code>保持高电平（空闲状态）。</p></li><li><p><code>s_axis_tready_reg</code>为高，允许接收新数据。</p></li><li><p><code>busy_reg</code>为低，表示模块空闲。</p></li></ul><h3id="数据接收与启动发送s_axis_tvalid有效且模块空闲s_axis_tready_reg为高">3.2.2、数据接收与启动发送(<code>s_axis_tvalid</code>有效且模块空闲<code>s_axis_tready_reg</code>为高)</h3><ul><li><p><strong>锁存数据</strong>：<code>data_reg &lt;= s_axis_tdata</code>。</p></li><li><p><strong>设置起始位</strong>：<code>txd_reg &lt;= 0</code>。</p></li><li><p><strong>初始化计数器</strong>：<code>prescale_reg &lt;= (prescale &lt;&lt; 3) - 1</code>，<code>bit_cnt &lt;= DATA_WIDTH + 1</code>。</p></li><li><p><strong>状态切换</strong>：<code>busy_reg</code>置高，<code>s_axis_tready_reg</code>置低。</p></li></ul><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">if</span> <span class="token punctuation">(</span>s_axis_tvalid<span class="token punctuation">)</span> <span class="token keyword">begin</span>    s_axis_tready_reg <span class="token operator">&lt;=</span> <span class="token operator">!</span>s_axis_tready_reg<span class="token punctuation">;</span>    prescale_reg      <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>prescale <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    bit_cnt           <span class="token operator">&lt;=</span> DATA_WIDTH <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    data_reg          <span class="token operator">&lt;=</span> s_axis_tdata<span class="token punctuation">;</span>    txd_reg           <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    busy_reg          <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span></code></pre></div></figure><h3 id="数据位发送bit_cnt-1">3.2.3、数据位发送(bit_cnt &gt; 1)</h3><ul><li><p><strong>分频计数</strong>：<code>prescale_reg</code>递减至0。</p></li><li><p><strong>移位发送</strong>：<code>&#123;data_reg, txd_reg&#125; &lt;= &#123;1'b0, data_reg&#125;</code>，<code>txd_reg</code>取<code>data_reg</code>的最低位（LSB优先发送）。</p></li><li><p><strong>更新计数器</strong>：<code>bit_cnt</code>减1，重置<code>prescale_reg</code>。</p></li></ul><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">if</span> <span class="token punctuation">(</span>bit_cnt <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>    bit_cnt             <span class="token operator">&lt;=</span> bit_cnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    prescale_reg        <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>prescale <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token operator">&#123;</span>data_reg<span class="token punctuation">,</span> txd_reg<span class="token operator">&#125;</span> <span class="token operator">&lt;=</span> <span class="token operator">&#123;</span><span class="token number">1'b0</span><span class="token punctuation">,</span> data_reg<span class="token operator">&#125;</span><span class="token punctuation">;</span><span class="token keyword">end</span> </code></pre></div></figure><h3 id="停止位发送bit_cnt-1">3.2.4、停止位发送(bit_cnt == 1)</h3><ul><li><p><strong>设置停止位</strong>：<code>txd_reg &lt;= 1</code>。</p></li><li><p><strong>分频计数</strong>：<code>prescale_reg &lt;= prescale &lt;&lt; 3</code>（停止位持续时间）。</p></li><li><p><strong>状态恢复</strong>：<code>bit_cnt</code>减至0，<code>busy_reg</code>置低，<code>s_axis_tready_reg</code>置高。</p></li></ul><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bit_cnt <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>    prescale_reg <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>prescale <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    bit_cnt      <span class="token operator">&lt;=</span> bit_cnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    txd_reg      <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bit_cnt <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>    s_axis_tready_reg <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    busy_reg          <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">//其他逻辑</span><span class="token keyword">end</span></code></pre></div></figure><h2 id="状态转换示意">3.3、状态转换示意</h2><figure><div class="code-wrapper"><pre class="language-none"><code class="language-none">     +-------------+     |   空闲状态   |     | (busy=0)    |     +-----+-------+           | s_axis_tvalid &amp; s_axis_tready           v     +-------------+   bit_cnt &gt; 1  +-----------------+     | 发送起始位   |+--------------&gt;| 发送数据位(循环) |     | (txd=0)     |                | (LSB优先)       |     +-----+-------+                +--------+--------+           |                                  |           | bit_cnt == 1                     |           v                                  |     +-------------+                          |     | 发送停止位   | &lt;------------------------+     | (txd=1)     |     +-------------+</code></pre></div></figure><h1 id="uart回环测试">4、UART回环测试</h1><p>比较简单，只需要将发送模块和接收模块互相连接，然后通过串口助手发送数据，观察接收端是否能够正常接收到数据即可。</p><h2 id="输入输出接口-2">4.1、输入/输出接口</h2><table><thead><tr><th>类型</th><th>名称</th><th>位宽</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>parameter</td><td><code>DATA_WIDTH</code></td><td>-</td><td>-</td><td>数据宽度，默认值为8</td></tr><tr><td>parameter</td><td><code>CLK_FREQ</code></td><td>-</td><td>-</td><td>输入时钟频率，默认值为200MHz</td></tr><tr><td>parameter</td><td><code>BAUD_RATE</code></td><td>-</td><td>-</td><td>目标波特率，默认值为115200bps</td></tr><tr><td>wire</td><td><code>sys_clk_p</code></td><td>1</td><td>input</td><td>系统差分时钟正端</td></tr><tr><td>wire</td><td><code>sys_clk_n</code></td><td>1</td><td>input</td><td>系统差分时钟负端</td></tr><tr><td>wire</td><td><code>sys_rst_n</code></td><td>1</td><td>input</td><td>系统复位信号，低电平有效</td></tr><tr><td>wire</td><td><code>uart_rxd</code></td><td>1</td><td>input</td><td>UART接收数据线</td></tr><tr><td>wire</td><td><code>uart_txd</code></td><td>1</td><td>output</td><td>UART发送数据线</td></tr></tbody></table><h2 id="模块实例化">4.2、模块实例化</h2><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog">uart_tx #<span class="token punctuation">(</span>    <span class="token punctuation">.</span><span class="token function">DATA_WIDTH</span><span class="token punctuation">(</span>DATA_WIDTH<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">CLK_FREQ</span><span class="token punctuation">(</span>CLK_FREQ<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">BAUD_RATE</span><span class="token punctuation">(</span>BAUD_RATE<span class="token punctuation">)</span><span class="token punctuation">)</span>uart_tx_inst <span class="token punctuation">(</span>    <span class="token punctuation">.</span><span class="token function">clk</span><span class="token punctuation">(</span>sys_clk<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">rst</span><span class="token punctuation">(</span><span class="token operator">~</span>sys_rst_n<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// axi input</span>    <span class="token punctuation">.</span><span class="token function">s_axis_tdata</span><span class="token punctuation">(</span>m_axis_tdata<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">s_axis_tvalid</span><span class="token punctuation">(</span>m_axis_tvalid<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">s_axis_tready</span><span class="token punctuation">(</span>m_axis_tready<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// output</span>    <span class="token punctuation">.</span><span class="token function">txd</span><span class="token punctuation">(</span>uart_txd<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// status output</span>    <span class="token punctuation">.</span><span class="token function">busy</span><span class="token punctuation">(</span>tx_busy<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>uart_rx #<span class="token punctuation">(</span>    <span class="token punctuation">.</span><span class="token function">DATA_WIDTH</span><span class="token punctuation">(</span>DATA_WIDTH<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">CLK_FREQ</span><span class="token punctuation">(</span>CLK_FREQ<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">BAUD_RATE</span><span class="token punctuation">(</span>BAUD_RATE<span class="token punctuation">)</span><span class="token punctuation">)</span>uart_rx_inst <span class="token punctuation">(</span>    <span class="token punctuation">.</span><span class="token function">clk</span><span class="token punctuation">(</span>sys_clk<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">rst</span><span class="token punctuation">(</span><span class="token operator">~</span>sys_rst_n<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// axi output</span>    <span class="token punctuation">.</span><span class="token function">m_axis_tdata</span><span class="token punctuation">(</span>m_axis_tdata<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">m_axis_tvalid</span><span class="token punctuation">(</span>m_axis_tvalid<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">m_axis_tready</span><span class="token punctuation">(</span>m_axis_tready<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// input</span>    <span class="token punctuation">.</span><span class="token function">rxd</span><span class="token punctuation">(</span>uart_rxd<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// status output</span>    <span class="token punctuation">.</span><span class="token function">busy</span><span class="token punctuation">(</span>rx_busy<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">overrun_error</span><span class="token punctuation">(</span>rx_overrun_error<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">frame_error</span><span class="token punctuation">(</span>rx_frame_error<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div></figure><h2 id="测试结果">4.3、测试结果</h2><ul><li><p><strong>波特率</strong>：115200bps</p></li><li><p><strong>数据位</strong>：8位</p></li><li><p><strong>校验位</strong>：无</p></li><li><p><strong>停止位</strong>：1位</p></li></ul><figure><img src="/img/uart-introduction/image-3.png"alt="图 4 USB 串口回环测试结果图" /><figcaption aria-hidden="true">图 4 USB 串口回环测试结果图</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>三大低速总线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>通信协议</tag>
      
      <tag>UART</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8b/10b编码详解</title>
    <link href="/8b10b/"/>
    <url>/8b10b/</url>
    
    <content type="html"><![CDATA[<h1 id="b10b编码简介">1、8b/10b编码简介</h1><p>8B/10B 编码是 1983 年由 IBM 公司的 Al Widmer 和 Peter Franaszek所提出的数据传输编码标准，目前已经被广泛应用到高速串行总线。8B/10B编码将待发送的 8 位数据转换成 10位代码组，其目的是保证直流平衡，以及足够密集的电平转换。</p><p>在这些高速收发器的接收端需要通过 CDR技术去恢复时钟与数据的相位关系，在这个过程中需要不断地检测数据边沿和数据中心，从而调整时钟和数据的相位，因此需要保证接收的数据不断变化，从而给CDR 提供足够多的待检测数据边沿。</p><p>另外，高速接口电路一般采用交流耦合方式进行连接，在交流耦合电路中的信号线会接电容（隔直通交）。如果传输的数据在一段时间内全是1 或全是0，那么这段时间传输的信号可以等效成直流信号，会产生直流偏移，在通过电容时，有可能解码错误。</p><p>因此，<strong>通过 8B/10B 编码，保证编码后的数据在一定时间内 0的个数与 1 的个数保持相等。</strong></p><h1 id="b10b编码原理">2、8b/10b编码原理</h1><p>8B/10B 编码的原理是将 8 位数据编码成 10 位数据，编码后的数据中 0 和 1的个数相等，以保证数据的直流平衡。</p><p>当中 8bit 的原始数据可以分为两部分：<strong>低位的 5bitEDCBA(设其十进制数值为X)，高位的 3bit HGF(设其十进制数值为Y)，则该 8bit数据可以记为 D.X.Y。</strong> 比如待编码数据为 110_00011，高 3位数据的十进制为 6，低 5 位的十进制数据为 3，则 D.3.6 就表示110_00011。</p><p>编码时，低 5bit 原数据 EDCBA 经过 5B/6B 编码成为 6bit 码 abcdei，高3bit 原数据 HGF 经 3B/4B 成为 4bit 码fghj，最后再将两部分组合起来形成一个 10bit 码abcdeifghj，如下图所示：</p><figure><img src="/img/8b10b/image.png" alt="图 1 编码示意图" /><figcaption aria-hidden="true">图 1 编码示意图</figcaption></figure><p>另外，<strong>8B/10B 编码中还用到 12个控制字符，他们可以作为传输中帧起始、帧结束、传输空闲等状态标识，与数据字符的记法类似，控制字符一般记为K.X.Y。</strong> 8bit 数据有 256 种，加上 12 种控制字符，总共有 268种。10bit 数据有 1024 种，可以从 1024 种状态中选取 256 种 0 和 1个数相等的数据作为编码结果，在从剩下的数据中选取 12个作为控制字符，即常见的 K码。</p><p>8B/10B 编码中将 K28.1、K28.5 和 K28.7 作为 K码的控制字符，称为“comma”。在任意数据组合中，comma只作为控制字符出现，而在数据部分不会出现，因此可以用 comma字符指示帧的开始和结束标志，或用来修正和数据流对齐的控制字符。</p><h1 id="b10b编码表">3、8b/10b编码表</h1><p>我们首先要搞清楚三个概念：</p><ul><li><strong>编码对照表</strong>：用来对原始数据进行编码的查找表，在对原始8bit数据进行编码时，不需要进行一系列复杂的算法运算（自己推算也可），而是直接从查找表上去查找8bit 原始数据对应的 10bit 编码数据。</li><li><strong>Paireddisparity</strong>：成对差异即“1”的个数和“0”的个数相差 2个（完美平衡除外）。不论是 5B/6B编码还是 3B/4B编码，最终编码后的数据“1”和“0”的个数对比只有三种情况，第一种是“1”的个数比“0”的个数多2 个，第二种是“0”的个数比“1”的个数多 2个，第三种是“1”的个数和“0”的个数一样多。其中“1”的个数和“0”的个数一样多又称之为完美平衡，在完美平衡的状态下是不需要进行补偿的，只不过由于完美平衡的编码数量无法满足所有数据的编码需求，因此完美平衡实际是无法做到的。</li></ul><div class="note note-success">            <p>5位数据总共有32种状态，编码结果有6位数据，0和1数量相等的只有000_111、001_011…、110_001、111_000等20种状态。其中000_111和111_000存在三个连续相同的状态，并没有被使用。导致编码后0和1数据相等的结果就只有18种状态，并不能满足输入5位数据的32种数据状态，3B4B编码也有同样的问题。此时设计编码的人提出，一次编码如果不能保证编码结果0和1个数相等，那么可以让连续两次编码结果的0和1相等，也能满足要求。</p>          </div><ul><li><strong>Running disparity</strong>：运行不一致，在上文的 Paireddisparity中已经说过编码后的数据“1”的个数和“0”的个数不可能做到一直完美平衡（因为只有少数数据编码后是完美平衡，大多数数据编码后是成对差异的），要么“1”的个数比“0”多，要么反之。我们称这种“0”“1”个数差为“极性偏差”，用 RD 表示，当“1”的个数比“0”多的时候 RD的值为“+1”，反过来 RD 的值为“-1”。</li></ul><div class="note note-success">            <p>如果编码结果的1和0个数相等，称为平衡编码，此时RD的数值保持不变。如果编码结果1和0个数不等，称为非平衡编码，此时RD的数值翻转，下次编码采用RD对应数值的编码作为编码结果。</p>          </div><p>搞清楚这三个概念后，我们就可以开始进行 8B/10B 编码了。8B/10B 编码是由5B/6B 编码和 3B/4B 编码组成的，编码的过程是先进行 5B/6B 编码，再进行3B/4B 编码，最后将两部分编码结果组合成 10bit 编码。在编码的过程中，RD的数值会不断翻转，每次编码的起始 RD 都是上次编码结果的 RD。</p><div class="note note-info">            <p><strong>上次8B/10B编码结果的RD数值将用作本次5B/6B编码的起始RD，而3B/4B编码的起始RD等于上次5B/6B编码结果的RD，3B/4B编码结果的RD作为本次8B/10B编码的RD。</strong></p>          </div><p>对应的编码状态跳转如下图所示：</p><figure><img src="/img/8b10b/image-3.png" alt="图 2 编码状态跳转示意图" /><figcaption aria-hidden="true">图 2 编码状态跳转示意图</figcaption></figure><h2 id="b6b-编码表">3.1 5B/6B 编码表</h2><figure><img src="/img/8b10b/image-1.png" alt="图 3 5B/6B 编码表" /><figcaption aria-hidden="true">图 3 5B/6B 编码表</figcaption></figure><p>5bit 的数据位宽一共对应 32 个原始数据，所以在上图的 5B/6B编码中一共拥有 0~31个原始数据，其中“EDCBA”表示原始数据，“abcdei”表示编码后的数据。表中可以看到绝大多数数据都是有两个编码对应的，在实际使用的时候根据RD 的值来选择其中一个编码使用；还有一部分数据后面是携带标记符号的，如D.23、D.27、D.29、D.30，这些带标记符号的既是原始数据又是控制编码的一部分，主要用于K.x.7。其中还有一个 K28比较特殊，这是一个独立的控制编码不与数据复用，主要用于控制编码K.28.y。</p><h2 id="b4b-编码表">3.2 3B/4B 编码表</h2><figure><img src="/img/8b10b/image-2.png" alt="图 4 3B/4B 编码表" /><figcaption aria-hidden="true">图 4 3B/4B 编码表</figcaption></figure><p>在 3B/4B 编码当中大家要注意的是数字 7 有两种编码，分别是 D.x.P7 和D.x.A7，为什么要用两种编码方式呢？</p><div class="note note-success">            <p>主要是避免出现连续的 5 个“0”或“1”，例如当 RD 为 1 时对 D(11,7)进行编码，其中 11 编码后的数值是 110100 而 7 就只能使用 D.x.A7这种编码规则了，如果使用 D.x.P7 的编码规则，最后编码数据就成了1101000001，可以看到出现了连续的 5个“0”。因此大家在编码的时候一定要选择合适的编码规则。</p>          </div><p>在控制码的编码表中可以看到 K.x.1、 K.x.5、 K.x.7这三个控制码被特殊标记了，这三个特殊编码会和上文 5B/6B 编码中提到的 K28连用，组成 K.28.1、K.28.5 和 K.28.7三个特殊编码，这三个特殊编码是会出现连续 5个“0”或“1”的，这种特殊码又称之为“commasymbols”。它们不会出现在数据负荷部分，并且只要出现就一定是控制码，通常用它们作为帧的开始和结束标志，或者数据流对齐的控制字符。</p><p>除了K.28.1、K.28.5 和 K.28.7 这三个特殊编码外还要注意上文 5B/6B编码中提到的 D.23、D.27、D.29、D.30 这几个特殊数值，在控制码中他们只能和K.x.7 连用组成 K.23.7、K.27.7、K.29.7、K.30.7这四个特殊控制码。原因和数字 7 的两套编码规则一样，避免出现连续的 5个“0”或“1”。</p><p><strong>完整的控制码编码表如下：</strong></p><figure><img src="/img/8b10b/image-4.png" alt="图 5 控制码编码示意图" /><figcaption aria-hidden="true">图 5 控制码编码示意图</figcaption></figure><h1 id="b10b编码实例">4、8b/10b编码实例</h1><p>Xilinx<ahref="https://docs.amd.com/v/u/en-US/ug476_7Series_Transceivers">UG476</a>手册的附录有所有8B/10B 编码数据的结果, 以及对应的RD值。这里以手册中的数据为例，对 8B/10B编码进行实例分析。</p><div class="note note-info">            <p><strong>问题一</strong></p><p>请问 D.8.3 的 8B/10B 编码结果是多少？</p>          </div><p>第一个原始数据在进行编码的时候是默认 RD 为“-1”。D.8 的 5B/6B编码结果为 111001，5B/6B 编码完成后，RD 翻转变为 1。将 RD=1 作为 D.x.3的 3B/4B 编码起始 RD，根据查表得编码结果为 0011，再次将 RD翻转，作为本次 8B/10B 编码结果的 RD。因此<strong>起始 RD=-1 的编码结果为111001_0011。</strong></p><p>与正确答案一致，编码结果为 111001_0011：</p><figure><img src="/img/8b10b/image-5.png" alt="图 6 D.8.3 的 8B/10B 编码结果" /><figcaption aria-hidden="true">图 6 D.8.3 的 8B/10B编码结果</figcaption></figure><div class="note note-info">            <p><strong>问题二</strong></p><p>当前 RD=1，则 K.28.5、D.2.6、D.23.4 的编码结果依次是多少，且最终的 RD是多少？</p>          </div><p>首先 RD=1 时，查得 k.28 编码结果为 110000，这是不平衡编码，RD的最终结果会翻转，RD=-1；K.x.5 的3B/4B编码是 0101，这是平衡编码，因此 RD不变，等于 -1。</p><p>因此 D.2.6 的起始 RD=-1，首先 D.2 的 5B/6B 编码结果为 101101，RD翻转变为 1。D.x.6 的 3B/4B 编码结果为 0110，由于 D.x.6 是平衡编码，因此RD 保持不变，等于 1。故 D.2.6 的编码结果为 101101_0110，RD 最终为1。</p><p>最后，D.23.4 的起始 RD=1，D.23.4 的 5B6B 编码结果为 000101，RD 翻转为-1。之后 D.x.4 的编码结果为 1101，RD 的极性再次翻转为 1。</p><p>所以 K.28.5、D.2.6、D.23.4 的编码结果依次是110000_0101、101101_0110、000101_1101，RD 的最终取值为 1。D.2.6、D.23.4的手册查表结果如下图所示，与上述计算结果保持相同，证明编码规则没有问题。</p><figure><img src="/img/8b10b/image-7.png" alt="图 7 D.2.6 的 8B/10B 编码结果" /><figcaption aria-hidden="true">图 7 D.2.6 的 8B/10B编码结果</figcaption></figure><figure><img src="/img/8b10b/image-6.png"alt="图 8 D.23.4 的 8B/10B 编码结果" /><figcaption aria-hidden="true">图 8 D.23.4 的 8B/10B编码结果</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>高速收发器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字编码</tag>
      
      <tag>FPGA</tag>
      
      <tag>8b/10b</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>以太网之UART+MDIO</title>
    <link href="/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%B9%8BUATR+MDIO/"/>
    <url>/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%B9%8BUATR+MDIO/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>组里新买了一款开发板，打算借此重温基本外设的开发。本系列将结合相关芯片手册及个人理解，对FPGA 开发以太网进行整理和记录。</p>          </div><hr /><h1 id="前言">1. 前言</h1><p>在<ahref="https://yao-jiangyu.github.io/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%B9%8BMDIO/">前面的文章</a>中，我们介绍了以太网中的MDIO 的一些基本知识点，今天我们打算利用 UART 来控制 MDIO 的读写，PC端通过 UART 向 FPGA 发送读写 PHY 芯片寄存器的指令，FPGA 通过 MDIO 总线从PHY 芯片读取指定寄存器地址的数据后，通过 UART 将读取的数据发送到 PC端的串口助手进行显示。</p><hr /><h1 id="uart-收发">2 UART 收发</h1><p>UART 的收发实现不属于本次文章的重点，具体实现可以参考<ahref="https://yao-jiangyu.github.io/uart-introduction/">UART回环测试</a>。</p><p>本次实验的指令格式定义如下：</p><h3 id="串口读寄存器指令帧格式">串口读寄存器指令帧格式</h3><table><thead><tr><th>字段名称</th><th>位宽</th><th>值/描述</th><th>字节序</th></tr></thead><tbody><tr><td>帧起始符</td><td>8位</td><td>0x36</td><td>第1字节</td></tr><tr><td>设备地址</td><td>5位</td><td>PHY 芯片地址</td><td>第2字节</td></tr><tr><td>无效位</td><td>2位</td><td>0x00</td><td>第2字节</td></tr><tr><td>读写指示</td><td>1位</td><td>0x01（最低位）</td><td>第2字节</td></tr></tbody></table><h3 id="串口写寄存器指令帧格式">串口写寄存器指令帧格式</h3><table><thead><tr><th>字段名称</th><th>位宽</th><th>值/描述</th><th>字节序</th></tr></thead><tbody><tr><td>帧起始符</td><td>8位</td><td>0x36</td><td>第1字节</td></tr><tr><td>设备地址</td><td>5位</td><td>PHY 芯片地址</td><td>第2字节</td></tr><tr><td>无效位</td><td>2位</td><td>0x00</td><td>第2字节</td></tr><tr><td>读写指示</td><td>1位</td><td>0x01（最低位）</td><td>第2字节</td></tr><tr><td>写入数据</td><td>16位</td><td>高8位先写</td><td>3-4字节</td></tr></tbody></table><hr /><h1 id="整体设计介绍">3 整体设计介绍</h1><figure><img src="/img/UART_MDIO/top.png" alt="MDIO 读操作时序图" /><figcaption aria-hidden="true">MDIO 读操作时序图</figcaption></figure><p>这个处理流程相对简单，其思路和串口数据处理模块借鉴了 CSDN上的电路_fpga 博主的文章<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[FPGA+MDIO总线+UART串口=高效读写PHY芯片寄存器！](https://blog.csdn.net/weixin_50810761/article/details/135092601)">[1]</span></a></sup>。流程如下：PC端通过串口模块发送数据，数据会先传输到串口数据处理模块进行解码，之后该模块会将解码后的信息传递给MDIO 驱动模块。MDIO 驱动模块会驱动 PHY芯片，实现对其内部寄存器的访问。</p><hr /><h1 id="上板实测">4 上板实测</h1><h2 id="网络连接">4.1 网络连接</h2><h2 id="写操作">4.1 写操作</h2><h2 id="读操作">4.1 读操作</h2><hr /><h1 id="代码下载">5、代码下载</h1><p>博客中涉及到的代码均在我的<ahref="https://github.com/yao-jiangyu/MyBlogCode">GitHub仓库</a>中，欢迎大家下载学习。</p><hr /><h1 id="参考资料">6、参考资料</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><ahref="https://blog.csdn.net/weixin_50810761/article/details/135092601">FPGA+MDIO总线+UART串口=高效读写PHY芯片寄存器！</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>以太网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>UART</tag>
      
      <tag>MDIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>以太网之MDIO</title>
    <link href="/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%B9%8BMDIO/"/>
    <url>/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%B9%8BMDIO/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>组里新买了一款开发板，打算借此重温基本外设的开发。本系列将结合相关芯片手册及个人理解，对FPGA 开发以太网进行整理和记录。</p>          </div><hr /><h1 id="mdio-简介">1. MDIO 简介</h1><p>MDIO（Management Data Input/Output）是以太网物理层设备（PHY）和 MAC之间的管理接口，主要用于配置和监控 PHY 设备的状态。MDIO 通常与MDC（Management Data Clock）一起使用，MDC 提供时钟信号，而 MDIO用于数据传输。通常情况下，PHY芯片在默认状态下也可正常工作，因此在进行以太网通信实验时，对 MDIO接口的配置并非必须。</p><ul><li><strong>ETH_MDC</strong>：为 ETH_MDIO提供时钟，数据手册<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[RTL8211数据手册](https://item.szlcsc.com/199338.html?lcsc_vid=RVFWVFVQFVFfVlcCFllXA1xTEgVbV1QETldfBFJfRlkxVlNSQVhaX1dXRVNbVzsOAxUeFF5JWAIASQYPGQZABAsLWA%3D%3D)">[1]</span></a></sup>中规定其最大时钟频率不得超过12.5MHz。</li><li><strong>ETH_MDIO</strong>：双向数据引脚，支持数据的发送与接收。</li></ul><figure><img src="/img/MDIO/image.png" alt="MDIO 接口功能示意图" /><figcaption aria-hidden="true">MDIO 接口功能示意图</figcaption></figure><hr /><h2 id="mdio-通信帧格式">1.1 MDIO 通信帧格式</h2><p>MDIO 接口的读写通信帧格式如下表所示：</p><table style="width:100%;"><thead><tr><th>字段</th><th>读操作帧结构</th><th>写操作帧结构</th></tr></thead><tbody><tr><td>Preamble</td><td>32 位逻辑 "1"</td><td>32 位逻辑 "1"</td></tr><tr><td>ST</td><td>01（帧开始信号）</td><td>01（帧开始信号）</td></tr><tr><td>OP</td><td>10（读操作码）</td><td>01（写操作码）</td></tr><tr><td>PHYAD</td><td>5 位 PHY 地址（AAAAA）</td><td>5 位 PHY 地址（AAAAA）</td></tr><tr><td>REGAD</td><td>5 位寄存器地址（RRRRR）</td><td>5 位寄存器地址（RRRRR）</td></tr><tr><td>TA</td><td>Z0（高阻切换）</td><td>10（固定输出）</td></tr><tr><td>DATA</td><td>16 位读取数据（高位在前）</td><td>16 位写入数据（高位在前）</td></tr><tr><td>IDLE</td><td>高阻态（默认上拉至高电平）</td><td>高阻态（默认上拉至高电平）</td></tr></tbody></table><hr /><h2 id="关键字段说明">1.2 关键字段说明</h2><ul><li><strong>Preamble</strong>：32 位前导码，用于同步 PHY 芯片。</li><li><strong>ST</strong>：帧起始标志，固定为 <code>01</code>。</li><li><strong>OP</strong>：操作码，<code>10</code> 表示读，<code>01</code>表示写。</li><li><strong>PHYAD</strong>：5 位 PHY 地址，支持 MAC 连接多个 PHY芯片。</li><li><strong>REGAD</strong>：5 位寄存器地址，指定目标寄存器。</li><li><strong>TA</strong>：方向切换标志。读操作时，MDIO 由 MAC 驱动切换为PHY 驱动；写操作时固定为 <code>10</code>。</li><li><strong>DATA</strong>：16 位数据，传输时高位在前。</li><li><strong>IDLE</strong>：空闲状态，默认通过上拉电阻维持高电平。</li></ul><hr /><h2 id="时序详解">1.3 时序详解</h2><h3 id="读操作时序">读操作时序</h3><figure><img src="/img/MDIO/image-1.png" alt="MDIO 读操作时序图" /><figcaption aria-hidden="true">MDIO 读操作时序图</figcaption></figure><p>以从 PHY 地址 <code>0x01</code> 的寄存器 <code>0x00</code>读取数据为例：</p><ol type="1"><li><p>MAC 驱动 MDIO 发送前导码、操作码、地址等信息。</p></li><li><p><strong>TA 阶段</strong>：MDIO 引脚切换为由 PHY 驱动，第一个 TA位为高阻态，第二个 TA 位若为低电平，则 PHY响应成功并输出数据；若为高电平，则响应失败。</p></li><li><p>数据采集：PHY 在 MDC 时钟上升沿采集数据，为确保数据稳定传输，MAC在 MDC 下降沿更新 MDIO 引脚数据。当 MDIO 引脚切换至PHY驱动时，MDIO数据于 MDC 时钟下降沿更新，故 MAC 需在 MDC时钟上升沿进行数据采集。</p></li><li><p>读操作结束后，MAC 将 MDIO引脚置为高阻态，此时由外部上拉电阻将其拉高，使 MDIO接口进入空闲状态。</p></li></ol><h3 id="写操作时序">写操作时序</h3><figure><img src="/img/MDIO/image-2.png" alt="MDIO 写操作时序图" /><figcaption aria-hidden="true">MDIO 写操作时序图</figcaption></figure><p>以向 PHY 地址 <code>0x01</code> 的寄存器 <code>0x00</code> 写入数据<code>0x1340</code> 为例：</p><ol type="1"><li><p>MAC 全程驱动 MDIO，依次发送帧头、地址和数据。</p></li><li><p>PHY 于 MDC 时钟上升沿采集数据，为确保数据稳定传输，MAC 在 MDC下降沿更新 MDIO 引脚数据。</p></li><li><p>写操作完成后，MAC 将 MDIO引脚置为高阻态，借助外部上拉电阻将其拉高，使 MDIO接口进入空闲状态。</p></li></ol><hr /><h2 id="phy-地址配置">1.4 PHY 地址配置</h2><p>PHY 地址由硬件电路中的 <code>PHYAD[2:0]</code>引脚电平决定。开发板原理图如下所示，PHY 地址被配置为<code>5'h01</code>：</p><figure><img src="/img/MDIO/image-3.png" alt="PHY 地址配置说明" /><figcaption aria-hidden="true">PHY 地址配置说明</figcaption></figure><figure><img src="/img/MDIO/image-4.png" alt="FPGA 开发板原理图" /><figcaption aria-hidden="true">FPGA 开发板原理图</figcaption></figure><hr /><h2 id="复位方式">1.5 复位方式</h2><p>RTL8211 PHY 芯片支持两种复位方式：</p><ol type="1"><li><p><strong>硬件复位</strong>：通过 <code>PHYRSTB</code> 引脚保持10ms 低电平实现。但开发板上该引脚被上拉，无法使用。</p></li><li><p><strong>软件复位</strong>：向寄存器 <code>0x00</code> 的 Bit[15]写入 <code>1</code>，复位完成后该位自动清零。</p></li></ol><figure><img src="/img/MDIO/image-5.png" alt="硬件复位电路设计" /><figcaption aria-hidden="true">硬件复位电路设计</figcaption></figure><figure><img src="/img/MDIO/image-6.png" alt="软件复位寄存器配置" /><figcaption aria-hidden="true">软件复位寄存器配置</figcaption></figure><hr /><h2 id="常用寄存器">1.6 常用寄存器</h2><h3 id="bmcr基础模式控制寄存器地址-0x00">BMCR（基础模式控制寄存器，地址<code>0x00</code>）</h3><figure><img src="/img/MDIO/image-7.png" alt="BMCR 寄存器上" /><figcaption aria-hidden="true">BMCR 寄存器上</figcaption></figure><figure><img src="/img/MDIO/image-8.png" alt="BMCR 寄存器下" /><figcaption aria-hidden="true">BMCR 寄存器下</figcaption></figure><ul><li><strong>Bit[15]</strong>：软件复位位（写入 <code>1</code>触发）。</li><li><strong>Bit[14]</strong>：环回模式使能（<code>1</code> 启用）。</li><li><strong>Bit[6/13]</strong>：速率选择（仅在自动协商关闭时有效，<code>10</code>==&gt; 1000Mb/s；<code>01</code> ==&gt; 100Mb/s；<code>00</code> ==&gt;10Mb/s）。</li><li><strong>Bit[12]</strong>：自动协商使能（<code>1</code> 启用）。</li><li><strong>Bit[9]</strong>：重启自动协商（<code>1</code> 触发）。</li></ul><h3 id="bmsr基础模式状态寄存器地址-0x01">BMSR（基础模式状态寄存器，地址<code>0x01</code>）</h3><figure><img src="/img/MDIO/image-9.png" alt="BMSR 寄存器" /><figcaption aria-hidden="true">BMSR 寄存器</figcaption></figure><ul><li><strong>Bit[5]</strong>：自动协商完成标志（<code>1</code>表示完成）。</li><li><strong>Bit[2]</strong>：链路状态（<code>1</code>表示连接成功）。</li></ul><h3 id="physrphy-状态寄存器地址-0x1a">PHYSR（PHY 状态寄存器，地址<code>0x1A</code>）</h3><figure><img src="/img/MDIO/image-10.png" alt="PHYSR 寄存器" /><figcaption aria-hidden="true">PHYSR 寄存器</figcaption></figure><ul><li><strong>Bit[5:4]</strong>：连接速率（<code>10</code> ==&gt;1000Mbps，<code>01</code> ==&gt; 100Mbps，<code>00</code> ==&gt;10Mbps）。</li></ul><hr /><h1 id="参考资料">2、参考资料</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><ahref="https://item.szlcsc.com/199338.html?lcsc_vid=RVFWVFVQFVFfVlcCFllXA1xTEgVbV1QETldfBFJfRlkxVlNSQVhaX1dXRVNbVzsOAxUeFF5JWAIASQYPGQZABAsLWA%3D%3D">RTL8211数据手册</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>以太网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>MDIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<center>繁星纵变，智慧永存！</center>]]></content>
    
  </entry>
  
  
  
</search>
