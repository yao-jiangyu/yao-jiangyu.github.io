<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>三大低速总线之UART详解</title>
    <link href="/uart-introduction/"/>
    <url>/uart-introduction/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>本科阶段在搞硬件设计的时候就经常碰到三大低速总线(UART、SPI、IIC)，奈何好记忆不如烂笔头，趁着现在基于github搭建了个人博客，就把这三大低速总线的原理和应用做一个详细的总结吧，以便日后查阅。</p>          </div><h1 id="uart简介">1、UART简介</h1><p>UART是一种采用<strong>异步串行通信方式</strong>的通用异步收发传输器(universalasynchronous receiver-transmitter)，它在发送数据时将并行数据转换成串行数据来传输，在接收数据时将接收到的串行数据转换成并行数据。</p><p>UART串口通信需要两根信号线来实现，一根用于串口发送，另外一根负责串口接收，如图1 所示。对于 PC 来说它的 TX 要和对于 FPGA 来说的 RX 连接，同样 PC 的 RX要和 FPGA 的 TX 连接，如果是两个 TX 或者两个 RX连接那数据就不能正常被发送出去或者接收到。</p><figure><img src="/img/uart-introduction/image.png" alt="图 1 串口通信连接图" /><figcaption aria-hidden="true">图 1 串口通信连接图</figcaption></figure><p>UART 在发送或接收过程中的一帧数据由 4部分组成，起始位、数据位、奇偶校验位和停止位，如图 2 所示。</p><figure><img src="/img/uart-introduction/image-1.png"alt="图 2 异步串行通信数据格式" /><figcaption aria-hidden="true">图 2 异步串行通信数据格式</figcaption></figure><p><spanclass="label label-success"><strong>起始位：</strong></span>当不传输数据时，UART数据传输线通常保持高电压电平。若要开始数据传输，发送UART会将传输线从高电平拉到低电平并保持 1 个波特率周期。当接收 UART检测到高到低电压跃迁时，便开始以波特率对应的频率读取数据帧中的位。</p><p><spanclass="label label-success"><strong>数据帧：</strong></span>其包含所传输的实际数据。如果使用奇偶校验位，数据帧长度可以是5 位到 8 位。如果不使用奇偶校验位，数据帧长度可以是 9位。在大多数情况下，数据以最低有效位优先方式发送。</p><p><spanclass="label label-success"><strong>奇偶校验：</strong></span>奇偶性描述数字是偶数还是奇数。通过奇偶校验位，接收UART判断传输期间是否有数据发生改变。电磁辐射、不一致的波特率或长距离数据传输都可能改变数据位。接收UART 读取数据帧后，将计数值为 1的位，检查总数是偶数还是奇数。如果奇偶校验位为0（偶数奇偶校验），则数据帧中的 1或逻辑高位总计应为偶数。如果奇偶校验位为 1（奇数奇偶校验），则数据帧中的1 或逻辑高位总计应为奇数。当奇偶校验位与数据匹配时，UART认为传输未出错。但是，如果奇偶校验位为 0，而总和为奇数，或者奇偶校验位为1，而总和为偶数，则 UART 认为数据帧中的位已改变。</p><p><spanclass="label label-success"><strong>停止位：</strong></span>为了表示数据包结束，发送UART 将数据传输线从低电压驱动到高电压并保持 1 到 2 位时间。</p><p>UART通信过程中的数据格式及传输速率是可设置的，为了正确的通信，收发双方应约定并遵循同样的设置。数据位可选择为5、6、7、8 位，其中 8 位数据位是最常用的，在实际应用中一般都选择 8位数据 位；校验位可选择奇校验、偶校验或者无校验位；停止位可选择 1位（默认），1.5 或 2位。串口通信的速率用波特率表示，它表示每秒传输二进制数据的位数，单位是bps（位/秒），常用的波特率有 9600、 19200、38400、57600 以及 115200等。</p><div class="note note-primary">            <p>波特率：每秒通过信号传输的码元数称为码元的传输速率，常用符号“Baud”表示，其单位为“波特每秒”(Bps)。在信息传输通道中，携带数据信息的信号单元叫作码元(因为串口是1bit 进行传输的，所以其码元就代表一个二进制数)，串口常见的波特率有4800、9600、19200、115200等，其实意思就是每秒传输这么多个比特位数(bit)。</p><p>通信信道每秒传输的信息量称为位传输速率，简称“比特率”，其单位为“每秒比特数”（bps）。比特率可由波特率计算得出，公式为比特率=波特率×单个调制状态对应的二进制位数。</p><p>如果使用的是 115200 的波特率，其串口的比特率为 115200Bps×1bit =115200bps，由计算得串口发送或者接收 1bit 数据的时间为一个波特，即1/115200s。</p>          </div><p>目前在各种设备中，都是利用CH340、CP2102等 USB转串口芯片来实现串口通信，这些芯片内部集成了 USB转串口的功能，只需要通过 USB 接口连接到 PC 上，就可以实现串口通信。</p><figure><img src="/img/uart-introduction/image-2.png"alt="图 3 USB 串口通信连接示意图" /><figcaption aria-hidden="true">图 3 USB 串口通信连接示意图</figcaption></figure><h1id="uart接收模块uart_rx.v设计">2、UART接收模块(<code>uart_rx.v</code>)设计</h1><p>该模块实现了一个基于AXI4-Stream接口的UART接收器，支持可配置的数据位宽(<code>DATA_WIDTH</code>)和波特率(通过<code>prescale</code>参数)。主要功能包括：</p><ul><li><p><strong>串行数据接收</strong>：通过<code>rxd</code>引脚接收数据。</p></li><li><p><strong>AXI4-Stream接口输出</strong>：通过<code>m_axis_tdata</code>和<code>m_axis_tvalid</code>输出数据。</p></li><li><p><strong>错误检测</strong>：支持帧错误（<code>frame_error</code>）和溢出错误（<code>overrun_error</code>）。</p></li><li><p><strong>状态指示</strong>：通过<code>busy</code>信号指示接收状态。</p></li></ul><h2 id="关键信号与寄存器">2.1、关键信号与寄存器</h2><h3 id="输入输出接口">2.1.1、输入/输出接口</h3><table><thead><tr><th>类型</th><th>名称</th><th>位宽</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>parameter</td><td><code>DATA_WIDTH</code></td><td>-</td><td>-</td><td>数据宽度，默认值为8</td></tr><tr><td>parameter</td><td><code>CLK_FREQ</code></td><td>-</td><td>-</td><td>输入时钟频率，默认值为200MHz</td></tr><tr><td>parameter</td><td><code>BAUD_RATE</code></td><td>-</td><td>-</td><td>目标波特率，默认值为115200bps</td></tr><tr><td>localparam</td><td><code>prescale</code></td><td>-</td><td>-</td><td>分频系数 = CLK_FREQ/(BAUD_RATE*8)</td></tr><tr><td>wire</td><td><code>clk</code></td><td>1</td><td>input</td><td>系统时钟</td></tr><tr><td>wire</td><td><code>rst</code></td><td>1</td><td>input</td><td>系统复位，高电平有效</td></tr><tr><td>wire</td><td><code>m_axis_tdata</code></td><td>DATA_WIDTH</td><td>output</td><td>AXI Stream数据输出</td></tr><tr><td>wire</td><td><code>m_axis_tvalid</code></td><td>1</td><td>output</td><td>AXI Stream数据有效信号</td></tr><tr><td>wire</td><td><code>m_axis_tready</code></td><td>1</td><td>input</td><td>AXI Stream就绪信号</td></tr><tr><td>wire</td><td><code>rxd</code></td><td>1</td><td>input</td><td>UART接收数据线</td></tr><tr><td>wire</td><td><code>busy</code></td><td>1</td><td>output</td><td>接收器忙状态指示</td></tr><tr><td>wire</td><td><code>overrun_error</code></td><td>1</td><td>output</td><td>数据溢出错误指示</td></tr><tr><td>wire</td><td><code>frame_error</code></td><td>1</td><td>output</td><td>帧格式错误指示</td></tr></tbody></table><h3 id="内部寄存器">2.2.2、内部寄存器</h3><table><thead><tr><th>寄存器</th><th>功能说明</th></tr></thead><tbody><tr><td><code>rxd_reg</code></td><td>同步后的<code>rxd</code>输入，避免亚稳态</td></tr><tr><td><code>prescale_reg</code></td><td>分频计数器，控制采样时机</td></tr><tr><td><code>bit_cnt</code></td><td>比特计数器，跟踪当前接收的比特位</td></tr><tr><td><code>data_reg</code></td><td>临时存储接收到的数据位</td></tr><tr><td><code>busy_reg</code></td><td>接收状态标志（忙/空闲）</td></tr><tr><td><code>overrun_error_reg</code></td><td>溢出错误标志</td></tr><tr><td><code>frame_error_reg</code></td><td>帧错误标志</td></tr><tr><td><code>m_axis_tdata_reg</code></td><td>输出数据寄存器</td></tr><tr><td><code>m_axis_tvalid_reg</code></td><td>输出数据有效标志</td></tr></tbody></table><h2 id="实现流程详解">2.2、实现流程详解</h2><h3 id="复位初始化">2.2.1、复位初始化</h3><ul><li><strong>寄存器清零</strong>：在复位信号(<code>rst</code>)为高电平时，所有寄存器和状态标志被清零，rxd_reg初始化为高电平(UART空闲状态)。</li></ul><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>rst<span class="token punctuation">)</span> <span class="token keyword">begin</span>        m_axis_tdata_reg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        m_axis_tvalid_reg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        rxd_reg <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token comment">// UART空闲状态为高电平</span>        prescale_reg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        bit_cnt <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        busy_reg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        overrun_error_reg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        frame_error_reg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span>     <span class="token keyword">else</span> <span class="token keyword">begin</span>        <span class="token comment">// 正常操作逻辑</span>    <span class="token keyword">end</span><span class="token keyword">end</span></code></pre></div></figure><h3 id="同步与状态更新">2.2.2、同步与状态更新</h3><ul><li><p><strong>同步输入</strong>：<code>rxd_reg</code>在每个时钟上升沿采样<code>rxd</code>，避免亚稳态。</p></li><li><p><strong>错误标志清零</strong>：<code>overrun_error_reg</code>和<code>frame_error_reg</code>在每个周期开始时清零，仅在有错误时置位。</p></li></ul><h3 id="接收逻辑">2.2.3、接收逻辑</h3><h4 id="空闲状态bit_cnt-0">空闲状态(bit_cnt = 0)</h4><ul><li>检测<strong>起始位</strong>：当<code>rxd_reg</code>从高电平跳变为低电平时，启动接收流程。</li></ul><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rxd_reg<span class="token punctuation">)</span> <span class="token keyword">begin</span>    prescale_reg <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>prescale <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 起始位采样点</span>    bit_cnt <span class="token operator">&lt;=</span> DATA_WIDTH <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token comment">// 总比特数：起始位 + 数据位 + 停止位</span>    data_reg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>                        <span class="token comment">// 清空数据寄存器</span>    busy_reg <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>                        <span class="token comment">// 进入忙状态</span><span class="token keyword">end</span></code></pre></div></figure><h4 id="接收数据位bit_cnt-data_width-1">接收数据位(bit_cnt &gt;DATA_WIDTH + 1)</h4><ul><li><strong>起始位确认</strong>：确保起始位有效。</li></ul><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">if</span> <span class="token punctuation">(</span>bit_cnt <span class="token operator">></span> DATA_WIDTH <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rxd_reg<span class="token punctuation">)</span> <span class="token keyword">begin</span>                   <span class="token comment">// 起始位有效</span>        bit_cnt <span class="token operator">&lt;=</span> bit_cnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        prescale_reg <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>prescale <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 数据位采样点：1倍波特率周期</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>                        <span class="token comment">// 起始位无效，中止接收</span>        bit_cnt <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        prescale_reg <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span></code></pre></div></figure><h4 id="数据位采集bit_cnt-1">数据位采集(bit_cnt &gt; 1)</h4><ul><li><strong>移位接收</strong>：每个数据位在中间点采样，并右移存入<code>data_reg</code>。</li></ul><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bit_cnt <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>    bit_cnt <span class="token operator">&lt;=</span> bit_cnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    prescale_reg <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>prescale <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 更新分频计数器</span>    data_reg <span class="token operator">&lt;=</span> <span class="token operator">&#123;</span>rxd_reg<span class="token punctuation">,</span> data_reg<span class="token punctuation">[</span>DATA_WIDTH<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 右移并插入新比特</span><span class="token keyword">end</span></code></pre></div></figure><h4 id="停止位确认bit_cnt-1">停止位确认(bit_cnt = 1)</h4><ul><li><strong>停止位检测</strong>：停止位应为高电平，否则触发帧错误。</li></ul><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bit_cnt <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>    bit_cnt <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>rxd_reg<span class="token punctuation">)</span> <span class="token keyword">begin</span>                    <span class="token comment">// 停止位有效</span>        m_axis_tdata_reg <span class="token operator">&lt;=</span> data_reg<span class="token punctuation">;</span>     <span class="token comment">// 输出数据</span>        m_axis_tvalid_reg <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>           <span class="token comment">// 置位有效信号</span>        overrun_error_reg <span class="token operator">&lt;=</span> m_axis_tvalid_reg<span class="token punctuation">;</span> <span class="token comment">// 若前次数据未读，触发溢出错误</span>    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span>        frame_error_reg <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>             <span class="token comment">// 停止位无效，触发帧错误</span>    <span class="token keyword">end</span><span class="token keyword">end</span></code></pre></div></figure><h3 id="错误处理">2.2.4、错误处理</h3><ul><li><p><strong>溢出错误(OverrunError)</strong>：当新数据已接收(<code>m_axis_tvalid_reg == 1</code>)，但前次数据未被读取(<code>m_axis_tready == 0</code>)时触发。</p></li><li><p><strong>帧错误(FrameError)</strong>：停止位无效(停止位为低电平)，触发帧错误。</p></li></ul><h3 id="波特率控制">2.2.5、波特率控制</h3><ul><li><strong>分频计数器</strong>：<code>prescale_reg</code>控制采样时机，递减至0时触发下一次采样。</li></ul><h1id="uart发送模块uart_tx.v设计">3、UART发送模块(<code>uart_tx.v</code>)设计</h1><p>该模块实现了一个基于AXI4-Stream接口的UART发送器，将并行数据转换为串行数据输出，支持可配置的数据位宽(<code>DATA_WIDTH</code>)和波特率(通过<code>prescale</code>输入)。主要功能包括：</p><ul><li><p><strong>串行数据发送</strong>：通过<code>txd</code>引脚发送数据。</p></li><li><p><strong>AXI4-Stream输入</strong>：<code>s_axis_tdata</code>(数据)、<code>s_axis_tvalid</code>(数据有效)、<code>s_axis_tready</code>(模块就绪)。</p></li><li><p><strong>波特率控制</strong>：<code>prescale</code>(波特率分频系数)。</p></li><li><p><strong>状态指示</strong>：通过<code>busy</code>信号指示发送状态。</p></li></ul><h2 id="关键寄存器与信号">3.1、关键寄存器与信号</h2><h3 id="输入输出接口-1">3.1.1、输入/输出接口</h3><table><thead><tr><th>类型</th><th>名称</th><th>位宽</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>parameter</td><td><code>DATA_WIDTH</code></td><td>-</td><td>-</td><td>数据宽度，默认值为8</td></tr><tr><td>parameter</td><td><code>CLK_FREQ</code></td><td>-</td><td>-</td><td>输入时钟频率，默认值为200MHz</td></tr><tr><td>parameter</td><td><code>BAUD_RATE</code></td><td>-</td><td>-</td><td>目标波特率，默认值为115200bps</td></tr><tr><td>localparam</td><td><code>prescale</code></td><td>-</td><td>-</td><td>分频系数 = CLK_FREQ/(BAUD_RATE*8)</td></tr><tr><td>wire</td><td><code>clk</code></td><td>1</td><td>input</td><td>系统时钟</td></tr><tr><td>wire</td><td><code>rst</code></td><td>1</td><td>input</td><td>系统复位，高电平有效</td></tr><tr><td>wire</td><td><code>s_axis_tdata</code></td><td>DATA_WIDTH</td><td>input</td><td>AXI Stream数据输入</td></tr><tr><td>wire</td><td><code>s_axis_tvalid</code></td><td>1</td><td>input</td><td>AXI Stream数据有效信号</td></tr><tr><td>wire</td><td><code>s_axis_tready</code></td><td>1</td><td>output</td><td>AXI Stream就绪信号</td></tr><tr><td>wire</td><td><code>txd</code></td><td>1</td><td>output</td><td>UART发送数据线</td></tr><tr><td>wire</td><td><code>busy</code></td><td>1</td><td>output</td><td>发送器忙状态指示</td></tr></tbody></table><h3 id="内部寄存器-1">3.1.2、内部寄存器</h3><table><thead><tr><th>寄存器/信号</th><th>描述</th></tr></thead><tbody><tr><td><code>s_axis_tready_reg</code></td><td>控制AXI <code>tready</code>信号，表示模块是否可接收新数据。</td></tr><tr><td><code>txd_reg</code></td><td>存储当前发送的串行数据位（最终输出到<code>txd</code>）。</td></tr><tr><td><code>busy_reg</code></td><td>表示模块是否正在发送数据（高电平有效）。</td></tr><tr><td><code>data_reg</code></td><td>存储待发送的数据帧（包含数据位）。</td></tr><tr><td><code>prescale_reg</code></td><td>波特率分频计数器，用于控制每个位的持续时间。</td></tr><tr><td><code>bit_cnt</code></td><td>位计数器，跟踪当前发送的位位置。</td></tr></tbody></table><h2 id="发送流程详解">3.2、发送流程详解</h2><h3 id="初始状态空闲">3.2.1、初始状态（空闲）</h3><ul><li><p><code>txd_reg</code>保持高电平（空闲状态）。</p></li><li><p><code>s_axis_tready_reg</code>为高，允许接收新数据。</p></li><li><p><code>busy_reg</code>为低，表示模块空闲。</p></li></ul><h3id="数据接收与启动发送s_axis_tvalid有效且模块空闲s_axis_tready_reg为高">3.2.2、数据接收与启动发送(<code>s_axis_tvalid</code>有效且模块空闲<code>s_axis_tready_reg</code>为高)</h3><ul><li><p><strong>锁存数据</strong>：<code>data_reg &lt;= s_axis_tdata</code>。</p></li><li><p><strong>设置起始位</strong>：<code>txd_reg &lt;= 0</code>。</p></li><li><p><strong>初始化计数器</strong>：<code>prescale_reg &lt;= (prescale &lt;&lt; 3) - 1</code>，<code>bit_cnt &lt;= DATA_WIDTH + 1</code>。</p></li><li><p><strong>状态切换</strong>：<code>busy_reg</code>置高，<code>s_axis_tready_reg</code>置低。</p></li></ul><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">if</span> <span class="token punctuation">(</span>s_axis_tvalid<span class="token punctuation">)</span> <span class="token keyword">begin</span>    s_axis_tready_reg <span class="token operator">&lt;=</span> <span class="token operator">!</span>s_axis_tready_reg<span class="token punctuation">;</span>    prescale_reg      <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>prescale <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    bit_cnt           <span class="token operator">&lt;=</span> DATA_WIDTH <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    data_reg          <span class="token operator">&lt;=</span> s_axis_tdata<span class="token punctuation">;</span>    txd_reg           <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    busy_reg          <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span></code></pre></div></figure><h3 id="数据位发送bit_cnt-1">3.2.3、数据位发送(bit_cnt &gt; 1)</h3><ul><li><p><strong>分频计数</strong>：<code>prescale_reg</code>递减至0。</p></li><li><p><strong>移位发送</strong>：<code>&#123;data_reg, txd_reg&#125; &lt;= &#123;1'b0, data_reg&#125;</code>，<code>txd_reg</code>取<code>data_reg</code>的最低位（LSB优先发送）。</p></li><li><p><strong>更新计数器</strong>：<code>bit_cnt</code>减1，重置<code>prescale_reg</code>。</p></li></ul><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">if</span> <span class="token punctuation">(</span>bit_cnt <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>    bit_cnt             <span class="token operator">&lt;=</span> bit_cnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    prescale_reg        <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>prescale <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token operator">&#123;</span>data_reg<span class="token punctuation">,</span> txd_reg<span class="token operator">&#125;</span> <span class="token operator">&lt;=</span> <span class="token operator">&#123;</span><span class="token number">1'b0</span><span class="token punctuation">,</span> data_reg<span class="token operator">&#125;</span><span class="token punctuation">;</span><span class="token keyword">end</span> </code></pre></div></figure><h3 id="停止位发送bit_cnt-1">3.2.4、停止位发送(bit_cnt == 1)</h3><ul><li><p><strong>设置停止位</strong>：<code>txd_reg &lt;= 1</code>。</p></li><li><p><strong>分频计数</strong>：<code>prescale_reg &lt;= prescale &lt;&lt; 3</code>（停止位持续时间）。</p></li><li><p><strong>状态恢复</strong>：<code>bit_cnt</code>减至0，<code>busy_reg</code>置低，<code>s_axis_tready_reg</code>置高。</p></li></ul><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bit_cnt <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>    prescale_reg <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>prescale <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    bit_cnt      <span class="token operator">&lt;=</span> bit_cnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    txd_reg      <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bit_cnt <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>    s_axis_tready_reg <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    busy_reg          <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">//其他逻辑</span><span class="token keyword">end</span></code></pre></div></figure><h2 id="状态转换示意图">3.3、状态转换示意图</h2><figure><div class="code-wrapper"><pre class="language-none"><code class="language-none">     +-------------+     |   空闲状态   |     | (busy=0)    |     +-----+-------+           | s_axis_tvalid &amp; s_axis_tready           v     +-------------+   bit_cnt &gt; 1  +-----------------+     | 发送起始位   |+--------------&gt;| 发送数据位(循环) |     | (txd=0)     |                | (LSB优先)       |     +-----+-------+                +--------+--------+           |                                  |           | bit_cnt == 1                     |           v                                  |     +-------------+                          |     | 发送停止位   | &lt;------------------------+     | (txd=1)     |     +-------------+</code></pre></div></figure><h1 id="uart回环测试">4、UART回环测试</h1><p>比较简单，只需要将发送模块和接收模块互相连接，然后通过串口助手发送数据，观察接收端是否能够正常接收到数据即可。</p><h2 id="输入输出接口-2">4.1、输入/输出接口</h2><table><thead><tr><th>类型</th><th>名称</th><th>位宽</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>parameter</td><td><code>DATA_WIDTH</code></td><td>-</td><td>-</td><td>数据宽度，默认值为8</td></tr><tr><td>parameter</td><td><code>CLK_FREQ</code></td><td>-</td><td>-</td><td>输入时钟频率，默认值为200MHz</td></tr><tr><td>parameter</td><td><code>BAUD_RATE</code></td><td>-</td><td>-</td><td>目标波特率，默认值为115200bps</td></tr><tr><td>wire</td><td><code>sys_clk_p</code></td><td>1</td><td>input</td><td>系统差分时钟正端</td></tr><tr><td>wire</td><td><code>sys_clk_n</code></td><td>1</td><td>input</td><td>系统差分时钟负端</td></tr><tr><td>wire</td><td><code>sys_rst_n</code></td><td>1</td><td>input</td><td>系统复位信号，低电平有效</td></tr><tr><td>wire</td><td><code>uart_rxd</code></td><td>1</td><td>input</td><td>UART接收数据线</td></tr><tr><td>wire</td><td><code>uart_txd</code></td><td>1</td><td>output</td><td>UART发送数据线</td></tr></tbody></table><h2 id="模块实例化">4.2、模块实例化</h2><figure><div class="code-wrapper"><pre class="language-verilog" data-language="verilog"><code class="language-verilog">uart_tx #<span class="token punctuation">(</span>    <span class="token punctuation">.</span><span class="token function">DATA_WIDTH</span><span class="token punctuation">(</span>DATA_WIDTH<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">CLK_FREQ</span><span class="token punctuation">(</span>CLK_FREQ<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">BAUD_RATE</span><span class="token punctuation">(</span>BAUD_RATE<span class="token punctuation">)</span><span class="token punctuation">)</span>uart_tx_inst <span class="token punctuation">(</span>    <span class="token punctuation">.</span><span class="token function">clk</span><span class="token punctuation">(</span>sys_clk<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">rst</span><span class="token punctuation">(</span><span class="token operator">~</span>sys_rst_n<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// axi input</span>    <span class="token punctuation">.</span><span class="token function">s_axis_tdata</span><span class="token punctuation">(</span>m_axis_tdata<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">s_axis_tvalid</span><span class="token punctuation">(</span>m_axis_tvalid<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">s_axis_tready</span><span class="token punctuation">(</span>m_axis_tready<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// output</span>    <span class="token punctuation">.</span><span class="token function">txd</span><span class="token punctuation">(</span>uart_txd<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// status output</span>    <span class="token punctuation">.</span><span class="token function">busy</span><span class="token punctuation">(</span>tx_busy<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>uart_rx #<span class="token punctuation">(</span>    <span class="token punctuation">.</span><span class="token function">DATA_WIDTH</span><span class="token punctuation">(</span>DATA_WIDTH<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">CLK_FREQ</span><span class="token punctuation">(</span>CLK_FREQ<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">BAUD_RATE</span><span class="token punctuation">(</span>BAUD_RATE<span class="token punctuation">)</span><span class="token punctuation">)</span>uart_rx_inst <span class="token punctuation">(</span>    <span class="token punctuation">.</span><span class="token function">clk</span><span class="token punctuation">(</span>sys_clk<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">rst</span><span class="token punctuation">(</span><span class="token operator">~</span>sys_rst_n<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// axi output</span>    <span class="token punctuation">.</span><span class="token function">m_axis_tdata</span><span class="token punctuation">(</span>m_axis_tdata<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">m_axis_tvalid</span><span class="token punctuation">(</span>m_axis_tvalid<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">m_axis_tready</span><span class="token punctuation">(</span>m_axis_tready<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// input</span>    <span class="token punctuation">.</span><span class="token function">rxd</span><span class="token punctuation">(</span>uart_rxd<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// status output</span>    <span class="token punctuation">.</span><span class="token function">busy</span><span class="token punctuation">(</span>rx_busy<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">overrun_error</span><span class="token punctuation">(</span>rx_overrun_error<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token function">frame_error</span><span class="token punctuation">(</span>rx_frame_error<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div></figure><h2 id="测试结果">4.3、测试结果</h2><ul><li><p><strong>波特率</strong>：115200bps</p></li><li><p><strong>数据位</strong>：8位</p></li><li><p><strong>校验位</strong>：无</p></li><li><p><strong>停止位</strong>：1位</p></li></ul><figure><img src="/img/uart-introduction/image-3.png" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>三大低速总线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>通信协议</tag>
      
      <tag>UART</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8b/10b编码详解</title>
    <link href="/8b10b/"/>
    <url>/8b10b/</url>
    
    <content type="html"><![CDATA[<h1 id="b10b编码简介">1、8b/10b编码简介</h1><p>8B/10B 编码是 1983 年由 IBM 公司的 Al Widmer 和 Peter Franaszek所提出的数据传输编码标准，目前已经被广泛应用到高速串行总线。8B/10B编码将待发送的 8 位数据转换成 10位代码组，其目的是保证直流平衡，以及足够密集的电平转换。</p><p>在这些高速收发器的接收端需要通过 CDR技术去恢复时钟与数据的相位关系，在这个过程中需要不断地检测数据边沿和数据中心，从而调整时钟和数据的相位，因此需要保证接收的数据不断变化，从而给CDR 提供足够多的待检测数据边沿。</p><p>另外，高速接口电路一般采用交流耦合方式进行连接，在交流耦合电路中的信号线会接电容（隔直通交）。如果传输的数据在一段时间内全是1 或全是0，那么这段时间传输的信号可以等效成直流信号，会产生直流偏移，在通过电容时，有可能解码错误。</p><p>因此，<strong>通过 8B/10B 编码，保证编码后的数据在一定时间内 0的个数与 1 的个数保持相等。</strong></p><h1 id="b10b编码原理">2、8b/10b编码原理</h1><p>8B/10B 编码的原理是将 8 位数据编码成 10 位数据，编码后的数据中 0 和 1的个数相等，以保证数据的直流平衡。</p><p>当中 8bit 的原始数据可以分为两部分：<strong>低位的 5bitEDCBA(设其十进制数值为X)，高位的 3bit HGF(设其十进制数值为Y)，则该 8bit数据可以记为 D.X.Y。</strong> 比如待编码数据为 110_00011，高 3位数据的十进制为 6，低 5 位的十进制数据为 3，则 D.3.6 就表示110_00011。</p><p>编码时，低 5bit 原数据 EDCBA 经过 5B/6B 编码成为 6bit 码 abcdei，高3bit 原数据 HGF 经 3B/4B 成为 4bit 码fghj，最后再将两部分组合起来形成一个 10bit 码abcdeifghj，如下图所示：</p><figure><img src="/img/8b10b/image.png" alt="图 1 编码示意图" /><figcaption aria-hidden="true">图 1 编码示意图</figcaption></figure><p>另外，<strong>8B/10B 编码中还用到 12个控制字符，他们可以作为传输中帧起始、帧结束、传输空闲等状态标识，与数据字符的记法类似，控制字符一般记为K.X.Y。</strong> 8bit 数据有 256 种，加上 12 种控制字符，总共有 268种。10bit 数据有 1024 种，可以从 1024 种状态中选取 256 种 0 和 1个数相等的数据作为编码结果，在从剩下的数据中选取 12个作为控制字符，即常见的 K码。</p><p>8B/10B 编码中将 K28.1、K28.5 和 K28.7 作为 K码的控制字符，称为“comma”。在任意数据组合中，comma只作为控制字符出现，而在数据部分不会出现，因此可以用 comma字符指示帧的开始和结束标志，或用来修正和数据流对齐的控制字符。</p><h1 id="b10b编码表">3、8b/10b编码表</h1><p>我们首先要搞清楚三个概念：</p><ul><li><strong>编码对照表</strong>：用来对原始数据进行编码的查找表，在对原始8bit数据进行编码时，不需要进行一系列复杂的算法运算（自己推算也可），而是直接从查找表上去查找8bit 原始数据对应的 10bit 编码数据。</li><li><strong>Paireddisparity</strong>：成对差异即“1”的个数和“0”的个数相差 2个（完美平衡除外）。不论是 5B/6B编码还是 3B/4B编码，最终编码后的数据“1”和“0”的个数对比只有三种情况，第一种是“1”的个数比“0”的个数多2 个，第二种是“0”的个数比“1”的个数多 2个，第三种是“1”的个数和“0”的个数一样多。其中“1”的个数和“0”的个数一样多又称之为完美平衡，在完美平衡的状态下是不需要进行补偿的，只不过由于完美平衡的编码数量无法满足所有数据的编码需求，因此完美平衡实际是无法做到的。</li></ul><div class="note note-success">            <p>5位数据总共有32种状态，编码结果有6位数据，0和1数量相等的只有000_111、001_011…、110_001、111_000等20种状态。其中000_111和111_000存在三个连续相同的状态，并没有被使用。导致编码后0和1数据相等的结果就只有18种状态，并不能满足输入5位数据的32种数据状态，3B4B编码也有同样的问题。此时设计编码的人提出，一次编码如果不能保证编码结果0和1个数相等，那么可以让连续两次编码结果的0和1相等，也能满足要求。</p>          </div><ul><li><strong>Running disparity</strong>：运行不一致，在上文的 Paireddisparity中已经说过编码后的数据“1”的个数和“0”的个数不可能做到一直完美平衡（因为只有少数数据编码后是完美平衡，大多数数据编码后是成对差异的），要么“1”的个数比“0”多，要么反之。我们称这种“0”“1”个数差为“极性偏差”，用 RD 表示，当“1”的个数比“0”多的时候 RD的值为“+1”，反过来 RD 的值为“-1”。</li></ul><div class="note note-success">            <p>如果编码结果的1和0个数相等，称为平衡编码，此时RD的数值保持不变。如果编码结果1和0个数不等，称为非平衡编码，此时RD的数值翻转，下次编码采用RD对应数值的编码作为编码结果。</p>          </div><p>搞清楚这三个概念后，我们就可以开始进行 8B/10B 编码了。8B/10B 编码是由5B/6B 编码和 3B/4B 编码组成的，编码的过程是先进行 5B/6B 编码，再进行3B/4B 编码，最后将两部分编码结果组合成 10bit 编码。在编码的过程中，RD的数值会不断翻转，每次编码的起始 RD 都是上次编码结果的 RD。</p><div class="note note-info">            <p><strong>上次8B/10B编码结果的RD数值将用作本次5B/6B编码的起始RD，而3B/4B编码的起始RD等于上次5B/6B编码结果的RD，3B/4B编码结果的RD作为本次8B/10B编码的RD。</strong></p>          </div><p>对应的编码状态跳转如下图所示：</p><figure><img src="/img/8b10b/image-3.png" alt="图 2 编码状态跳转示意图" /><figcaption aria-hidden="true">图 2 编码状态跳转示意图</figcaption></figure><h2 id="b6b-编码表">3.1 5B/6B 编码表</h2><figure><img src="/img/8b10b/image-1.png" alt="图 3 5B/6B 编码表" /><figcaption aria-hidden="true">图 3 5B/6B 编码表</figcaption></figure><p>5bit 的数据位宽一共对应 32 个原始数据，所以在上图的 5B/6B编码中一共拥有 0~31个原始数据，其中“EDCBA”表示原始数据，“abcdei”表示编码后的数据。表中可以看到绝大多数数据都是有两个编码对应的，在实际使用的时候根据RD 的值来选择其中一个编码使用；还有一部分数据后面是携带标记符号的，如D.23、D.27、D.29、D.30，这些带标记符号的既是原始数据又是控制编码的一部分，主要用于K.x.7。其中还有一个 K28比较特殊，这是一个独立的控制编码不与数据复用，主要用于控制编码K.28.y。</p><h2 id="b4b-编码表">3.2 3B/4B 编码表</h2><figure><img src="/img/8b10b/image-2.png" alt="图 4 3B/4B 编码表" /><figcaption aria-hidden="true">图 4 3B/4B 编码表</figcaption></figure><p>在 3B/4B 编码当中大家要注意的是数字 7 有两种编码，分别是 D.x.P7 和D.x.A7，为什么要用两种编码方式呢？</p><div class="note note-success">            <p>主要是避免出现连续的 5 个“0”或“1”，例如当 RD 为 1 时对 D(11,7)进行编码，其中 11 编码后的数值是 110100 而 7 就只能使用 D.x.A7这种编码规则了，如果使用 D.x.P7 的编码规则，最后编码数据就成了1101000001，可以看到出现了连续的 5个“0”。因此大家在编码的时候一定要选择合适的编码规则。</p>          </div><p>在控制码的编码表中可以看到 K.x.1、 K.x.5、 K.x.7这三个控制码被特殊标记了，这三个特殊编码会和上文 5B/6B 编码中提到的 K28连用，组成 K.28.1、K.28.5 和 K.28.7三个特殊编码，这三个特殊编码是会出现连续 5个“0”或“1”的，这种特殊码又称之为“commasymbols”。它们不会出现在数据负荷部分，并且只要出现就一定是控制码，通常用它们作为帧的开始和结束标志，或者数据流对齐的控制字符。</p><p>除了K.28.1、K.28.5 和 K.28.7 这三个特殊编码外还要注意上文 5B/6B编码中提到的 D.23、D.27、D.29、D.30 这几个特殊数值，在控制码中他们只能和K.x.7 连用组成 K.23.7、K.27.7、K.29.7、K.30.7这四个特殊控制码。原因和数字 7 的两套编码规则一样，避免出现连续的 5个“0”或“1”。</p><p><strong>完整的控制码编码表如下：</strong></p><figure><img src="/img/8b10b/image-4.png" alt="图 5 控制码编码示意图" /><figcaption aria-hidden="true">图 5 控制码编码示意图</figcaption></figure><h1 id="b10b编码实例">4、8b/10b编码实例</h1><p>Xilinx<ahref="https://docs.amd.com/v/u/en-US/ug476_7Series_Transceivers">UG476</a>手册的附录有所有8B/10B 编码数据的结果, 以及对应的RD值。这里以手册中的数据为例，对 8B/10B编码进行实例分析。</p><div class="note note-info">            <p><strong>问题一</strong></p><p>请问 D.8.3 的 8B/10B 编码结果是多少？</p>          </div><p>第一个原始数据在进行编码的时候是默认 RD 为“-1”。D.8 的 5B/6B编码结果为 111001，5B/6B 编码完成后，RD 翻转变为 1。将 RD=1 作为 D.x.3的 3B/4B 编码起始 RD，根据查表得编码结果为 0011，再次将 RD翻转，作为本次 8B/10B 编码结果的 RD。因此<strong>起始 RD=-1 的编码结果为111001_0011。</strong></p><p>与正确答案一致，编码结果为 111001_0011：</p><figure><img src="/img/8b10b/image-5.png" alt="图 6 D.8.3 的 8B/10B 编码结果" /><figcaption aria-hidden="true">图 6 D.8.3 的 8B/10B编码结果</figcaption></figure><div class="note note-info">            <p><strong>问题二</strong></p><p>当前 RD=1，则 K.28.5、D.2.6、D.23.4 的编码结果依次是多少，且最终的 RD是多少？</p>          </div><p>首先 RD=1 时，查得 k.28 编码结果为 110000，这是不平衡编码，RD的最终结果会翻转，RD=-1；K.x.5 的3B/4B编码是 0101，这是平衡编码，因此 RD不变，等于 -1。</p><p>因此 D.2.6 的起始 RD=-1，首先 D.2 的 5B/6B 编码结果为 101101，RD翻转变为 1。D.x.6 的 3B/4B 编码结果为 0110，由于 D.x.6 是平衡编码，因此RD 保持不变，等于 1。故 D.2.6 的编码结果为 101101_0110，RD 最终为1。</p><p>最后，D.23.4 的起始 RD=1，D.23.4 的 5B6B 编码结果为 000101，RD 翻转为-1。之后 D.x.4 的编码结果为 1101，RD 的极性再次翻转为 1。</p><p>所以 K.28.5、D.2.6、D.23.4 的编码结果依次是110000_0101、101101_0110、000101_1101，RD 的最终取值为 1。D.2.6、D.23.4的手册查表结果如下图所示，与上述计算结果保持相同，证明编码规则没有问题。</p><figure><img src="/img/8b10b/image-7.png" alt="图 7 D.2.6 的 8B/10B 编码结果" /><figcaption aria-hidden="true">图 7 D.2.6 的 8B/10B编码结果</figcaption></figure><figure><img src="/img/8b10b/image-6.png"alt="图 8 D.23.4 的 8B/10B 编码结果" /><figcaption aria-hidden="true">图 8 D.23.4 的 8B/10B编码结果</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>高速收发器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字编码</tag>
      
      <tag>FPGA</tag>
      
      <tag>8b/10b</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/hello-world/"/>
    <url>/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre></div></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo server</code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo generate</code></pre></div></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure><div class="code-wrapper"><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo deploy</code></pre></div></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<center>繁星纵变，智慧永存！</center>]]></content>
    
  </entry>
  
  
  
</search>
